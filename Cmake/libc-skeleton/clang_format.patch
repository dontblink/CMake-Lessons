diff --git a/Cmake/libc-skeleton/BuildOptions.cmake b/Cmake/libc-skeleton/BuildOptions.cmake
index 1a4e449..2e669f5 100644
--- a/Cmake/libc-skeleton/BuildOptions.cmake
+++ b/Cmake/libc-skeleton/BuildOptions.cmake
@@ -1,91 +1,91 @@
-include(CMakeDependentOption)
-include(CheckIPOSupported)
-
-option(HIDE_UNIMPLEMENTED_C_APIS
-       "Make unimplemented libc functions invisible to the compiler."
-       OFF)
-
-option(ENABLE_GNU_EXTENSIONS
-       "Enable GNU extensions to the standard libc functions"
-       OFF)
-
-option(DISABLE_BUILTINS
-       "Disable builts to the library target but not it's dependencies"
-       ON)
-
-option(DISABLE_STACK_PROTECTION
-       "Disable stack protection on libc target and its dependencies"
-       ON)
-
-option(NOSTDINC_FOR_DEPENDENTS
-       "apply_supported_compiler_flags for -nostdinc should use a public scope when on, private when off"
-       OFF)
-
-CMAKE_DEPENDENT_OPTION(LIBC_BUILD_TESTING
-       "enables unit test builds when this project is used as a dependency in another project"
-       OFF
-       "NOT CMAKE_CROSSCOMPILING" OFF)
-
-if((NOT CMAKE_CROSSCOMPILING) AND BUILD_TESTING AND 
-   (LIBC_BUILD_TESTING OR (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)))
-	message("Enabling libc tests.")
-	set(LIBC_TESTING_IS_ENABLED ON CACHE INTERNAL "Logic that sets whether testing is enabled on this project")
-endif()
-
-#Set a default build type if none was specified
-set(default_build_type "RelWithDebInfo")
-if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-	message(STATUS "Setting build type to '${default_build_type}' as none was specified.")
-	set(CMAKE_BUILD_TYPE "${default_build_type}" CACHE
-	    STRING "choose the type of build"
-	    FORCE
-	    )
-
-# Set the possible values of build type for cmake-gui/cmake
-set_property(CACHE CMAKE_BUILD_TYPE
-             PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
-             
-endif()
-
-set(default_pic ON)
-if ("${CMAKE_POSITION_INDEPENDENT_CODE}" STREQUAL "")
-  message(STATUS "Setting PIC for all targets to '${default_pic}' as no value was specified.")
-  set(CMAKE_POSITION_INDEPENDENT_CODE ${default_pic} CACHE
-    BOOL "Compile all targets with -fPIC"
-    FORCE
-  )
-endif()
-
-set(default_shared_libs OFF)
-if ("${BUILD_SHARED_LIBS}" STREQUAL "")
-  message(STATUS "Setting 'build shared libraries' to '${default_shared_libs}' as no value was specified.")
-  set(BUILD_SHARED_LIBS ${default_shared_libs} CACHE
-	    BOOL "Compile shared libraries by default instead of static libraries."
-	    FORCE)
-endif()
-
-# Export compile_commands.json file
-set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
-
-check_ipo_supported(RESULT result)
-if("${result}")
-       option(ENABLE_LTO
-              "Enable link time optimization"
-              OFF)
-
-       # disable builtins, make it dependent on LTO and compiler checks
-       if(NOT "${ENABLE_LTO}" AND (${CMAKE_C_COMPILER_ID} STREQUAL Clang OR ${CMAKE_C_COMPILER_ID} STREQUAL AppleClang))
-              set(OPTION_DISABLE_BUILTINS_IS_ENABLED True)
-       else()
-              set(OPTION_DISABLE_BUILTINS_IS_ENABLED False)
-       endif()
-
-       CMAKE_DEPENDENT_OPTION(DISABLE_BUILTINS
-                              "Disable compiler builtins (-fno-builtin)."
-                              ON
-                              "${OPTION_DISABLE_BUILTINS_IS_ENABLED}"
-                              ON)
-       if("${ENABLE_LTO}")
-              set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
-       endif()
-endif()
+include(CMakeDependentOption)
+include(CheckIPOSupported)
+
+option(HIDE_UNIMPLEMENTED_C_APIS
+       "Make unimplemented libc functions invisible to the compiler."
+       OFF)
+
+option(ENABLE_GNU_EXTENSIONS
+       "Enable GNU extensions to the standard libc functions"
+       OFF)
+
+option(DISABLE_BUILTINS
+       "Disable builts to the library target but not it's dependencies"
+       ON)
+
+option(DISABLE_STACK_PROTECTION
+       "Disable stack protection on libc target and its dependencies"
+       ON)
+
+option(NOSTDINC_FOR_DEPENDENTS
+       "apply_supported_compiler_flags for -nostdinc should use a public scope when on, private when off"
+       OFF)
+
+CMAKE_DEPENDENT_OPTION(LIBC_BUILD_TESTING
+       "enables unit test builds when this project is used as a dependency in another project"
+       OFF
+       "NOT CMAKE_CROSSCOMPILING" OFF)
+
+if((NOT CMAKE_CROSSCOMPILING) AND BUILD_TESTING AND 
+   (LIBC_BUILD_TESTING OR (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)))
+	message("Enabling libc tests.")
+	set(LIBC_TESTING_IS_ENABLED ON CACHE INTERNAL "Logic that sets whether testing is enabled on this project")
+endif()
+
+#Set a default build type if none was specified
+set(default_build_type "RelWithDebInfo")
+if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
+	message(STATUS "Setting build type to '${default_build_type}' as none was specified.")
+	set(CMAKE_BUILD_TYPE "${default_build_type}" CACHE
+	    STRING "choose the type of build"
+	    FORCE
+	    )
+
+# Set the possible values of build type for cmake-gui/cmake
+set_property(CACHE CMAKE_BUILD_TYPE
+             PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
+             
+endif()
+
+set(default_pic ON)
+if ("${CMAKE_POSITION_INDEPENDENT_CODE}" STREQUAL "")
+  message(STATUS "Setting PIC for all targets to '${default_pic}' as no value was specified.")
+  set(CMAKE_POSITION_INDEPENDENT_CODE ${default_pic} CACHE
+    BOOL "Compile all targets with -fPIC"
+    FORCE
+  )
+endif()
+
+set(default_shared_libs OFF)
+if ("${BUILD_SHARED_LIBS}" STREQUAL "")
+  message(STATUS "Setting 'build shared libraries' to '${default_shared_libs}' as no value was specified.")
+  set(BUILD_SHARED_LIBS ${default_shared_libs} CACHE
+	    BOOL "Compile shared libraries by default instead of static libraries."
+	    FORCE)
+endif()
+
+# Export compile_commands.json file
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+
+check_ipo_supported(RESULT result)
+if("${result}")
+       option(ENABLE_LTO
+              "Enable link time optimization"
+              OFF)
+
+       # disable builtins, make it dependent on LTO and compiler checks
+       if(NOT "${ENABLE_LTO}" AND (${CMAKE_C_COMPILER_ID} STREQUAL Clang OR ${CMAKE_C_COMPILER_ID} STREQUAL AppleClang))
+              set(OPTION_DISABLE_BUILTINS_IS_ENABLED True)
+       else()
+              set(OPTION_DISABLE_BUILTINS_IS_ENABLED False)
+       endif()
+
+       CMAKE_DEPENDENT_OPTION(DISABLE_BUILTINS
+                              "Disable compiler builtins (-fno-builtin)."
+                              ON
+                              "${OPTION_DISABLE_BUILTINS_IS_ENABLED}"
+                              ON)
+       if("${ENABLE_LTO}")
+              set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
+       endif()
+endif()
diff --git a/Cmake/libc-skeleton/CMakeLists.txt b/Cmake/libc-skeleton/CMakeLists.txt
index a5617a7..e24a758 100644
--- a/Cmake/libc-skeleton/CMakeLists.txt
+++ b/Cmake/libc-skeleton/CMakeLists.txt
@@ -1,115 +1,138 @@
-cmake_minimum_required(VERSION 3.18)
-project(EmbeddedArtistryLibc 
-        VERSION 1.0 
-        DESCRIPTION "A libc implementation for microcontroller-based embedded systems." 
-        LANGUAGES C CXX)
-
-set_property(GLOBAL PROPERTY C_STANDARD 11)
-
-include(cmake/CPM.cmake)
-
-# Only use testing if we're not somebody's subproject!
-if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME OR LIBC_BUILD_TESTING)
-	include(CTest)
-endif()
-
-include(cmake/CheckAndApplyFlags.cmake)
-include(BuildOptions.cmake)
-
-# Compiler Flags
-if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
-	add_compile_options(-Wall -Wextra)
-endif()
-
-# generate map file in linker
-function(target_linker_map target)
-  check_c_linker_flag("-Wl,-Map,test.map" _Map1)
-  if("${_Map1}")
-    set(GEN_MAP_FILE "-Wl,-Map,")
-  else()
-    check_c_linker_flag("-Wl,-map,test.map" _Map2)
-    if("${_Map2}")
-      set(GEN_MAP_FILE "-Wl,-map,")
-    else()
-      message("[WARNING] ${CMAKE_C_COMPILER_ID} does not have a defined linker map argument. ")
-      return()
-    endif()
-  endif()
-  get_target_property(map_dir ${target} BINARY_DIR)
-  target_link_options(${target} PRIVATE ${GEN_MAP_FILE}${map_dir}/${target}.map)
-  set_target_properties(${target} PROPERTIES
-                        ADDITIONAL_CLEAN_FILES ${target}.map)
-endfunction()
-
-
-
-
-#####################
-# add printf module #
-#####################
-CPMAddPackage(
-  NAME printf
-  GITHUB_REPOSITORY embeddedartistry/printf
-  GIT_TAG 43e98e84
-  DOWNLOAD_ONLY ON
-)
-
-add_library(printf INTERFACE)
-target_sources(printf INTERFACE ${printf_SOURCE_DIR}/src/printf/printf.c)
-# Both include paths are added so that `#include <printf.h>` and `#include <printf/printf.h>` will work
-target_include_directories(printf SYSTEM INTERFACE ${printf_SOURCE_DIR}/src ${printf_SOURCE_DIR}/src/printf)
-target_compile_definitions(printf INTERFACE PRINTF_ALIAS_STANDARD_FUNCTION_NAMES_HARD PRINTF_INCLUDE_CONFIG_H=0)
-
-if(LIBC_TESTING_IS_ENABLED)
-  add_executable(printf_tests)
-  target_sources(printf_tests PRIVATE ${printf_SOURCE_DIR}/test/test_suite.cpp)
-  target_include_directories(printf_tests PRIVATE ${printf_SOURCE_DIR}/src)
-  set_target_properties(printf_tests PROPERTIES CXX_STANDARD 11)
-
-  # Re-build + execute tests, printing test information to the console instead of the XML file
-  add_custom_target(test-printf printf_tests)
-
-  add_test(NAME Printf.Test
-    COMMAND printf_tests -s -r junit -o ${CMAKE_BINARY_DIR}/printf_tests.xml
-  )
-  target_linker_map(printf_tests)
-endif()
-
-
-#######################
-# add openlibm module #
-#######################
-CPMAddPackage(
-              NAME openlibm
-              GITHUB_REPOSITORY embeddedartistry/openlibm
-              GIT_TAG 0418324
-              DOWNLOAD_ONLY ON
-              )
-add_library(openlibm INTERFACE)
-target_include_directories(openlibm SYSTEM INTERFACE
-                           ${openlibm_SOURCE_DIR}/src
-                           ${openlibm_SOURCE_DIR}/include)
-
-##############
-# add cmocka #
-##############
-
-if(LIBC_TESTING_IS_ENABLED)
-  CPMFindPackage(
-    NAME cmocka
-    GIT_REPOSITORY https://git.cryptomilk.org/projects/cmocka.git/
-    VERSION 1.1.7
-    GIT_TAG cmocka-1.1.7
-    OPTIONS
-      "WITH_EXAMPLES OFF"
-      "CMAKE_BUILD_TYPE DEBUG"
-  )
-endif()
-
-#process source tree
-add_subdirectory(src)
-
-#process test tree
-if(LIBC_TESTING_IS_ENABLED)
-	add_subdirectory(test)
-endif()
+cmake_minimum_required(VERSION 3.18)
+project(EmbeddedArtistryLibc 
+        VERSION 1.0 
+        DESCRIPTION "A libc implementation for microcontroller-based embedded systems." 
+        LANGUAGES C CXX ASM)
+
+set_property(GLOBAL PROPERTY C_STANDARD 11)
+
+include(cmake/CPM.cmake)
+
+# Only use testing if we're not somebody's subproject!
+if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME OR LIBC_BUILD_TESTING)
+	include(CTest)
+endif()
+
+include(cmake/CheckAndApplyFlags.cmake)
+include(BuildOptions.cmake)
+include(cmake/Conversions.cmake)
+include(cmake/AddExecutableWithLinkerScriptDep.cmake)
+# Compiler Flags
+if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
+	add_compile_options(-Wall -Wextra)
+endif()
+
+# generate map file in linker
+function(target_linker_map target)
+  check_c_linker_flag("-Wl,-Map,test.map" _Map1)
+  if("${_Map1}")
+    set(GEN_MAP_FILE "-Wl,-Map,")
+  else()
+    check_c_linker_flag("-Wl,-map,test.map" _Map2)
+    if("${_Map2}")
+      set(GEN_MAP_FILE "-Wl,-map,")
+    else()
+      message("[WARNING] ${CMAKE_C_COMPILER_ID} does not have a defined linker map argument. ")
+      return()
+    endif()
+  endif()
+  get_target_property(map_dir ${target} BINARY_DIR)
+  target_link_options(${target} PRIVATE ${GEN_MAP_FILE}${map_dir}/${target}.map)
+  set_target_properties(${target} PROPERTIES
+                        ADDITIONAL_CLEAN_FILES ${target}.map)
+endfunction()
+
+
+
+
+#####################
+# add printf module #
+#####################
+CPMAddPackage(
+  NAME printf
+  GITHUB_REPOSITORY embeddedartistry/printf
+  GIT_TAG 43e98e84
+  DOWNLOAD_ONLY ON
+)
+
+add_library(printf INTERFACE)
+target_sources(printf INTERFACE ${printf_SOURCE_DIR}/src/printf/printf.c)
+# Both include paths are added so that `#include <printf.h>` and `#include <printf/printf.h>` will work
+target_include_directories(printf SYSTEM INTERFACE ${printf_SOURCE_DIR}/src ${printf_SOURCE_DIR}/src/printf)
+target_compile_definitions(printf INTERFACE PRINTF_ALIAS_STANDARD_FUNCTION_NAMES_HARD PRINTF_INCLUDE_CONFIG_H=0)
+
+if(LIBC_TESTING_IS_ENABLED)
+  add_executable(printf_tests)
+  target_sources(printf_tests PRIVATE ${printf_SOURCE_DIR}/test/test_suite.cpp)
+  target_include_directories(printf_tests PRIVATE ${printf_SOURCE_DIR}/src)
+  set_target_properties(printf_tests PROPERTIES CXX_STANDARD 11)
+
+  # Re-build + execute tests, printing test information to the console instead of the XML file
+  add_custom_target(test-printf printf_tests)
+
+  add_test(NAME Printf.Test
+    COMMAND printf_tests -s -r junit -o ${CMAKE_BINARY_DIR}/printf_tests.xml
+  )
+  target_linker_map(printf_tests)
+endif()
+
+
+#######################
+# add openlibm module #
+#######################
+CPMAddPackage(
+              NAME openlibm
+              GITHUB_REPOSITORY embeddedartistry/openlibm
+              GIT_TAG 0418324
+              DOWNLOAD_ONLY ON
+              )
+add_library(openlibm INTERFACE)
+target_include_directories(openlibm SYSTEM INTERFACE
+                           ${openlibm_SOURCE_DIR}/src
+                           ${openlibm_SOURCE_DIR}/include)
+
+##############
+# add cmocka #
+##############
+
+if(LIBC_TESTING_IS_ENABLED)
+  CPMFindPackage(
+    NAME cmocka
+    GIT_REPOSITORY https://git.cryptomilk.org/projects/cmocka.git/
+    VERSION 1.1.7
+    GIT_TAG cmocka-1.1.7
+    OPTIONS
+      "WITH_EXAMPLES OFF"
+      "CMAKE_BUILD_TYPE DEBUG"
+  )
+endif()
+
+#process source tree
+add_subdirectory(arch/${CMAKE_SYSTEM_PROCESSOR}/)
+add_subdirectory(src)
+
+#process test tree
+
+add_subdirectory(test)
+
+find_program(DOXYGEN doxygen)
+
+if(DOXYGEN)
+  add_custom_target(docs
+                    COMMAND ${DOXYGEN} docs/Doxyfile
+                    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
+                    )
+  #this property will remove a directory, while add_custom_target BYPRODUCTS will not
+  set_target_properties(docs PROPERTIES ADDITIONAL_CLEAN_FILES ${CMAKE_BINARY_DIR}/doc/)
+endif()
+
+find_program(CLANG_FORMAT clang-format)
+if(CLANG_FORMAT)
+  add_custom_target(format
+                    COMMAND tools/format.sh
+                    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
+                    )
+  add_custom_target(format-patch
+                    COMMAND tools/format-patch.sh
+                    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR})
+endif()
diff --git a/Cmake/libc-skeleton/cmake/CheckAndApplyFlags.cmake b/Cmake/libc-skeleton/cmake/CheckAndApplyFlags.cmake
index 4752fab..8fd66ea 100644
--- a/Cmake/libc-skeleton/cmake/CheckAndApplyFlags.cmake
+++ b/Cmake/libc-skeleton/cmake/CheckAndApplyFlags.cmake
@@ -1,153 +1,153 @@
-
-# Read enabled languages to determine what functionality to provide
-get_property(enabled_languages GLOBAL PROPERTY ENABLED_LANGUAGES)
-
-###########################
-# Common Macros/Functions #
-###########################
-
-# Change - to _ to generate safe variable names
-macro(make_safe_varname input_string output_var)
-	string(REPLACE - _ ${output_var} ${input_string})
-endmacro()
-
-# Use this function to promote an input argument that represents a list
-# such that two layers of dereferencing aren't needed.
-# This enables supporting both string and variable inputs with a function arg.
-macro(check_and_double_deref input)
-	if(NOT "${${${input}}}" STREQUAL "")
-		set(${input} ${${${input}}})
-	endif()
-endmacro()
-
-#########################################
-# C Language Support (For CMake < 3.18) #
-#########################################
-
-if("C" IN_LIST enabled_languages)
-	include(CheckCCompilerFlag)
-
-	function(apply_supported_c_compiler_flags target scope flag_list)
-		check_and_double_deref(flag_list)
-		foreach(flag ${flag_list})
-			make_safe_varname(${flag} flag_var)
-			check_c_compiler_flag(${flag} ${flag_var})
-
-			if(${flag_var})
-				target_compile_options(${target} ${scope} ${flag})
-			endif()
-		endforeach()
-	endfunction()
-
-	function(check_c_linker_flag flag out_var)
-		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${flag}")
-  		check_c_compiler_flag("" ${out_var})
-	endfunction()
-
-	function(apply_supported_c_linker_flags target scope flag_list)
-		check_and_double_deref(flag_list)
-		foreach(flag ${flag_list})
-			make_safe_varname(${flag} flag_var)
-			check_c_linker_flag(${flag} ${flag_var})
-
-			if(${flag_var})
-				target_link_options(${target} ${scope} ${flag})
-			endif()
-		endforeach()
-	endfunction()
-endif()
-
-###########################################
-# CXX Language Support (For CMake < 3.18) #
-###########################################
-
-if("CXX" IN_LIST enabled_languages)
-	include(CheckCXXCompilerFlag)
-
-	function(apply_supported_cxx_compiler_flags target scope flag_list)
-		check_and_double_deref(flag_list)
-		foreach(flag ${flag_list})
-			make_safe_varname(${flag} flag_var)
-			check_cxx_compiler_flag(${flag} ${flag_var})
-
-			if(${flag_var})
-				target_compile_options(${target} ${scope} ${flag})
-			endif()
-		endforeach()
-	endfunction()
-
-	function(check_cxx_linker_flag flag out_var)
-		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${flag}")
-  		check_cxx_compiler_flag("" ${out_var})
-	endfunction()
-
-	function(apply_supported_cxx_linker_flags target scope flag_list)
-		check_and_double_deref(flag_list)
-		foreach(flag ${flag_list})
-			make_safe_varname(${flag} flag_var)
-			check_cxx_linker_flag(${flag} ${flag_var})
-
-			if(${flag_var})
-				target_link_options(${target} ${scope} ${flag})
-			endif()
-		endforeach()
-	endfunction()
-endif()
-
-#############################
-# Common Compiler Interface #
-#############################
-
-function(apply_supported_compiler_flags lang target scope flag_list)
-if(${CMAKE_VERSION} VERSION_LESS "3.18")
-	if(${lang} STREQUAL C)
-		apply_supported_c_compiler_flags(${target} ${scope} ${flag_list})
-	elseif(${lang} STREQUAL CXX)
-		apply_supported_cxx_compiler_flags(${target} ${scope} ${flag_list})
-	else()
-		message(FATAL_ERROR "Language ${lang} is not supported by this function.")
-	endif()
-else()
-	include(Check${lang}CompilerFlag)
-
-	check_and_double_deref(flag_list)
-	foreach(flag ${flag_list})
-		make_safe_varname(${flag} flag_var)
-		cmake_language(CALL check_${lang}_compiler_flag ${flag} ${flag_var})
-
-		if(${flag_var})
-			target_compile_options(${target} ${scope} ${flag})
-		endif()
-	endforeach()
-endif()
-endfunction()
-
-###########################
-# Common Linker Interface #
-###########################
-
-if(${CMAKE_VERSION} VERSION_LESS "3.18")
-	function(apply_supported_linker_flags lang target scope flag_list)
-		if(${lang} STREQUAL C)
-			apply_supported_c_linker_flags(${target} ${scope} ${flag_list})
-		elseif(${lang} STREQUAL CXX)
-			apply_supported_cxx_linker_flags(${target} ${scope} ${flag_list})
-		else()
-			message(FATAL_ERROR "Language ${lang} is not supported by this function.")
-		endif()
-	endfunction()
-else()
-	include(CheckLinkerFlag)
-
-	function(apply_supported_linker_flags lang target scope flag_list)
-		check_and_double_deref(flag_list)
-		foreach(flag ${flag_list})
-			make_safe_varname(${flag} flag_var)
-			check_linker_flag(${lang} ${flag} ${flag_var})
-
-			if(${flag_var})
-				target_link_options(${target} ${scope} ${flag})
-			endif()
-		endforeach()
-	endfunction()
-endif()
+
+# Read enabled languages to determine what functionality to provide
+get_property(enabled_languages GLOBAL PROPERTY ENABLED_LANGUAGES)
+
+###########################
+# Common Macros/Functions #
+###########################
+
+# Change - to _ to generate safe variable names
+macro(make_safe_varname input_string output_var)
+	string(REPLACE - _ ${output_var} ${input_string})
+endmacro()
+
+# Use this function to promote an input argument that represents a list
+# such that two layers of dereferencing aren't needed.
+# This enables supporting both string and variable inputs with a function arg.
+macro(check_and_double_deref input)
+	if(NOT "${${${input}}}" STREQUAL "")
+		set(${input} ${${${input}}})
+	endif()
+endmacro()
+
+#########################################
+# C Language Support (For CMake < 3.18) #
+#########################################
+
+if("C" IN_LIST enabled_languages)
+	include(CheckCCompilerFlag)
+
+	function(apply_supported_c_compiler_flags target scope flag_list)
+		check_and_double_deref(flag_list)
+		foreach(flag ${flag_list})
+			make_safe_varname(${flag} flag_var)
+			check_c_compiler_flag(${flag} ${flag_var})
+
+			if(${flag_var})
+				target_compile_options(${target} ${scope} ${flag})
+			endif()
+		endforeach()
+	endfunction()
+
+	function(check_c_linker_flag flag out_var)
+		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${flag}")
+  		check_c_compiler_flag("" ${out_var})
+	endfunction()
+
+	function(apply_supported_c_linker_flags target scope flag_list)
+		check_and_double_deref(flag_list)
+		foreach(flag ${flag_list})
+			make_safe_varname(${flag} flag_var)
+			check_c_linker_flag(${flag} ${flag_var})
+
+			if(${flag_var})
+				target_link_options(${target} ${scope} ${flag})
+			endif()
+		endforeach()
+	endfunction()
+endif()
+
+###########################################
+# CXX Language Support (For CMake < 3.18) #
+###########################################
+
+if("CXX" IN_LIST enabled_languages)
+	include(CheckCXXCompilerFlag)
+
+	function(apply_supported_cxx_compiler_flags target scope flag_list)
+		check_and_double_deref(flag_list)
+		foreach(flag ${flag_list})
+			make_safe_varname(${flag} flag_var)
+			check_cxx_compiler_flag(${flag} ${flag_var})
+
+			if(${flag_var})
+				target_compile_options(${target} ${scope} ${flag})
+			endif()
+		endforeach()
+	endfunction()
+
+	function(check_cxx_linker_flag flag out_var)
+		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${flag}")
+  		check_cxx_compiler_flag("" ${out_var})
+	endfunction()
+
+	function(apply_supported_cxx_linker_flags target scope flag_list)
+		check_and_double_deref(flag_list)
+		foreach(flag ${flag_list})
+			make_safe_varname(${flag} flag_var)
+			check_cxx_linker_flag(${flag} ${flag_var})
+
+			if(${flag_var})
+				target_link_options(${target} ${scope} ${flag})
+			endif()
+		endforeach()
+	endfunction()
+endif()
+
+#############################
+# Common Compiler Interface #
+#############################
+
+function(apply_supported_compiler_flags lang target scope flag_list)
+if(${CMAKE_VERSION} VERSION_LESS "3.18")
+	if(${lang} STREQUAL C)
+		apply_supported_c_compiler_flags(${target} ${scope} ${flag_list})
+	elseif(${lang} STREQUAL CXX)
+		apply_supported_cxx_compiler_flags(${target} ${scope} ${flag_list})
+	else()
+		message(FATAL_ERROR "Language ${lang} is not supported by this function.")
+	endif()
+else()
+	include(Check${lang}CompilerFlag)
+
+	check_and_double_deref(flag_list)
+	foreach(flag ${flag_list})
+		make_safe_varname(${flag} flag_var)
+		cmake_language(CALL check_${lang}_compiler_flag ${flag} ${flag_var})
+
+		if(${flag_var})
+			target_compile_options(${target} ${scope} ${flag})
+		endif()
+	endforeach()
+endif()
+endfunction()
+
+###########################
+# Common Linker Interface #
+###########################
+
+if(${CMAKE_VERSION} VERSION_LESS "3.18")
+	function(apply_supported_linker_flags lang target scope flag_list)
+		if(${lang} STREQUAL C)
+			apply_supported_c_linker_flags(${target} ${scope} ${flag_list})
+		elseif(${lang} STREQUAL CXX)
+			apply_supported_cxx_linker_flags(${target} ${scope} ${flag_list})
+		else()
+			message(FATAL_ERROR "Language ${lang} is not supported by this function.")
+		endif()
+	endfunction()
+else()
+	include(CheckLinkerFlag)
+
+	function(apply_supported_linker_flags lang target scope flag_list)
+		check_and_double_deref(flag_list)
+		foreach(flag ${flag_list})
+			make_safe_varname(${flag} flag_var)
+			check_linker_flag(${lang} ${flag} ${flag_var})
+
+			if(${flag_var})
+				target_link_options(${target} ${scope} ${flag})
+			endif()
+		endforeach()
+	endfunction()
+endif()
diff --git a/Cmake/libc-skeleton/cmake/toolchains/cross/arm-none-eabi-gcc.cmake b/Cmake/libc-skeleton/cmake/toolchains/cross/arm-none-eabi-gcc.cmake
index 8cb5751..7f31c0d 100644
--- a/Cmake/libc-skeleton/cmake/toolchains/cross/arm-none-eabi-gcc.cmake
+++ b/Cmake/libc-skeleton/cmake/toolchains/cross/arm-none-eabi-gcc.cmake
@@ -1,47 +1,51 @@
-set(CMAKE_SYSTEM_NAME Generic)
-set(CMAKE_SYSTEM_PROCESSOR arm)
-# Represents the name of the specific processor type, e.g. Cortex-M4
-if (NOT CPU_NAME)
-    set(CPU_NAME generic)
-endif()
-
-# make cmake toolchain variables to our toolchain's program names
-set(CMAKE_C_COMPILER arm-none-eabi-gcc)
-set(CMAKE_CXX_COMPILER arm-none-eabi-g++)
-set(AS arm-none-eabi-as)
-set(CMAKE_AR arm-none-eabi-gcc-ar)
-set(OBJCOPY arm-none-eabi-objcopy)
-set(OBJDUMP arm-none-eabi-objdump)
-set(SIZE arm-none-eabi-size)
-
-#tell cmake where to search for files when using the find_* functions
-# if set to ONLY, then only the roots in cmake_find_root_path (i.e. the host machine)
-# will be searched. If set to NEVER, then the roots in CMAKE_FIND_ROOT_PATH will
-# be ignored and only the build machien root will be used
-set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
-set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
-
-# Test compiles will use static libraries, so we won't need to define linker flags
-# and scripts for linking to succeed
-set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)
-
-# set compilation flags for our target
-# compile this program for a cortex-m4
-# use the hard floating point ABI, so floating point instructions will go to the FPU
-#	FPU standard is fpv4-sp-d16
-# use the ARM architecture Procedure Call Standard as the abi
-# Generate thumb instructions
-set(CMAKE_C_FLAGS_INIT
-    "${CPU_FLAGS} ${VFP_FLAGS} -fdata-sections -ffunction-sections"
-    CACHE
-    INTERNAL "Default C compiler flags.")
-set(CMAKE_CXX_FLAGS_INIT
-    "${CPU_FLAGS} ${VFP_FLAGS} -fdata-sections -ffunction-sections"
-    CACHE
-    INTERNAL "Default C++ compiler flags.")
-set(CMAKE_EXE_LINKER_FLAGS_INIT
-    "${LD_FLAGS} -Wl, --gc-sections"
-    CACHE
-    INTERNAL "Default linker flags.")
+set(CMAKE_SYSTEM_NAME Generic)
+set(CMAKE_SYSTEM_PROCESSOR arm)
+# Represents the name of the specific processor type, e.g. Cortex-M4
+if(NOT CPU_NAME)
+    set(CPU_NAME generic)
+endif()
+
+# make cmake toolchain variables to our toolchain's program names
+set(CMAKE_C_COMPILER arm-none-eabi-gcc)
+set(CMAKE_CXX_COMPILER arm-none-eabi-g++)
+set(AS arm-none-eabi-as)
+set(CMAKE_AR arm-none-eabi-gcc-ar)
+set(OBJCOPY arm-none-eabi-objcopy)
+set(OBJDUMP arm-none-eabi-objdump)
+set(SIZE arm-none-eabi-size)
+
+#tell cmake where to search for files when using the find_* functions
+# if set to ONLY, then only the roots in cmake_find_root_path (i.e. the host machine)
+# will be searched. If set to NEVER, then the roots in CMAKE_FIND_ROOT_PATH will
+# be ignored and only the build machien root will be used
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
+
+# Test compiles will use static libraries, so we won't need to define linker flags
+# and scripts for linking to succeed
+set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)
+
+# set compilation flags for our target
+# compile this program for a cortex-m4
+# use the hard floating point ABI, so floating point instructions will go to the FPU
+#	FPU standard is fpv4-sp-d16
+# use the ARM architecture Procedure Call Standard as the abi
+# Generate thumb instructions
+set(CMAKE_C_FLAGS_INIT
+    "${CPU_FLAGS} ${VFP_FLAGS} -fdata-sections -ffunction-sections"
+    CACHE
+    INTERNAL "Default C compiler flags.")
+set(CMAKE_CXX_FLAGS_INIT
+    "${CPU_FLAGS} ${VFP_FLAGS} -fdata-sections -ffunction-sections"
+    CACHE
+    INTERNAL "Default C++ compiler flags.")
+set(CMAKE_ASM_FLAGS_INIT
+    "${CPU_FLAGS} -x assembler-with-cpp"
+    CACHE
+    INTERNAL "Default ASM compiler flags.")
+set(CMAKE_EXE_LINKER_FLAGS_INIT
+    "${LD_FLAGS} -Wl,--gc-sections"
+    CACHE
+    INTERNAL "Default linker flags.")
diff --git a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m3_softfloat.cmake b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m3_softfloat.cmake
index c281eb1..9f23e32 100644
--- a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m3_softfloat.cmake
+++ b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m3_softfloat.cmake
@@ -1,11 +1,14 @@
-if($ENV{ARM_CORTEX_M3_TOOLCHAIN_INCLUDED})
-	return()
-endif()
-
-set(ENV{ARM_CORTEX_M3_TOOLCHAIN_INCLUDED} true)
-
-set(CPU_NAME cortex-m3)
-set(CPU_FLAGS, "-mcpu=cortex-m3 -mthumb")
-set(VFP_FLAGS, "-mfloat-abi=soft ")
-
-include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
+if($ENV{ARM_CORTEX_M3_TOOLCHAIN_INCLUDED})
+	return()
+endif()
+
+set(ENV{ARM_CORTEX_M3_TOOLCHAIN_INCLUDED} true)
+
+if(NOT CPU_NAME)
+	set(CPU_NAME cortex-m3)
+endif()
+
+set(CPU_FLAGS, "-mcpu=cortex-m3 -mthumb ${CPU_FLAGS}")
+set(VFP_FLAGS, "-mfloat-abi=soft ${VFP_FLAGS}")
+
+include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
diff --git a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m4_hardfloat.cmake b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m4_hardfloat.cmake
index 3bda640..73dea32 100644
--- a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m4_hardfloat.cmake
+++ b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m4_hardfloat.cmake
@@ -1,11 +1,13 @@
-if($ENV{ARM_CORTEX_M4_TOOLCHAIN_INCLUDED})
-    return()
-endif()
-
-set(ENV{ARM_CORTEX_M4_TOOLCHAIN_INCLUDED} true)
-
-set(CPU_NAME cortex-m4)
-set(CPU_FLAGS, "-mcpu=cortex-m4 -mthumb")
-set(VFP_FLAGS, "-mfloat-abi=hard -mfpu=fpv4-sp-d16 ")
-
-include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
+if($ENV{ARM_CORTEX_M4_TOOLCHAIN_INCLUDED})
+    return()
+endif()
+
+set(ENV{ARM_CORTEX_M4_TOOLCHAIN_INCLUDED} true)
+
+if(NOT CPU_NAME)
+    set(CPU_NAME cortex-m4)
+endif()
+set(CPU_FLAGS, "-mcpu=cortex-m4 -mthumb ${CPU_FLAGS}")
+set(VFP_FLAGS, "-mfloat-abi=hard -mfpu=fpv4-sp-d16  ${VFP_FLAGS}")
+
+include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
diff --git a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m7_hardfloat.cmake b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m7_hardfloat.cmake
index 80e5878..d9eb0e7 100644
--- a/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m7_hardfloat.cmake
+++ b/Cmake/libc-skeleton/cmake/toolchains/cross/cortex-m7_hardfloat.cmake
@@ -1,11 +1,14 @@
-if($ENV{ARM_CORTEX_M7_TOOLCHAIN_INCLUDED})
-	return()
-endif()
-
-set(ENV{ARM_CORTEX_M7_TOOLCHAIN_INCLUDED} true)
-
-set(CPU_NAME cortex-m7)
-set(CPU_FLAGS, "-mcpu=cortex-m7 -mthumb")
-set(VFP_FLAGS, "-mfloat-abi=hard -mfpu=fpv5-sp-d16 ")
-
-include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
+if($ENV{ARM_CORTEX_M7_TOOLCHAIN_INCLUDED})
+	return()
+endif()
+
+set(ENV{ARM_CORTEX_M7_TOOLCHAIN_INCLUDED} true)
+
+if(NOT CPU_NAME)
+	set(CPU_NAME cortex-m7)
+endif()
+
+set(CPU_FLAGS, "-mcpu=cortex-m7 -mthumb ${CPU_FLAGS}")
+set(VFP_FLAGS, "-mfloat-abi=hard -mfpu=fpv5-sp-d16  ${VFP_FLAGS}")
+
+include(${CMAKE_CURRENT_LIST_DIR}/arm-none-eabi-gcc.cmake)
diff --git a/Cmake/libc-skeleton/cmake/toolchains/native/clang.cmake b/Cmake/libc-skeleton/cmake/toolchains/native/clang.cmake
index c760b10..f915ddf 100644
--- a/Cmake/libc-skeleton/cmake/toolchains/native/clang.cmake
+++ b/Cmake/libc-skeleton/cmake/toolchains/native/clang.cmake
@@ -1,3 +1,3 @@
-set(CMAKE_C_COMPILER clang)
-set(CMAKE_CXX_COMPILER clang++)
-set(CMAKE_AR llvm-ar)
+set(CMAKE_C_COMPILER clang)
+set(CMAKE_CXX_COMPILER clang++)
+set(CMAKE_AR llvm-ar)
diff --git a/Cmake/libc-skeleton/docs/Doxyfile b/Cmake/libc-skeleton/docs/Doxyfile
index 03d9a8f..a8bc0a1 100644
--- a/Cmake/libc-skeleton/docs/Doxyfile
+++ b/Cmake/libc-skeleton/docs/Doxyfile
@@ -1,4 +1,4 @@
-# Doxyfile 1.8.13
+# Doxyfile 1.9.1
 
 # This file describes the settings to be used by the documentation system
 # doxygen (www.doxygen.org) for a project.
@@ -17,11 +17,11 @@
 # Project related configuration options
 #---------------------------------------------------------------------------
 
-# This tag specifies the encoding used for all characters in the config file
-# that follow. The default is UTF-8 which is also the encoding used for all text
-# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
-# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
-# for the list of possible encodings.
+# This tag specifies the encoding used for all characters in the configuration
+# file that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
 # The default value is: UTF-8.
 
 DOXYFILE_ENCODING      = UTF-8
@@ -93,6 +93,14 @@ ALLOW_UNICODE_NAMES    = NO
 
 OUTPUT_LANGUAGE        = English
 
+# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all generated output in the proper direction.
+# Possible values are: None, LTR, RTL and Context.
+# The default value is: None.
+
+OUTPUT_TEXT_DIRECTION  = None
+
 # If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
 # descriptions after the members that are listed in the file and class
 # documentation (similar to Javadoc). Set to NO to disable this.
@@ -189,6 +197,16 @@ SHORT_NAMES            = NO
 
 JAVADOC_AUTOBRIEF      = NO
 
+# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
+# such as
+# /***************
+# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
+# Javadoc-style will behave just like regular comments and it will not be
+# interpreted by doxygen.
+# The default value is: NO.
+
+JAVADOC_BANNER         = NO
+
 # If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
 # line (until the first dot) of a Qt-style comment as the brief description. If
 # set to NO, the Qt-style will behave just like regular Qt-style comments (thus
@@ -209,6 +227,14 @@ QT_AUTOBRIEF           = NO
 
 MULTILINE_CPP_IS_BRIEF = NO
 
+# By default Python docstrings are displayed as preformatted text and doxygen's
+# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the
+# doxygen's special commands can be used and the contents of the docstring
+# documentation blocks is shown as doxygen documentation.
+# The default value is: YES.
+
+PYTHON_DOCSTRING       = YES
+
 # If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
 # documentation from any documented member that it re-implements.
 # The default value is: YES.
@@ -236,16 +262,15 @@ TAB_SIZE               = 4
 # will allow you to put the command \sideeffect (or @sideeffect) in the
 # documentation, which will result in a user-defined paragraph with heading
 # "Side Effects:". You can put \n's in the value part of an alias to insert
-# newlines.
+# newlines (in the resulting output). You can put ^^ in the value part of an
+# alias to insert a newline as if a physical newline was in the original file.
+# When you need a literal { or } or , in the value part of an alias you have to
+# escape them by means of a backslash (\), this can lead to conflicts with the
+# commands \{ and \} for these it is advised to use the version @{ and @} or use
+# a double escape (\\{ and \\})
 
 ALIASES                =
 
-# This tag can be used to specify a number of word-keyword mappings (TCL only).
-# A mapping has the form "name=value". For example adding "class=itcl::class"
-# will allow you to use the command class in the itcl::class meaning.
-
-TCL_SUBST              =
-
 # Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
 # only. Doxygen will then generate output that is more tailored for C. For
 # instance, some of the names that are used will be different. The list of all
@@ -274,28 +299,40 @@ OPTIMIZE_FOR_FORTRAN   = NO
 
 OPTIMIZE_OUTPUT_VHDL   = NO
 
+# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
+# sources only. Doxygen will then generate output that is more tailored for that
+# language. For instance, namespaces will be presented as modules, types will be
+# separated into more groups, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_SLICE  = NO
+
 # Doxygen selects the parser to use depending on the extension of the files it
 # parses. With this tag you can assign which parser to use for a given
 # extension. Doxygen has a built-in mapping, but you can override or extend it
 # using this tag. The format is ext=language, where ext is a file extension, and
-# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
-# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
-# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
-# Fortran. In the later case the parser tries to guess whether the code is fixed
-# or free formatted code, this is the default for Fortran type files), VHDL. For
-# instance to make doxygen treat .inc files as Fortran files (default is PHP),
-# and .f files as C (default is Fortran), use: inc=Fortran f=C.
+# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
+# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice, VHDL,
+# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
+# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
+# tries to guess whether the code is fixed or free formatted code, this is the
+# default for Fortran type files). For instance to make doxygen treat .inc files
+# as Fortran files (default is PHP), and .f files as C (default is Fortran),
+# use: inc=Fortran f=C.
 #
 # Note: For files without extension you can use no_extension as a placeholder.
 #
 # Note that for custom extensions you also need to set FILE_PATTERNS otherwise
-# the files are not read by doxygen.
+# the files are not read by doxygen. When specifying no_extension you should add
+# * to the FILE_PATTERNS.
+#
+# Note see also the list of default file extension mappings.
 
 EXTENSION_MAPPING      =
 
 # If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
 # according to the Markdown format, which allows for more readable
-# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# documentation. See https://daringfireball.net/projects/markdown/ for details.
 # The output of markdown processing is further processed by doxygen, so you can
 # mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
 # case of backward compatibilities issues.
@@ -307,7 +344,7 @@ MARKDOWN_SUPPORT       = YES
 # to that level are automatically included in the table of contents, even if
 # they do not have an id attribute.
 # Note: This feature currently applies only to Markdown headings.
-# Minimum value: 0, maximum value: 99, default value: 0.
+# Minimum value: 0, maximum value: 99, default value: 5.
 # This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
 
 TOC_INCLUDE_HEADINGS   = 0
@@ -337,7 +374,7 @@ BUILTIN_STL_SUPPORT    = YES
 CPP_CLI_SUPPORT        = NO
 
 # Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
-# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
 # will parse them like normal C++ but will assume all classes use public instead
 # of private inheritance when no explicit protection keyword is present.
 # The default value is: NO.
@@ -423,6 +460,19 @@ TYPEDEF_HIDES_STRUCT   = NO
 
 LOOKUP_CACHE_SIZE      = 0
 
+# The NUM_PROC_THREADS specifies the number threads doxygen is allowed to use
+# during processing. When set to 0 doxygen will based this on the number of
+# cores available in the system. You can set it explicitly to a value larger
+# than 0 to get more control over the balance between CPU load and processing
+# speed. At this moment only the input processing can be done using multiple
+# threads. Since this is still an experimental feature the default is set to 1,
+# which efficively disables parallel processing. Please report any issues you
+# encounter. Generating dot graphs in parallel is controlled by the
+# DOT_NUM_THREADS setting.
+# Minimum value: 0, maximum value: 32, default value: 1.
+
+NUM_PROC_THREADS       = 1
+
 #---------------------------------------------------------------------------
 # Build related configuration options
 #---------------------------------------------------------------------------
@@ -443,6 +493,12 @@ EXTRACT_ALL            = YES
 
 EXTRACT_PRIVATE        = YES
 
+# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
+# methods of a class will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIV_VIRTUAL   = NO
+
 # If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
 # scope will be included in the documentation.
 # The default value is: NO.
@@ -480,6 +536,13 @@ EXTRACT_LOCAL_METHODS  = NO
 
 EXTRACT_ANON_NSPACES   = NO
 
+# If this flag is set to YES, the name of an unnamed parameter in a declaration
+# will be determined by the corresponding definition. By default unnamed
+# parameters remain unnamed in the output.
+# The default value is: YES.
+
+RESOLVE_UNNAMED_PARAMS = YES
+
 # If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
 # undocumented members inside documented classes or files. If set to NO these
 # members will be included in the various overviews, but no documentation
@@ -497,8 +560,8 @@ HIDE_UNDOC_MEMBERS     = NO
 HIDE_UNDOC_CLASSES     = NO
 
 # If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
-# (class|struct|union) declarations. If set to NO, these declarations will be
-# included in the documentation.
+# declarations. If set to NO, these declarations will be included in the
+# documentation.
 # The default value is: NO.
 
 HIDE_FRIEND_COMPOUNDS  = NO
@@ -517,11 +580,18 @@ HIDE_IN_BODY_DOCS      = NO
 
 INTERNAL_DOCS          = NO
 
-# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
-# names in lower-case letters. If set to YES, upper-case letters are also
-# allowed. This is useful if you have classes or files whose names only differ
-# in case and if your file system supports case sensitive file names. Windows
-# and Mac users are advised to set this option to NO.
+# With the correct setting of option CASE_SENSE_NAMES doxygen will better be
+# able to match the capabilities of the underlying filesystem. In case the
+# filesystem is case sensitive (i.e. it supports files in the same directory
+# whose names only differ in casing), the option must be set to YES to properly
+# deal with such files in case they appear in the input. For filesystems that
+# are not case sensitive the option should be be set to NO to properly deal with
+# output files written for symbols that only differ in casing, such as for two
+# classes, one named CLASS and the other named Class, and to also support
+# references to files without having to specify the exact matching casing. On
+# Windows (including Cygwin) and MacOS, users should typically set this option
+# to NO, whereas on Linux or other Unix flavors it should typically be set to
+# YES.
 # The default value is: system dependent.
 
 CASE_SENSE_NAMES       = NO
@@ -708,7 +778,7 @@ LAYOUT_FILE            =
 # The CITE_BIB_FILES tag can be used to specify one or more bib files containing
 # the reference definitions. This must be a list of .bib files. The .bib
 # extension is automatically appended if omitted. This requires the bibtex tool
-# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
 # For LaTeX the style of the bibliography can be controlled using
 # LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
 # search path. See also \cite for info how to create references.
@@ -753,13 +823,17 @@ WARN_IF_DOC_ERROR      = YES
 # This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
 # are documented, but have no documentation for their parameters or return
 # value. If set to NO, doxygen will only warn about wrong or incomplete
-# parameter documentation, but not about the absence of documentation.
+# parameter documentation, but not about the absence of documentation. If
+# EXTRACT_ALL is set to YES then this flag will automatically be disabled.
 # The default value is: NO.
 
 WARN_NO_PARAMDOC       = NO
 
 # If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
-# a warning is encountered.
+# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS
+# then doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but
+# at the end of the doxygen process doxygen will return with a non-zero status.
+# Possible values are: NO, YES and FAIL_ON_WARNINGS.
 # The default value is: NO.
 
 WARN_AS_ERROR          = NO
@@ -790,13 +864,15 @@ WARN_LOGFILE           =
 # spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
 # Note: If this tag is empty the current directory is searched.
 
-INPUT                  = include/ src/ docs/
+INPUT                  = include/ \
+                         src/ \
+                         docs/
 
 # This tag can be used to specify the character encoding of the source files
 # that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
 # libiconv (or the iconv built into libc) for the transcoding. See the libiconv
-# documentation (see: http://www.gnu.org/software/libiconv) for the list of
-# possible encodings.
+# documentation (see:
+# https://www.gnu.org/software/libiconv/) for the list of possible encodings.
 # The default value is: UTF-8.
 
 INPUT_ENCODING         = UTF-8
@@ -809,11 +885,15 @@ INPUT_ENCODING         = UTF-8
 # need to set EXTENSION_MAPPING for the extension otherwise the files are not
 # read by doxygen.
 #
+# Note the list of default checked file patterns might differ from the list of
+# default file extension mappings.
+#
 # If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
 # *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
 # *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
-# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
-# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.
+# *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C comment),
+# *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f18, *.f, *.for, *.vhd, *.vhdl,
+# *.ucf, *.qsf and *.ice.
 
 FILE_PATTERNS          = *.c \
                          *.cc \
@@ -889,7 +969,13 @@ EXCLUDE_SYMLINKS       = NO
 # Note that the wildcards are matched against the file with absolute path, so to
 # exclude all test directories for example use the pattern */test/*
 
-EXCLUDE_PATTERNS       = catch.hpp */cmocka/* */build/* */buildresults/* */docs/Doxyfile */docs/*enkinsfile */dependencies/*
+EXCLUDE_PATTERNS       = catch.hpp \
+                         */cmocka/* \
+                         */build/* \
+                         */buildresults/* \
+                         */docs/Doxyfile \
+                         */docs/*enkinsfile \
+                         */dependencies/*
 
 # The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
 # (namespaces, classes, functions, etc.) that should be excluded from the
@@ -1011,7 +1097,7 @@ INLINE_SOURCES         = YES
 STRIP_CODE_COMMENTS    = YES
 
 # If the REFERENCED_BY_RELATION tag is set to YES then for each documented
-# function all documented functions referencing it will be listed.
+# entity all documented functions referencing it will be listed.
 # The default value is: NO.
 
 REFERENCED_BY_RELATION = YES
@@ -1043,12 +1129,12 @@ SOURCE_TOOLTIPS        = YES
 # If the USE_HTAGS tag is set to YES then the references to source code will
 # point to the HTML generated by the htags(1) tool instead of doxygen built-in
 # source browser. The htags tool is part of GNU's global source tagging system
-# (see http://www.gnu.org/software/global/global.html). You will need version
+# (see https://www.gnu.org/software/global/global.html). You will need version
 # 4.8.6 or higher.
 #
 # To use it do the following:
 # - Install the latest version of global
-# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
 # - Make sure the INPUT points to the root of the source tree
 # - Run doxygen as normal
 #
@@ -1070,6 +1156,44 @@ USE_HTAGS              = NO
 
 VERBATIM_HEADERS       = YES
 
+# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
+# clang parser (see:
+# http://clang.llvm.org/) for more accurate parsing at the cost of reduced
+# performance. This can be particularly helpful with template rich C++ code for
+# which doxygen's built-in parser lacks the necessary type information.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled and the CLANG_ADD_INC_PATHS tag is set to
+# YES then doxygen will add the directory of each input to the include path.
+# The default value is: YES.
+
+CLANG_ADD_INC_PATHS    = YES
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          =
+
+# If clang assisted parsing is enabled you can provide the clang parser with the
+# path to the directory containing a file called compile_commands.json. This
+# file is the compilation database (see:
+# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) containing the
+# options used when the source files were built. This is equivalent to
+# specifying the -p option to a clang tool, such as clang-check. These options
+# will then be passed to the parser. Any options specified with CLANG_OPTIONS
+# will be added as well.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+
+CLANG_DATABASE_PATH    =
+
 #---------------------------------------------------------------------------
 # Configuration options related to the alphabetical class index
 #---------------------------------------------------------------------------
@@ -1081,13 +1205,6 @@ VERBATIM_HEADERS       = YES
 
 ALPHABETICAL_INDEX     = YES
 
-# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
-# which the alphabetical index list will be split.
-# Minimum value: 1, maximum value: 20, default value: 5.
-# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
-
-COLS_IN_ALPHA_INDEX    = 5
-
 # In case all classes in a project start with a common prefix, all classes will
 # be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
 # can be used to specify a prefix (or a list of prefixes) that should be ignored
@@ -1188,7 +1305,7 @@ HTML_EXTRA_FILES       =
 # The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
 # will adjust the colors in the style sheet and background images according to
 # this color. Hue is specified as an angle on a colorwheel, see
-# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
 # 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
 # purple, and 360 is red again.
 # Minimum value: 0, maximum value: 359, default value: 220.
@@ -1224,6 +1341,17 @@ HTML_COLORSTYLE_GAMMA  = 80
 
 HTML_TIMESTAMP         = NO
 
+# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
+# documentation will contain a main index with vertical navigation menus that
+# are dynamically created via JavaScript. If disabled, the navigation index will
+# consists of multiple levels of tabs that are statically embedded in every HTML
+# page. Disable this option to support browsers that do not have JavaScript,
+# like the Qt help browser.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_MENUS     = YES
+
 # If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
 # documentation will contain sections that can be hidden and shown after the
 # page has loaded.
@@ -1247,13 +1375,14 @@ HTML_INDEX_NUM_ENTRIES = 100
 
 # If the GENERATE_DOCSET tag is set to YES, additional index files will be
 # generated that can be used as input for Apple's Xcode 3 integrated development
-# environment (see: http://developer.apple.com/tools/xcode/), introduced with
-# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
-# Makefile in the HTML output directory. Running make will produce the docset in
-# that directory and running make install will install the docset in
+# environment (see:
+# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To
+# create a documentation set, doxygen will generate a Makefile in the HTML
+# output directory. Running make will produce the docset in that directory and
+# running make install will install the docset in
 # ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
-# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
-# for more information.
+# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
+# genXcode/_index.html for more information.
 # The default value is: NO.
 # This tag requires that the tag GENERATE_HTML is set to YES.
 
@@ -1292,8 +1421,8 @@ DOCSET_PUBLISHER_NAME  = Publisher
 # If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
 # additional HTML index files: index.hhp, index.hhc, and index.hhk. The
 # index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
-# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
-# Windows.
+# (see:
+# https://www.microsoft.com/en-us/download/details.aspx?id=21138) on Windows.
 #
 # The HTML Help Workshop contains a compiler that can convert all HTML output
 # generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
@@ -1323,7 +1452,7 @@ CHM_FILE               =
 HHC_LOCATION           =
 
 # The GENERATE_CHI flag controls if a separate .chi index file is generated
-# (YES) or that it should be included in the master .chm file (NO).
+# (YES) or that it should be included in the main .chm file (NO).
 # The default value is: NO.
 # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
 
@@ -1368,7 +1497,8 @@ QCH_FILE               =
 
 # The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
 # Project output. For more information please see Qt Help Project / Namespace
-# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
 # The default value is: org.doxygen.Project.
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
@@ -1376,8 +1506,8 @@ QHP_NAMESPACE          = org.doxygen.Project
 
 # The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
 # Help Project output. For more information please see Qt Help Project / Virtual
-# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
-# folders).
+# Folders (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).
 # The default value is: doc.
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
@@ -1385,30 +1515,30 @@ QHP_VIRTUAL_FOLDER     = doc
 
 # If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
 # filter to add. For more information please see Qt Help Project / Custom
-# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
-# filters).
+# Filters (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
 QHP_CUST_FILTER_NAME   =
 
 # The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
 # custom filter to add. For more information please see Qt Help Project / Custom
-# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
-# filters).
+# Filters (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
 QHP_CUST_FILTER_ATTRS  =
 
 # The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
 # project's filter section matches. Qt Help Project / Filter Attributes (see:
-# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
 QHP_SECT_FILTER_ATTRS  =
 
-# The QHG_LOCATION tag can be used to specify the location of Qt's
-# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
-# generated .qhp file.
+# The QHG_LOCATION tag can be used to specify the location (absolute path
+# including file name) of Qt's qhelpgenerator. If non-empty doxygen will try to
+# run qhelpgenerator on the generated .qhp file.
 # This tag requires that the tag GENERATE_QHP is set to YES.
 
 QHG_LOCATION           =
@@ -1485,6 +1615,17 @@ TREEVIEW_WIDTH         = 250
 
 EXT_LINKS_IN_WINDOW    = NO
 
+# If the HTML_FORMULA_FORMAT option is set to svg, doxygen will use the pdf2svg
+# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see
+# https://inkscape.org) to generate formulas as SVG images instead of PNGs for
+# the HTML output. These images will generally look nicer at scaled resolutions.
+# Possible values are: png (the default) and svg (looks nicer but requires the
+# pdf2svg or inkscape tool).
+# The default value is: png.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FORMULA_FORMAT    = png
+
 # Use this tag to change the font size of LaTeX formulas included as images in
 # the HTML documentation. When you change the font size after a successful
 # doxygen run you need to manually remove any form_*.png images from the HTML
@@ -1494,7 +1635,7 @@ EXT_LINKS_IN_WINDOW    = NO
 
 FORMULA_FONTSIZE       = 10
 
-# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
 # generated for formulas are transparent PNGs. Transparent PNGs are not
 # supported properly for IE 6.0, but are supported on all modern browsers.
 #
@@ -1505,8 +1646,14 @@ FORMULA_FONTSIZE       = 10
 
 FORMULA_TRANSPARENT    = YES
 
+# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
+# to create new LaTeX commands to be used in formulas as building blocks. See
+# the section "Including formulas" for details.
+
+FORMULA_MACROFILE      =
+
 # Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
-# http://www.mathjax.org) which uses client side Javascript for the rendering
+# https://www.mathjax.org) which uses client side JavaScript for the rendering
 # instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
 # installed or if you want to formulas look prettier in the HTML output. When
 # enabled you may also need to install MathJax separately and configure the path
@@ -1518,7 +1665,7 @@ USE_MATHJAX            = NO
 
 # When MathJax is enabled you can set the default output format to be used for
 # the MathJax output. See the MathJax site (see:
-# http://docs.mathjax.org/en/latest/output.html) for more details.
+# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details.
 # Possible values are: HTML-CSS (which is slower, but has the best
 # compatibility), NativeMML (i.e. MathML) and SVG.
 # The default value is: HTML-CSS.
@@ -1533,8 +1680,8 @@ MATHJAX_FORMAT         = HTML-CSS
 # MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
 # Content Delivery Network so you can quickly see the result without installing
 # MathJax. However, it is strongly recommended to install a local copy of
-# MathJax from http://www.mathjax.org before deployment.
-# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# MathJax from https://www.mathjax.org before deployment.
+# The default value is: https://cdn.jsdelivr.net/npm/mathjax@2.
 # This tag requires that the tag USE_MATHJAX is set to YES.
 
 MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
@@ -1548,7 +1695,8 @@ MATHJAX_EXTENSIONS     =
 
 # The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
 # of code that will be used on startup of the MathJax code. See the MathJax site
-# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# (see:
+# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details. For an
 # example see the documentation.
 # This tag requires that the tag USE_MATHJAX is set to YES.
 
@@ -1576,7 +1724,7 @@ MATHJAX_CODEFILE       =
 SEARCHENGINE           = YES
 
 # When the SERVER_BASED_SEARCH tag is enabled the search engine will be
-# implemented using a web server instead of a web client using Javascript. There
+# implemented using a web server instead of a web client using JavaScript. There
 # are two flavors of web server based searching depending on the EXTERNAL_SEARCH
 # setting. When disabled, doxygen will generate a PHP script for searching and
 # an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
@@ -1595,7 +1743,8 @@ SERVER_BASED_SEARCH    = NO
 #
 # Doxygen ships with an example indexer (doxyindexer) and search engine
 # (doxysearch.cgi) which are based on the open source search engine library
-# Xapian (see: http://xapian.org/).
+# Xapian (see:
+# https://xapian.org/).
 #
 # See the section "External Indexing and Searching" for details.
 # The default value is: NO.
@@ -1608,8 +1757,9 @@ EXTERNAL_SEARCH        = NO
 #
 # Doxygen ships with an example indexer (doxyindexer) and search engine
 # (doxysearch.cgi) which are based on the open source search engine library
-# Xapian (see: http://xapian.org/). See the section "External Indexing and
-# Searching" for details.
+# Xapian (see:
+# https://xapian.org/). See the section "External Indexing and Searching" for
+# details.
 # This tag requires that the tag SEARCHENGINE is set to YES.
 
 SEARCHENGINE_URL       =
@@ -1660,21 +1810,35 @@ LATEX_OUTPUT           = latex
 # The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
 # invoked.
 #
-# Note that when enabling USE_PDFLATEX this option is only used for generating
-# bitmaps for formulas in the HTML output, but not in the Makefile that is
-# written to the output directory.
-# The default file is: latex.
+# Note that when not enabling USE_PDFLATEX the default is latex when enabling
+# USE_PDFLATEX the default is pdflatex and when in the later case latex is
+# chosen this is overwritten by pdflatex. For specific output languages the
+# default can have been set differently, this depends on the implementation of
+# the output language.
 # This tag requires that the tag GENERATE_LATEX is set to YES.
 
 LATEX_CMD_NAME         = latex
 
 # The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
 # index for LaTeX.
+# Note: This tag is used in the Makefile / make.bat.
+# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
+# (.tex).
 # The default file is: makeindex.
 # This tag requires that the tag GENERATE_LATEX is set to YES.
 
 MAKEINDEX_CMD_NAME     = makeindex
 
+# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
+# generate index for LaTeX. In case there is no backslash (\) as first character
+# it will be automatically added in the LaTeX code.
+# Note: This tag is used in the generated output file (.tex).
+# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
+# The default value is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_MAKEINDEX_CMD    = makeindex
+
 # If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
 # documents. This may be useful for small projects and may help to save some
 # trees in general.
@@ -1759,9 +1923,11 @@ LATEX_EXTRA_FILES      =
 
 PDF_HYPERLINKS         = YES
 
-# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
-# the PDF file directly from the LaTeX files. Set this option to YES, to get a
-# higher quality PDF documentation.
+# If the USE_PDFLATEX tag is set to YES, doxygen will use the engine as
+# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX
+# files. Set this option to YES, to get a higher quality PDF documentation.
+#
+# See also section LATEX_CMD_NAME for selecting the engine.
 # The default value is: YES.
 # This tag requires that the tag GENERATE_LATEX is set to YES.
 
@@ -1795,7 +1961,7 @@ LATEX_SOURCE_CODE      = NO
 
 # The LATEX_BIB_STYLE tag can be used to specify the style to use for the
 # bibliography, e.g. plainnat, or ieeetr. See
-# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
 # The default value is: plain.
 # This tag requires that the tag GENERATE_LATEX is set to YES.
 
@@ -1809,6 +1975,14 @@ LATEX_BIB_STYLE        = plain
 
 LATEX_TIMESTAMP        = NO
 
+# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
+# path from which the emoji images will be read. If a relative path is entered,
+# it will be relative to the LATEX_OUTPUT directory. If left blank the
+# LATEX_OUTPUT directory will be used.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EMOJI_DIRECTORY  =
+
 #---------------------------------------------------------------------------
 # Configuration options related to the RTF output
 #---------------------------------------------------------------------------
@@ -1848,9 +2022,9 @@ COMPACT_RTF            = NO
 
 RTF_HYPERLINKS         = NO
 
-# Load stylesheet definitions from file. Syntax is similar to doxygen's config
-# file, i.e. a series of assignments. You only have to provide replacements,
-# missing definitions are set to their default value.
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# configuration file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
 #
 # See also section "Doxygen usage" for information on how to generate the
 # default style sheet that doxygen normally uses.
@@ -1859,8 +2033,8 @@ RTF_HYPERLINKS         = NO
 RTF_STYLESHEET_FILE    =
 
 # Set optional variables used in the generation of an RTF document. Syntax is
-# similar to doxygen's config file. A template extensions file can be generated
-# using doxygen -e rtf extensionFile.
+# similar to doxygen's configuration file. A template extensions file can be
+# generated using doxygen -e rtf extensionFile.
 # This tag requires that the tag GENERATE_RTF is set to YES.
 
 RTF_EXTENSIONS_FILE    =
@@ -1946,6 +2120,13 @@ XML_OUTPUT             = xml
 
 XML_PROGRAMLISTING     = YES
 
+# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
+# namespace members in file scope as well, matching the HTML output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_NS_MEMB_FILE_SCOPE = NO
+
 #---------------------------------------------------------------------------
 # Configuration options related to the DOCBOOK output
 #---------------------------------------------------------------------------
@@ -1978,9 +2159,9 @@ DOCBOOK_PROGRAMLISTING = NO
 #---------------------------------------------------------------------------
 
 # If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
-# AutoGen Definitions (see http://autogen.sf.net) file that captures the
-# structure of the code including all documentation. Note that this feature is
-# still experimental and incomplete at the moment.
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
 # The default value is: NO.
 
 GENERATE_AUTOGEN_DEF   = NO
@@ -2178,7 +2359,7 @@ HIDE_UNDOC_RELATIONS   = YES
 # http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
 # Bell Labs. The other options in this section have no effect if this option is
 # set to NO
-# The default value is: NO.
+# The default value is: YES.
 
 HAVE_DOT               = YES
 
@@ -2257,10 +2438,32 @@ UML_LOOK               = YES
 # but if the number exceeds 15, the total amount of fields shown is limited to
 # 10.
 # Minimum value: 0, maximum value: 100, default value: 10.
-# This tag requires that the tag HAVE_DOT is set to YES.
+# This tag requires that the tag UML_LOOK is set to YES.
 
 UML_LIMIT_NUM_FIELDS   = 10
 
+# If the DOT_UML_DETAILS tag is set to NO, doxygen will show attributes and
+# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS
+# tag is set to YES, doxygen will add type and arguments for attributes and
+# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, doxygen
+# will not generate fields with class member information in the UML graphs. The
+# class diagrams will look similar to the default class diagrams but using UML
+# notation for the relationships.
+# Possible values are: NO, YES and NONE.
+# The default value is: NO.
+# This tag requires that the tag UML_LOOK is set to YES.
+
+DOT_UML_DETAILS        = NO
+
+# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters
+# to display on a single line. If the actual line length exceeds this threshold
+# significantly it will wrapped across multiple lines. Some heuristics are apply
+# to avoid ugly line breaks.
+# Minimum value: 0, maximum value: 1000, default value: 17.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_WRAP_THRESHOLD     = 17
+
 # If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
 # collaboration graphs will show the relations between templates and their
 # instances.
@@ -2334,7 +2537,9 @@ DIRECTORY_GRAPH        = YES
 # Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
 # to make the SVG files visible in IE 9+ (other browsers do not have this
 # requirement).
-# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
+# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,
+# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,
+# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,
 # png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
 # png:gdiplus:gdiplus.
 # The default value is: png.
@@ -2365,7 +2570,7 @@ DOT_PATH               =
 # command).
 # This tag requires that the tag HAVE_DOT is set to YES.
 
-#DOTFILE_DIRS           = docs/dot/
+DOTFILE_DIRS           =
 
 # The MSCFILE_DIRS tag can be used to specify one or more directories that
 # contain msc files that are included in the documentation (see the \mscfile
@@ -2450,9 +2655,11 @@ DOT_MULTI_TARGETS      = YES
 
 GENERATE_LEGEND        = YES
 
-# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate
 # files that are used to generate the various graphs.
+#
+# Note: This setting is not only used for dot files but also for msc and
+# plantuml temporary files.
 # The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
 
 DOT_CLEANUP            = YES
diff --git a/Cmake/libc-skeleton/docs/LICENSES.md b/Cmake/libc-skeleton/docs/LICENSES.md
index be75d02..b1da7cf 100644
--- a/Cmake/libc-skeleton/docs/LICENSES.md
+++ b/Cmake/libc-skeleton/docs/LICENSES.md
@@ -1,189 +1,189 @@
-# Embedded Artistry libc
-
-MIT License
-
-Copyright (c) 2017 Embedded Artistry
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
-# musl libc
-
-musl as a whole is licensed under the following standard MIT license:
-
-----------------------------------------------------------------------
-Copyright © 2005-2014 Rich Felker, et al.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-----------------------------------------------------------------------
-
-Authors/contributors include:
-
-Alex Dowad
-Alexander Monakov
-Anthony G. Basile
-Arvid Picciani
-Bobby Bingham
-Boris Brezillon
-Brent Cook
-Chris Spiegel
-Clément Vasseur
-Daniel Micay
-Denys Vlasenko
-Emil Renner Berthing
-Felix Fietkau
-Felix Janda
-Gianluca Anzolin
-Hauke Mehrtens
-Hiltjo Posthuma
-Isaac Dunham
-Jaydeep Patil
-Jens Gustedt
-Jeremy Huntwork
-Jo-Philipp Wich
-Joakim Sindholt
-John Spencer
-Josiah Worcester
-Justin Cormack
-Khem Raj
-Kylie McClain
-Luca Barbato
-Luka Perkov
-M Farkas-Dyck (Strake)
-Mahesh Bodapati
-Michael Forney
-Natanael Copa
-Nicholas J. Kain
-orc
-Pascal Cuoq
-Petr Hosek
-Pierre Carrier
-Rich Felker
-Richard Pennington
-Shiz
-sin
-Solar Designer
-Stefan Kristiansson
-Szabolcs Nagy
-Timo Teräs
-Trutz Behn
-Valentin Ochs
-William Haddon
-
-Portions of this software are derived from third-party works licensed
-under terms compatible with the above MIT license:
-
-The TRE regular expression implementation (src/regex/reg* and
-src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed
-under a 2-clause BSD license (license text in the source files). The
-included version has been heavily modified by Rich Felker in 2012, in
-the interests of size, simplicity, and namespace cleanliness.
-
-Much of the math library code (src/math/* and src/complex/*) is
-Copyright © 1993,2004 Sun Microsystems or
-Copyright © 2003-2011 David Schultz or
-Copyright © 2003-2009 Steven G. Kargl or
-Copyright © 2003-2009 Bruce D. Evans or
-Copyright © 2008 Stephen L. Moshier
-and labelled as such in comments in the individual source files. All
-have been licensed under extremely permissive terms.
-
-The ARM memcpy code (src/string/arm/memcpy_el.S) is Copyright © 2008
-The Android Open Source Project and is licensed under a two-clause BSD
-license. It was taken from Bionic libc, used on Android.
-
-The implementation of DES for crypt (src/crypt/crypt_des.c) is
-Copyright © 1994 David Burren. It is licensed under a BSD license.
-
-The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was
-originally written by Solar Designer and placed into the public
-domain. The code also comes with a fallback permissive license for use
-in jurisdictions that may not recognize the public domain.
-
-The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011
-Valentin Ochs and is licensed under an MIT-style license.
-
-The BSD PRNG implementation (src/prng/random.c) and XSI search API
-(src/search/*.c) functions are Copyright © 2011 Szabolcs Nagy and
-licensed under following terms: "Permission to use, copy, modify,
-and/or distribute this code for any purpose with or without fee is
-hereby granted. There is no warranty."
-
-The x86_64 port was written by Nicholas J. Kain and is licensed under
-the standard MIT terms.
-
-The mips and microblaze ports were originally written by Richard
-Pennington for use in the ellcc project. The original code was adapted
-by Rich Felker for build system and code conventions during upstream
-integration. It is licensed under the standard MIT terms.
-
-The mips64 port was contributed by Imagination Technologies and is
-licensed under the standard MIT terms.
-
-The powerpc port was also originally written by Richard Pennington,
-and later supplemented and integrated by John Spencer. It is licensed
-under the standard MIT terms.
-
-All other files which have no copyright comments are original works
-produced specifically for use as part of this library, written either
-by Rich Felker, the main author of the library, or by one or more
-contibutors listed above. Details on authorship of individual files
-can be found in the git version control history of the project. The
-omission of copyright and license comments in each file is in the
-interest of source tree size.
-
-In addition, permission is hereby granted for all public header files
-(include/* and arch/*/bits/*) and crt files intended to be linked into
-applications (crt/*, ldso/dlstart.c, and arch/*/crt_arch.h) to omit
-the copyright notice and permission notice otherwise required by the
-license, and to use these files without any requirement of
-attribution. These files include substantial contributions from:
-
-Bobby Bingham
-John Spencer
-Nicholas J. Kain
-Rich Felker
-Richard Pennington
-Stefan Kristiansson
-Szabolcs Nagy
-
-all of whom have explicitly granted such permission.
-
-This file previously contained text expressing a belief that most of
-the files covered by the above exception were sufficiently trivial not
-to be subject to copyright, resulting in confusion over whether it
-negated the permissions granted in the license. In the spirit of
-permissive licensing, and of not having licensing issues being an
-obstacle to adoption, that text has been removed.
+# Embedded Artistry libc
+
+MIT License
+
+Copyright (c) 2017 Embedded Artistry
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+# musl libc
+
+musl as a whole is licensed under the following standard MIT license:
+
+----------------------------------------------------------------------
+Copyright © 2005-2014 Rich Felker, et al.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------
+
+Authors/contributors include:
+
+Alex Dowad
+Alexander Monakov
+Anthony G. Basile
+Arvid Picciani
+Bobby Bingham
+Boris Brezillon
+Brent Cook
+Chris Spiegel
+Clément Vasseur
+Daniel Micay
+Denys Vlasenko
+Emil Renner Berthing
+Felix Fietkau
+Felix Janda
+Gianluca Anzolin
+Hauke Mehrtens
+Hiltjo Posthuma
+Isaac Dunham
+Jaydeep Patil
+Jens Gustedt
+Jeremy Huntwork
+Jo-Philipp Wich
+Joakim Sindholt
+John Spencer
+Josiah Worcester
+Justin Cormack
+Khem Raj
+Kylie McClain
+Luca Barbato
+Luka Perkov
+M Farkas-Dyck (Strake)
+Mahesh Bodapati
+Michael Forney
+Natanael Copa
+Nicholas J. Kain
+orc
+Pascal Cuoq
+Petr Hosek
+Pierre Carrier
+Rich Felker
+Richard Pennington
+Shiz
+sin
+Solar Designer
+Stefan Kristiansson
+Szabolcs Nagy
+Timo Teräs
+Trutz Behn
+Valentin Ochs
+William Haddon
+
+Portions of this software are derived from third-party works licensed
+under terms compatible with the above MIT license:
+
+The TRE regular expression implementation (src/regex/reg* and
+src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed
+under a 2-clause BSD license (license text in the source files). The
+included version has been heavily modified by Rich Felker in 2012, in
+the interests of size, simplicity, and namespace cleanliness.
+
+Much of the math library code (src/math/* and src/complex/*) is
+Copyright © 1993,2004 Sun Microsystems or
+Copyright © 2003-2011 David Schultz or
+Copyright © 2003-2009 Steven G. Kargl or
+Copyright © 2003-2009 Bruce D. Evans or
+Copyright © 2008 Stephen L. Moshier
+and labelled as such in comments in the individual source files. All
+have been licensed under extremely permissive terms.
+
+The ARM memcpy code (src/string/arm/memcpy_el.S) is Copyright © 2008
+The Android Open Source Project and is licensed under a two-clause BSD
+license. It was taken from Bionic libc, used on Android.
+
+The implementation of DES for crypt (src/crypt/crypt_des.c) is
+Copyright © 1994 David Burren. It is licensed under a BSD license.
+
+The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was
+originally written by Solar Designer and placed into the public
+domain. The code also comes with a fallback permissive license for use
+in jurisdictions that may not recognize the public domain.
+
+The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011
+Valentin Ochs and is licensed under an MIT-style license.
+
+The BSD PRNG implementation (src/prng/random.c) and XSI search API
+(src/search/*.c) functions are Copyright © 2011 Szabolcs Nagy and
+licensed under following terms: "Permission to use, copy, modify,
+and/or distribute this code for any purpose with or without fee is
+hereby granted. There is no warranty."
+
+The x86_64 port was written by Nicholas J. Kain and is licensed under
+the standard MIT terms.
+
+The mips and microblaze ports were originally written by Richard
+Pennington for use in the ellcc project. The original code was adapted
+by Rich Felker for build system and code conventions during upstream
+integration. It is licensed under the standard MIT terms.
+
+The mips64 port was contributed by Imagination Technologies and is
+licensed under the standard MIT terms.
+
+The powerpc port was also originally written by Richard Pennington,
+and later supplemented and integrated by John Spencer. It is licensed
+under the standard MIT terms.
+
+All other files which have no copyright comments are original works
+produced specifically for use as part of this library, written either
+by Rich Felker, the main author of the library, or by one or more
+contibutors listed above. Details on authorship of individual files
+can be found in the git version control history of the project. The
+omission of copyright and license comments in each file is in the
+interest of source tree size.
+
+In addition, permission is hereby granted for all public header files
+(include/* and arch/*/bits/*) and crt files intended to be linked into
+applications (crt/*, ldso/dlstart.c, and arch/*/crt_arch.h) to omit
+the copyright notice and permission notice otherwise required by the
+license, and to use these files without any requirement of
+attribution. These files include substantial contributions from:
+
+Bobby Bingham
+John Spencer
+Nicholas J. Kain
+Rich Felker
+Richard Pennington
+Stefan Kristiansson
+Szabolcs Nagy
+
+all of whom have explicitly granted such permission.
+
+This file previously contained text expressing a belief that most of
+the files covered by the above exception were sufficiently trivial not
+to be subject to copyright, resulting in confusion over whether it
+negated the permissions granted in the license. In the spirit of
+permissive licensing, and of not having licensing issues being an
+obstacle to adoption, that text has been removed.
diff --git a/Cmake/libc-skeleton/docs/licenses/printf_LICENSE b/Cmake/libc-skeleton/docs/licenses/printf_LICENSE
index 8f7ebd0..8140739 100644
--- a/Cmake/libc-skeleton/docs/licenses/printf_LICENSE
+++ b/Cmake/libc-skeleton/docs/licenses/printf_LICENSE
@@ -1,22 +1,22 @@
-The MIT License (MIT)
-
-Copyright (c) 2014 Marco Paland
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
+The MIT License (MIT)
+
+Copyright (c) 2014 Marco Paland
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
diff --git a/Cmake/libc-skeleton/src/CMakeLists.txt b/Cmake/libc-skeleton/src/CMakeLists.txt
index c628ac1..7e75528 100644
--- a/Cmake/libc-skeleton/src/CMakeLists.txt
+++ b/Cmake/libc-skeleton/src/CMakeLists.txt
@@ -1,300 +1,305 @@
-add_library(gdtoa INTERFACE)
-target_sources(gdtoa INTERFACE
-	gdtoa/src/dmisc.c
-	gdtoa/src/dtoa.c
-	gdtoa/src/g__fmt.c
-	gdtoa/src/g_ddfmt.c
-	gdtoa/src/g_dfmt.c
-	gdtoa/src/g_ffmt.c
-	gdtoa/src/g_Qfmt.c
-	gdtoa/src/g_xfmt.c
-	gdtoa/src/g_xLfmt.c
-	gdtoa/src/gdtoa.c
-	gdtoa/src/gethex.c
-	gdtoa/src/gmisc.c
-	gdtoa/src/hd_init.c
-	gdtoa/src/hexnan.c
-	gdtoa/src/misc.c
-	gdtoa/src/smisc.c
-	gdtoa/src/strtod.c
-	gdtoa/src/strtodg.c
-	gdtoa/src/strtodI.c
-	gdtoa/src/strtof.c
-	gdtoa/src/strtoId.c
-	gdtoa/src/strtoIdd.c
-	gdtoa/src/strtoIf.c
-	gdtoa/src/strtoIg.c
-	gdtoa/src/strtoIQ.c
-	gdtoa/src/strtoIx.c
-	gdtoa/src/strtoIxL.c
-	gdtoa/src/strtopd.c
-	gdtoa/src/strtopdd.c
-	gdtoa/src/strtopf.c
-	gdtoa/src/strtopQ.c
-	gdtoa/src/strtopx.c
-	gdtoa/src/strtopxL.c
-	gdtoa/src/strtord.c
-	gdtoa/src/strtordd.c
-	gdtoa/src/strtorf.c
-	gdtoa/src/strtorQ.c
-	gdtoa/src/strtorx.c
-	gdtoa/src/strtorxL.c
-	gdtoa/src/sum.c
-	gdtoa/src/ulp.c
-)
-
-target_include_directories(gdtoa INTERFACE gdtoa/include)
-target_compile_definitions(gdtoa INTERFACE
-                           NO_ERRNO
-                           IFNAN_CHECK
-                           GDTOA_NO_ASSERT
-                           NO_FENV_H)
-
-#Libc
-
-#libc_core contains shared files and definitions that are used by libc and libc_hosted
-add_library(c_core INTERFACE)
-target_link_libraries(c_core INTERFACE printf openlibm gdtoa)
-target_include_directories(c_core  
-   INTERFACE 
-       ${PROJECT_SOURCE_DIR}/include
-       ${PROJECT_SOURCE_DIR}/arch/${CMAKE_SYSTEM_PROCESSOR}/include
-)
-
-#libc is a standalone version of the library
-add_library(c)
-target_link_libraries(c PRIVATE c_core)
-
-#libc_hosted is designed to be used with an operating system that provides a full implementation
-#which can do the heavy lifting for missing pieces
-add_library(c_hosted)
-target_link_libraries(c_hosted PRIVATE c_core)
-
-# Apply unconditional private flags here
-list(APPEND libc_private_compile_flags
-	"-Wno-nonnull-compare"
-     "-Wno-unknown-pragmas"
-)
-
-list(APPEND libc_public_flags
-     "")
-
-if (DISABLE_BUILTINS)
-	list(APPEND libc_private_flags -fno-builtin)
-endif()
-
-if(DISABLE_STACK_PROTECTION)
-	list(APPEND libc_public_flags -fno-stack-protector)
-endif()
-
-if(NOSTDINC_FOR_DEPENDENTS)
-	list(APPEND libc_public_flags -nostdinc)
-else()
-	list(APPEND libc_private_flags -nostdinc)
-endif()
-
-
-# Apply common settings to C and C_hosted targets
-foreach(target c c_hosted)
-	target_include_directories(${target} 
-		INTERFACE SYSTEM
-			$<TARGET_PROPERTY:openlibm,INTERFACE_INCLUDE_DIRECTORIES>
-			${PROJECT_SOURCE_DIR}/include
-			${PROJECT_SOURCE_DIR}/arch/${CMAKE_SYSTEM_PROCESSOR}/include
-	)
-
-	target_compile_definitions(${target}
-		INTERFACE
-			$<$<BOOL:${HIDE_UNIMPLEMENTED_C_APIS}>:DISABLE_UNIMPLEMENTED_LIBC_APIS>
-		PUBLIC
-			$<$<BOOL:${ENABLE_GNU_EXTENSIONS}>:_GNU_SOURCE>
-		PRIVATE
-			# Define a DEBUG symbol if we're using a Debug or Relase with Debug Info buildtype
-			$<$<OR:$<STREQUAL:${CMAKE_BUILD_TYPE},Debug>,$<STREQUAL:${CMAKE_BUILD_TYPE},RelWithDebInfo>>:DEBUG>
-		)
-
-
-
-	apply_supported_compiler_flags(C ${target} PRIVATE libc_private_flags)
-	apply_supported_compiler_flags(C ${target} PUBLIC libc_public_flags)
-endforeach()	
-
-if(NOT ((${CMAKE_C_COMPILER_ID} STREQUAL "Clang") OR (${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")))
-	check_c_compiler_flag("-nolibc" _nolibc)
-	#Clang doesn't handle -nolibc, so we need to upgrade to `-nostdlib`
-endif()
-
-if("${_nolibc}")
-	target_link_options(c INTERFACE "-nolibc")
-else()	
-	check_c_compiler_flag("-nostdlib" _nostdlib)
-	if("${_nostdlib}")
-		target_link_options(c INTERFACE "-nostdlib")	
-	endif()
-endif()
-
-# Assert Module
-target_sources(c_core INTERFACE
-               assert/assert.c)
-
-target_sources(c PRIVATE
-	crt/_Exit.c
-	crt/abort.c
-	crt/at_exit.c
-	crt/at_quick_exit.c
-	crt/crt.c
-	crt/cxa_atexit.c
-	crt/exit.c
-	crt/quick_exit.c
-)
-
-# CType Module                         
-target_sources(c_core INTERFACE
-	ctype/isalnum.c
-	ctype/isalpha.c
-	ctype/isascii.c
-	ctype/isblank.c
-	ctype/iscntrl.c
-	ctype/isdigit.c
-	ctype/isgraph.c
-	ctype/islower.c
-	ctype/isprint.c
-	ctype/ispunct.c
-	ctype/isspace.c
-	ctype/isupper.c
-	ctype/isxdigit.c
-	ctype/toascii.c
-	ctype/tolower.c
-	ctype/toupper.c
-)
-
-# locale Module
-target_sources(c_core INTERFACE
-	locale/langinfo.c
-)
-
-# math Module
-target_sources(c_core INTERFACE
-	math/fabs.c
-	math/fabsf.c
-)
-
-# stdio Module
-target_sources(c_core INTERFACE
-	stdio/asprintf.c
-	stdio/putchar.c
-	stdio/puts.c
-	stdio/vasprintf.c
-)
-
-# stdio Hosted Module
-target_sources(c_hosted PRIVATE
-	stdio/putchar_native.c
-)
-
-# stdlib Module
-target_sources(c_core INTERFACE
-	stdlib/abs.c
-	stdlib/atof.c
-	stdlib/atoi.c
-	stdlib/atol.c
-	stdlib/atoll.c
-	stdlib/bsearch.c
-	stdlib/calloc.c
-	stdlib/div.c
-	stdlib/heapsort_r.c
-	stdlib/heapsort.c
-	stdlib/imaxabs.c
-	stdlib/imaxdiv.c
-	stdlib/labs.c
-	stdlib/ldiv.c
-	stdlib/llabs.c
-	stdlib/lldiv.c
-	stdlib/qsort_r.c
-	stdlib/qsort.c
-	stdlib/rand.c
-	stdlib/realloc.c
-	stdlib/strtol.c
-	stdlib/strtold.c
-	stdlib/strtoul.c
-	stdlib/strtoll.c
-	stdlib/strtoull.c
-)
-
-# string Module
-target_sources(c_core INTERFACE
-               string/memcmp.c
-               string/memcpy.c
-               string/memmem.c
-               string/memmove.c
-               string/memchr.c
-               string/memrchr.c
-               string/memset.c
-               string/strcat.c
-               string/strchr.c
-               string/strchrnul.c
-               string/strcmp.c
-               string/strcoll.c
-               string/strcpy.c
-               string/strcspn.c
-               string/strdup.c
-               string/strerror.c
-               string/strerror_r.c
-               string/strlen.c
-               string/strncat.c
-               string/strncmp.c
-               string/strncpy.c
-               string/strndup.c
-               string/strnlen.c
-               string/strnstr.c
-               string/strpbrk.c
-               string/strrchr.c
-               string/strspn.c
-               string/strstr.c
-               string/strtok.c
-	string/strxfrm.c
-)
-
-# support Module
-target_sources(c_core INTERFACE
-	support/fls.c
-	support/flsl.c
-	support/flsll.c
-)
-
-# time Module
-target_sources(c_core INTERFACE
-	time/asctime.c
-	time/asctime_r.c
-)
-
-# wchar Module
-target_sources(c_core INTERFACE
-	wchar/iswalnum.c
-	wchar/iswalpha.c
-	wchar/iswblank.c
-	wchar/iswcntrl.c
-	wchar/iswalnum.c
-	wchar/iswalpha.c
-	wchar/iswblank.c
-	wchar/iswcntrl.c
-	wchar/iswctype.c
-	wchar/iswdigit.c
-	wchar/iswgraph.c
-	wchar/iswlower.c
-	wchar/iswprint.c
-	wchar/iswpunct.c
-	wchar/iswspace.c
-	wchar/iswupper.c
-	wchar/iswxdigit.c
-	wchar/towccase.c
-	wchar/towctrans.c
-	wchar/towlower.c
-	wchar/towupper.c
-	wchar/wcswidth.c
-	wchar/wctrans.c
-	wchar/wctype.c
-	wchar/wcwidth.c
-)
-
-
+add_library(gdtoa INTERFACE)
+target_sources(gdtoa INTERFACE
+	gdtoa/src/dmisc.c
+	gdtoa/src/dtoa.c
+	gdtoa/src/g__fmt.c
+	gdtoa/src/g_ddfmt.c
+	gdtoa/src/g_dfmt.c
+	gdtoa/src/g_ffmt.c
+	gdtoa/src/g_Qfmt.c
+	gdtoa/src/g_xfmt.c
+	gdtoa/src/g_xLfmt.c
+	gdtoa/src/gdtoa.c
+	gdtoa/src/gethex.c
+	gdtoa/src/gmisc.c
+	gdtoa/src/hd_init.c
+	gdtoa/src/hexnan.c
+	gdtoa/src/misc.c
+	gdtoa/src/smisc.c
+	gdtoa/src/strtod.c
+	gdtoa/src/strtodg.c
+	gdtoa/src/strtodI.c
+	gdtoa/src/strtof.c
+	gdtoa/src/strtoId.c
+	gdtoa/src/strtoIdd.c
+	gdtoa/src/strtoIf.c
+	gdtoa/src/strtoIg.c
+	gdtoa/src/strtoIQ.c
+	gdtoa/src/strtoIx.c
+	gdtoa/src/strtoIxL.c
+	gdtoa/src/strtopd.c
+	gdtoa/src/strtopdd.c
+	gdtoa/src/strtopf.c
+	gdtoa/src/strtopQ.c
+	gdtoa/src/strtopx.c
+	gdtoa/src/strtopxL.c
+	gdtoa/src/strtord.c
+	gdtoa/src/strtordd.c
+	gdtoa/src/strtorf.c
+	gdtoa/src/strtorQ.c
+	gdtoa/src/strtorx.c
+	gdtoa/src/strtorxL.c
+	gdtoa/src/sum.c
+	gdtoa/src/ulp.c
+)
+
+target_include_directories(gdtoa INTERFACE gdtoa/include)
+target_compile_definitions(gdtoa INTERFACE
+                           NO_ERRNO
+                           IFNAN_CHECK
+                           GDTOA_NO_ASSERT
+                           NO_FENV_H)
+
+#Libc
+
+#libc_core contains shared files and definitions that are used by libc and libc_hosted
+add_library(c_core INTERFACE)
+target_link_libraries(c_core INTERFACE printf openlibm gdtoa architecture_specific)
+target_include_directories(c_core  
+   INTERFACE 
+       ${PROJECT_SOURCE_DIR}/include
+)
+
+#libc is a standalone version of the library
+add_library(c)
+target_link_libraries(c PRIVATE c_core)
+
+#libc_hosted is designed to be used with an operating system that provides a full implementation
+#which can do the heavy lifting for missing pieces
+add_library(c_hosted)
+target_link_libraries(c_hosted PRIVATE c_core)
+
+# Apply unconditional private flags here
+list(APPEND libc_private_compile_flags
+	"-Wno-nonnull-compare"
+     "-Wno-unknown-pragmas"
+)
+
+list(APPEND libc_public_flags
+     "")
+
+if (DISABLE_BUILTINS)
+	list(APPEND libc_private_flags -fno-builtin)
+endif()
+
+if(DISABLE_STACK_PROTECTION)
+	list(APPEND libc_public_flags -fno-stack-protector)
+endif()
+
+if(NOSTDINC_FOR_DEPENDENTS)
+	list(APPEND libc_public_flags -nostdinc)
+else()
+	list(APPEND libc_private_flags -nostdinc)
+endif()
+
+
+# Apply common settings to C and C_hosted targets
+foreach(target c c_hosted)
+	target_include_directories(${target} 
+		INTERFACE SYSTEM
+			${PROJECT_SOURCE_DIR}/include
+			$<TARGET_PROPERTY:openlibm,INTERFACE_INCLUDE_DIRECTORIES>
+			$<TARGET_PROPERTY:architecture_specific,INTERFACE_INCLUDE_DIRECTORIES>
+			
+	)
+
+	target_compile_definitions(${target}
+		INTERFACE
+			$<$<BOOL:${HIDE_UNIMPLEMENTED_C_APIS}>:DISABLE_UNIMPLEMENTED_LIBC_APIS>
+		PUBLIC
+			$<$<BOOL:${ENABLE_GNU_EXTENSIONS}>:_GNU_SOURCE>
+		PRIVATE
+			# Define a DEBUG symbol if we're using a Debug or Relase with Debug Info buildtype
+			$<$<OR:$<STREQUAL:${CMAKE_BUILD_TYPE},Debug>,$<STREQUAL:${CMAKE_BUILD_TYPE},RelWithDebInfo>>:DEBUG>
+		)
+
+
+
+	apply_supported_compiler_flags(C ${target} PRIVATE libc_private_flags)
+	apply_supported_compiler_flags(C ${target} PUBLIC libc_public_flags)
+endforeach()	
+
+if(NOT ((${CMAKE_C_COMPILER_ID} STREQUAL "Clang") OR (${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")))
+	check_c_compiler_flag("-nolibc" _nolibc)
+	#Clang doesn't handle -nolibc, so we need to upgrade to `-nostdlib`
+endif()
+
+if("${_nolibc}")
+	target_link_options(c INTERFACE "-nolibc")
+else()	
+	check_c_compiler_flag("-nostdlib" _nostdlib)
+	if("${_nostdlib}")
+		target_link_options(c INTERFACE "-nostdlib")	
+	endif()
+endif()
+
+check_c_compiler_flag("-nostartfiles" _nostartfiles)
+if("${_nostartfiles}")
+	target_link_options(c INTERFACE "-nostartfiles")
+endif()
+
+# Assert Module
+target_sources(c_core INTERFACE
+               assert/assert.c)
+
+target_sources(c PRIVATE
+	crt/_Exit.c
+	crt/abort.c
+	crt/at_exit.c
+	crt/at_quick_exit.c
+	crt/crt.c
+	crt/cxa_atexit.c
+	crt/exit.c
+	crt/quick_exit.c
+)
+
+# CType Module                         
+target_sources(c_core INTERFACE
+	ctype/isalnum.c
+	ctype/isalpha.c
+	ctype/isascii.c
+	ctype/isblank.c
+	ctype/iscntrl.c
+	ctype/isdigit.c
+	ctype/isgraph.c
+	ctype/islower.c
+	ctype/isprint.c
+	ctype/ispunct.c
+	ctype/isspace.c
+	ctype/isupper.c
+	ctype/isxdigit.c
+	ctype/toascii.c
+	ctype/tolower.c
+	ctype/toupper.c
+)
+
+# locale Module
+target_sources(c_core INTERFACE
+	locale/langinfo.c
+)
+
+# math Module
+target_sources(c_core INTERFACE
+	math/fabs.c
+	math/fabsf.c
+)
+
+# stdio Module
+target_sources(c_core INTERFACE
+	stdio/asprintf.c
+	stdio/putchar.c
+	stdio/puts.c
+	stdio/vasprintf.c
+)
+
+# stdio Hosted Module
+target_sources(c_hosted PRIVATE
+	stdio/putchar_native.c
+)
+
+# stdlib Module
+target_sources(c_core INTERFACE
+	stdlib/abs.c
+	stdlib/atof.c
+	stdlib/atoi.c
+	stdlib/atol.c
+	stdlib/atoll.c
+	stdlib/bsearch.c
+	stdlib/calloc.c
+	stdlib/div.c
+	stdlib/heapsort_r.c
+	stdlib/heapsort.c
+	stdlib/imaxabs.c
+	stdlib/imaxdiv.c
+	stdlib/labs.c
+	stdlib/ldiv.c
+	stdlib/llabs.c
+	stdlib/lldiv.c
+	stdlib/qsort_r.c
+	stdlib/qsort.c
+	stdlib/rand.c
+	stdlib/realloc.c
+	stdlib/strtol.c
+	stdlib/strtold.c
+	stdlib/strtoul.c
+	stdlib/strtoll.c
+	stdlib/strtoull.c
+)
+
+# string Module
+target_sources(c_core INTERFACE
+               string/memcmp.c
+               string/memcpy.c
+               string/memmem.c
+               string/memmove.c
+               string/memchr.c
+               string/memrchr.c
+               string/memset.c
+               string/strcat.c
+               string/strchr.c
+               string/strchrnul.c
+               string/strcmp.c
+               string/strcoll.c
+               string/strcpy.c
+               string/strcspn.c
+               string/strdup.c
+               string/strerror.c
+               string/strerror_r.c
+               string/strlen.c
+               string/strncat.c
+               string/strncmp.c
+               string/strncpy.c
+               string/strndup.c
+               string/strnlen.c
+               string/strnstr.c
+               string/strpbrk.c
+               string/strrchr.c
+               string/strspn.c
+               string/strstr.c
+               string/strtok.c
+	string/strxfrm.c
+)
+
+# support Module
+target_sources(c_core INTERFACE
+	support/fls.c
+	support/flsl.c
+	support/flsll.c
+)
+
+# time Module
+target_sources(c_core INTERFACE
+	time/asctime.c
+	time/asctime_r.c
+)
+
+# wchar Module
+target_sources(c_core INTERFACE
+	wchar/iswalnum.c
+	wchar/iswalpha.c
+	wchar/iswblank.c
+	wchar/iswcntrl.c
+	wchar/iswalnum.c
+	wchar/iswalpha.c
+	wchar/iswblank.c
+	wchar/iswcntrl.c
+	wchar/iswctype.c
+	wchar/iswdigit.c
+	wchar/iswgraph.c
+	wchar/iswlower.c
+	wchar/iswprint.c
+	wchar/iswpunct.c
+	wchar/iswspace.c
+	wchar/iswupper.c
+	wchar/iswxdigit.c
+	wchar/towccase.c
+	wchar/towctrans.c
+	wchar/towlower.c
+	wchar/towupper.c
+	wchar/wcswidth.c
+	wchar/wctrans.c
+	wchar/wctype.c
+	wchar/wcwidth.c
+)
+
+
diff --git a/Cmake/libc-skeleton/src/ctype/isalnum.c b/Cmake/libc-skeleton/src/ctype/isalnum.c
index 5f1d5c7..700f08b 100644
--- a/Cmake/libc-skeleton/src/ctype/isalnum.c
+++ b/Cmake/libc-skeleton/src/ctype/isalnum.c
@@ -4,5 +4,5 @@
 
 int isalnum(int c)
 {
-	return isalpha(c) || isdigit(c);
+	return isalpha( c ) || isdigit(c);
 }
diff --git a/Cmake/libc-skeleton/src/gdtoa/include/arith.h b/Cmake/libc-skeleton/src/gdtoa/include/arith.h
index 1517771..5a96147 100644
--- a/Cmake/libc-skeleton/src/gdtoa/include/arith.h
+++ b/Cmake/libc-skeleton/src/gdtoa/include/arith.h
@@ -26,19 +26,19 @@
  */
 
 #if defined(__i386__)
-#define IEEE_8087
-#define Arith_Kind_ASL 1
+	#define IEEE_8087
+	#define Arith_Kind_ASL 1
 #elif defined(__x86_64__)
-#define IEEE_8087
-#define Arith_Kind_ASL 1
-#define Intcast (int)(long)
-#define Double_Align
-#define X64_bit_pointers
+	#define IEEE_8087
+	#define Arith_Kind_ASL 1
+	#define Intcast (int)(long)
+	#define Double_Align
+	#define X64_bit_pointers
 #elif defined(__arm__) || defined(__aarch64__)
-#define IEEE_8087
-#define Arith_Kind_ASL 1
+	#define IEEE_8087
+	#define Arith_Kind_ASL 1
 #else
-#error Unsupported architecture
+	#error Unsupported architecture
 #endif
 
 #define Honor_FLT_ROUNDS
diff --git a/Cmake/libc-skeleton/src/gdtoa/include/gd_qnan.h b/Cmake/libc-skeleton/src/gdtoa/include/gd_qnan.h
index 44a594f..54914b5 100644
--- a/Cmake/libc-skeleton/src/gdtoa/include/gd_qnan.h
+++ b/Cmake/libc-skeleton/src/gdtoa/include/gd_qnan.h
@@ -1,33 +1,33 @@
 #if defined(__ppc__) || defined(__ppc64__)
 
-#define f_QNAN 0x7fc00000
-#define d_QNAN0 0x7ff80000
-#define d_QNAN1 0x0
-#define ld_QNAN0 0x7ff80000
-#define ld_QNAN1 0x0
-#define ld_QNAN2 0x0
-#define ld_QNAN3 0x0
-#define ldus_QNAN0 0x7ff8
-#define ldus_QNAN1 0x0
-#define ldus_QNAN2 0x0
-#define ldus_QNAN3 0x0
-#define ldus_QNAN4 0x0
+	#define f_QNAN 0x7fc00000
+	#define d_QNAN0 0x7ff80000
+	#define d_QNAN1 0x0
+	#define ld_QNAN0 0x7ff80000
+	#define ld_QNAN1 0x0
+	#define ld_QNAN2 0x0
+	#define ld_QNAN3 0x0
+	#define ldus_QNAN0 0x7ff8
+	#define ldus_QNAN1 0x0
+	#define ldus_QNAN2 0x0
+	#define ldus_QNAN3 0x0
+	#define ldus_QNAN4 0x0
 
 #elif defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
 
-#define f_QNAN 0x7fc00000
-#define d_QNAN0 0x0
-#define d_QNAN1 0x7ff80000
-#define ld_QNAN0 0x0
-#define ld_QNAN1 0xc0000000
-#define ld_QNAN2 0x7fff
-#define ld_QNAN3 0x0
-#define ldus_QNAN0 0x0
-#define ldus_QNAN1 0x0
-#define ldus_QNAN2 0x0
-#define ldus_QNAN3 0xc000
-#define ldus_QNAN4 0x7fff
+	#define f_QNAN 0x7fc00000
+	#define d_QNAN0 0x0
+	#define d_QNAN1 0x7ff80000
+	#define ld_QNAN0 0x0
+	#define ld_QNAN1 0xc0000000
+	#define ld_QNAN2 0x7fff
+	#define ld_QNAN3 0x0
+	#define ldus_QNAN0 0x0
+	#define ldus_QNAN1 0x0
+	#define ldus_QNAN2 0x0
+	#define ldus_QNAN3 0xc000
+	#define ldus_QNAN4 0x7fff
 
 #else
-#error unknown architecture
+	#error unknown architecture
 #endif
diff --git a/Cmake/libc-skeleton/src/gdtoa/include/gdtoa.h b/Cmake/libc-skeleton/src/gdtoa/include/gdtoa.h
index 522c41e..4e51c27 100644
--- a/Cmake/libc-skeleton/src/gdtoa/include/gdtoa.h
+++ b/Cmake/libc-skeleton/src/gdtoa/include/gdtoa.h
@@ -37,23 +37,23 @@ THIS SOFTWARE.
 
 enum
 { /* return values from strtodg */
-  STRTOG_Zero = 0,
-  STRTOG_Normal = 1,
-  STRTOG_Denormal = 2,
-  STRTOG_Infinite = 3,
-  STRTOG_NaN = 4,
-  STRTOG_NaNbits = 5,
-  STRTOG_NoNumber = 6,
-  STRTOG_Retmask = 7,
-
-  /* The following may be or-ed into one of the above values. */
-
-  STRTOG_Neg = 0x08,
-  STRTOG_Inexlo = 0x10,
-  STRTOG_Inexhi = 0x20,
-  STRTOG_Inexact = 0x30,
-  STRTOG_Underflow = 0x40,
-  STRTOG_Overflow = 0x80
+	STRTOG_Zero = 0,
+	STRTOG_Normal = 1,
+	STRTOG_Denormal = 2,
+	STRTOG_Infinite = 3,
+	STRTOG_NaN = 4,
+	STRTOG_NaNbits = 5,
+	STRTOG_NoNumber = 6,
+	STRTOG_Retmask = 7,
+
+	/* The following may be or-ed into one of the above values. */
+
+	STRTOG_Neg = 0x08,
+	STRTOG_Inexlo = 0x10,
+	STRTOG_Inexhi = 0x20,
+	STRTOG_Inexact = 0x30,
+	STRTOG_Underflow = 0x40,
+	STRTOG_Overflow = 0x80
 };
 
 typedef struct FPI
@@ -67,56 +67,57 @@ typedef struct FPI
 
 enum
 { /* FPI.rounding values: same as FLT_ROUNDS */
-  FPI_Round_zero = 0,
-  FPI_Round_near = 1,
-  FPI_Round_up = 2,
-  FPI_Round_down = 3
+	FPI_Round_zero = 0,
+	FPI_Round_near = 1,
+	FPI_Round_up = 2,
+	FPI_Round_down = 3
 };
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-extern char* dtoa(double d, int mode, int ndigits, int* decpt, int* sign, char** rve);
-extern char* gdtoa(FPI * fpi, int be, uint32_t* bits, int* kindp, int mode, int ndigits,
-						 int* decpt, char** rve);
-extern void freedtoa(char*);
-extern int strtodg(const char*, char**, FPI*, int32_t*, uint32_t*);
-
-extern char* g_ddfmt(char*, double*, int, unsigned);
-extern char* g_dfmt(char*, double*, int, unsigned);
-extern char* g_ffmt(char*, float*, int, unsigned);
-extern char* g_Qfmt(char*, void*, int, unsigned);
-extern char* g_xfmt(char*, void*, int, unsigned);
-extern char* g_xLfmt(char*, void*, int, unsigned);
-
-extern int strtoId(const char*, char**, double*, double*);
-extern int strtoIdd(const char*, char**, double*, double*);
-extern int strtoIf(const char*, char**, float*, float*);
-extern int strtoIQ(const char*, char**, void*, void*);
-extern int strtoIx(const char*, char**, void*, void*);
-extern int strtoIxL(const char*, char**, void*, void*);
-extern int strtord(const char*, char**, int, double*);
-extern int strtordd(const char*, char**, int, double*);
-extern int strtorf(const char*, char**, int, float*);
-extern int strtorQ(const char*, char**, int, void*);
-extern int strtorx(const char*, char**, int, void*);
-extern int strtorxL(const char*, char**, int, void*);
+	extern char* dtoa(double d, int mode, int ndigits, int* decpt, int* sign, char** rve);
+	extern char* gdtoa(FPI* fpi, int be, uint32_t* bits, int* kindp, int mode, int ndigits,
+					   int* decpt, char** rve);
+	extern void freedtoa(char*);
+	extern int strtodg(const char*, char**, FPI*, int32_t*, uint32_t*);
+
+	extern char* g_ddfmt(char*, double*, int, unsigned);
+	extern char* g_dfmt(char*, double*, int, unsigned);
+	extern char* g_ffmt(char*, float*, int, unsigned);
+	extern char* g_Qfmt(char*, void*, int, unsigned);
+	extern char* g_xfmt(char*, void*, int, unsigned);
+	extern char* g_xLfmt(char*, void*, int, unsigned);
+
+	extern int strtoId(const char*, char**, double*, double*);
+	extern int strtoIdd(const char*, char**, double*, double*);
+	extern int strtoIf(const char*, char**, float*, float*);
+	extern int strtoIQ(const char*, char**, void*, void*);
+	extern int strtoIx(const char*, char**, void*, void*);
+	extern int strtoIxL(const char*, char**, void*, void*);
+	extern int strtord(const char*, char**, int, double*);
+	extern int strtordd(const char*, char**, int, double*);
+	extern int strtorf(const char*, char**, int, float*);
+	extern int strtorQ(const char*, char**, int, void*);
+	extern int strtorx(const char*, char**, int, void*);
+	extern int strtorxL(const char*, char**, int, void*);
 #if 1
-extern int strtodI(const char*, char**, double*);
-extern int strtopd(const char*, char**, double*);
-extern int strtopdd(const char*, char**, double*);
-extern int strtopf(const char*, char**, float*);
-extern int strtopQ(const char*, char**, void*);
-extern int strtopx(const char*, char**, void*);
-extern int strtopxL(const char*, char**, void*);
+	extern int strtodI(const char*, char**, double*);
+	extern int strtopd(const char*, char**, double*);
+	extern int strtopdd(const char*, char**, double*);
+	extern int strtopf(const char*, char**, float*);
+	extern int strtopQ(const char*, char**, void*);
+	extern int strtopx(const char*, char**, void*);
+	extern int strtopxL(const char*, char**, void*);
 #else
-#define strtopd(s, se, x) strtord(s, se, 1, x)
-#define strtopdd(s, se, x) strtordd(s, se, 1, x)
-#define strtopf(s, se, x) strtorf(s, se, 1, x)
-#define strtopQ(s, se, x) strtorQ(s, se, 1, x)
-#define strtopx(s, se, x) strtorx(s, se, 1, x)
-#define strtopxL(s, se, x) strtorxL(s, se, 1, x)
+	#define strtopd(s, se, x) strtord(s, se, 1, x)
+	#define strtopdd(s, se, x) strtordd(s, se, 1, x)
+	#define strtopf(s, se, x) strtorf(s, se, 1, x)
+	#define strtopQ(s, se, x) strtorQ(s, se, 1, x)
+	#define strtopx(s, se, x) strtorx(s, se, 1, x)
+	#define strtopxL(s, se, x) strtorxL(s, se, 1, x)
 #endif
 
 #ifdef __cplusplus
diff --git a/Cmake/libc-skeleton/src/gdtoa/include/gdtoaimp.h b/Cmake/libc-skeleton/src/gdtoa/include/gdtoaimp.h
index 525e956..c9f8bbb 100644
--- a/Cmake/libc-skeleton/src/gdtoa/include/gdtoaimp.h
+++ b/Cmake/libc-skeleton/src/gdtoa/include/gdtoaimp.h
@@ -173,22 +173,22 @@ THIS SOFTWARE.
 #include "gdtoa.h"
 
 #ifdef DEBUG
-#ifdef GDTOA_HOST_DEBUG
-#include <stdio.h>
-#define Bug(x)                      \
-	{                               \
-		fprintf(stderr, "%s\n", x); \
-		exit(1);                    \
-	}
-#else
-#ifdef GDTOA_NO_ASSERT
-#define Bug(...)
-#else
-#include <assert.h>
-#include <stdbool.h>
-#define Bug(x) assert(!(bool)(x))
-#endif // GDTOA_NO_ASSET
-#endif // GDTOA_HOST_DEBUG
+	#ifdef GDTOA_HOST_DEBUG
+		#include <stdio.h>
+		#define Bug(x)                      \
+			{                               \
+				fprintf(stderr, "%s\n", x); \
+				exit(1);                    \
+			}
+	#else
+		#ifdef GDTOA_NO_ASSERT
+			#define Bug(...)
+		#else
+			#include <assert.h>
+			#include <stdbool.h>
+			#define Bug(x) assert(!(bool)(x))
+		#endif // GDTOA_NO_ASSET
+	#endif // GDTOA_HOST_DEBUG
 #endif // DEBUG
 
 #include "stdlib.h"
@@ -197,107 +197,108 @@ THIS SOFTWARE.
 #ifdef MALLOC
 extern void* MALLOC(size_t);
 #else
-#define MALLOC malloc
+	#define MALLOC malloc
 #endif
 
 #undef IEEE_Arith
 #undef Avoid_Underflow
 #ifdef IEEE_8087
-#define IEEE_Arith
+	#define IEEE_Arith
 #else
-#error Something went wrong, IEEE8087 is not defined
+	#error Something went wrong, IEEE8087 is not defined
 #endif
 
 #ifndef NO_ERRNO
-#include "errno.h"
+	#include "errno.h"
 #endif
 
 #ifdef Bad_float_h
 
-#ifdef IEEE_Arith
-#define DBL_DIG 15
-#define DBL_MAX_10_EXP 308
-#define DBL_MAX_EXP 1024
-#define FLT_RADIX 2
-#define DBL_MAX 1.7976931348623157e+308
-#endif
-
-#ifdef IBM
-#define DBL_DIG 16
-#define DBL_MAX_10_EXP 75
-#define DBL_MAX_EXP 63
-#define FLT_RADIX 16
-#define DBL_MAX 7.2370055773322621e+75
-#endif
-
-#ifdef VAX
-#define DBL_DIG 16
-#define DBL_MAX_10_EXP 38
-#define DBL_MAX_EXP 127
-#define FLT_RADIX 2
-#define DBL_MAX 1.7014118346046923e+38
-#define n_bigtens 2
-#endif
-
-#ifndef LONG_MAX
-#define LONG_MAX 2147483647
-#endif
+	#ifdef IEEE_Arith
+		#define DBL_DIG 15
+		#define DBL_MAX_10_EXP 308
+		#define DBL_MAX_EXP 1024
+		#define FLT_RADIX 2
+		#define DBL_MAX 1.7976931348623157e+308
+	#endif
+
+	#ifdef IBM
+		#define DBL_DIG 16
+		#define DBL_MAX_10_EXP 75
+		#define DBL_MAX_EXP 63
+		#define FLT_RADIX 16
+		#define DBL_MAX 7.2370055773322621e+75
+	#endif
+
+	#ifdef VAX
+		#define DBL_DIG 16
+		#define DBL_MAX_10_EXP 38
+		#define DBL_MAX_EXP 127
+		#define FLT_RADIX 2
+		#define DBL_MAX 1.7014118346046923e+38
+		#define n_bigtens 2
+	#endif
+
+	#ifndef LONG_MAX
+		#define LONG_MAX 2147483647
+	#endif
 
 #else /* ifndef Bad_float_h */
-#include "float.h"
+	#include "float.h"
 #endif /* Bad_float_h */
 
 #ifdef IEEE_Arith
-#define Scale_Bit 0x10
-#define n_bigtens 5
+	#define Scale_Bit 0x10
+	#define n_bigtens 5
 #endif
 
 #ifdef IBM
-#define n_bigtens 3
+	#define n_bigtens 3
 #endif
 
 #ifdef VAX
-#define n_bigtens 2
+	#define n_bigtens 2
 #endif
 
 #ifndef GDTOA_NO_MATH_H
-#ifndef __MATH_H__
-#include "math.h"
-#endif
+	#ifndef __MATH_H__
+		#include "math.h"
+	#endif
 #endif
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
 #if defined(IEEE_8087) + defined(VAX) + defined(IBM) != 1
-Exactly one of IEEE_8087, VAX, or IBM should be defined.
+	Exactly one of IEEE_8087, VAX, or IBM should be defined.
 #endif
 
-											   typedef union
-{
-	double d;
-	uint32_t L[2];
-} U;
+									   typedef union
+	{
+		double d;
+		uint32_t L[2];
+	} U;
 
 #ifdef YES_ALIAS
-#define dval(x) x
-#ifdef IEEE_8087
-#define word0(x) ((uint32_t*)&x)[1]
-#define word1(x) ((uint32_t*)&x)[0]
-#else
-#define word0(x) ((uint32_t*)&x)[0]
-#define word1(x) ((uint32_t*)&x)[1]
-#endif
+	#define dval(x) x
+	#ifdef IEEE_8087
+		#define word0(x) ((uint32_t*)&x)[1]
+		#define word1(x) ((uint32_t*)&x)[0]
+	#else
+		#define word0(x) ((uint32_t*)&x)[0]
+		#define word1(x) ((uint32_t*)&x)[1]
+	#endif
 #else /* !YES_ALIAS */
-#ifdef IEEE_8087
-#define word0(x) ((U*)&x)->L[1]
-#define word1(x) ((U*)&x)->L[0]
-#else
-#define word0(x) ((U*)&x)->L[0]
-#define word1(x) ((U*)&x)->L[1]
-#endif
-#define dval(x) ((U*)&x)->d
+	#ifdef IEEE_8087
+		#define word0(x) ((U*)&x)->L[1]
+		#define word1(x) ((U*)&x)->L[0]
+	#else
+		#define word0(x) ((U*)&x)->L[0]
+		#define word1(x) ((U*)&x)->L[1]
+	#endif
+	#define dval(x) ((U*)&x)->d
 #endif /* YES_ALIAS */
 
 /* The following definition of Storeinc is appropriate for MIPS processors.
@@ -305,121 +306,124 @@ Exactly one of IEEE_8087, VAX, or IBM should be defined.
  * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)
  */
 #if defined(IEEE_8087) + defined(VAX)
-#define Storeinc(a, b, c) \
-	(((unsigned short*)a)[1] = (unsigned short)b, ((unsigned short*)a)[0] = (unsigned short)c, a++)
+	#define Storeinc(a, b, c)                                                                      \
+		(((unsigned short*)a)[1] = (unsigned short)b, ((unsigned short*)a)[0] = (unsigned short)c, \
+		 a++)
 #else
-#define Storeinc(a, b, c) \
-	(((unsigned short*)a)[0] = (unsigned short)b, ((unsigned short*)a)[1] = (unsigned short)c, a++)
+	#define Storeinc(a, b, c)                                                                      \
+		(((unsigned short*)a)[0] = (unsigned short)b, ((unsigned short*)a)[1] = (unsigned short)c, \
+		 a++)
 #endif
 
-/* #define P DBL_MANT_DIG */
-/* Ten_pmax = floor(P*log(2)/log(5)) */
-/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
-/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
-/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
+	/* #define P DBL_MANT_DIG */
+	/* Ten_pmax = floor(P*log(2)/log(5)) */
+	/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
+	/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
+	/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
 
 #ifdef IEEE_Arith
-#define Exp_shift 20
-#define Exp_shift1 20
-#define Exp_msk1 0x100000
-#define Exp_msk11 0x100000
-#define Exp_mask 0x7ff00000
-#define P 53
-#define Bias 1023
-#define Emin (-1022)
-#define Exp_1 0x3ff00000
-#define Exp_11 0x3ff00000
-#define Ebits 11
-#define Frac_mask 0xfffff
-#define Frac_mask1 0xfffff
-#define Ten_pmax 22
-#define Bletch 0x10
-#define Bndry_mask 0xfffff
-#define Bndry_mask1 0xfffff
-#define LSB 1
-#define Sign_bit 0x80000000
-#define Log2P 1
-#define Tiny0 0
-#define Tiny1 1
-#define Quick_max 14
-#define Int_max 14
-
-#ifndef Flt_Rounds
-#ifdef FLT_ROUNDS
-#define Flt_Rounds FLT_ROUNDS
-#else
-#define Flt_Rounds 1
-#endif
-#endif /*Flt_Rounds*/
+	#define Exp_shift 20
+	#define Exp_shift1 20
+	#define Exp_msk1 0x100000
+	#define Exp_msk11 0x100000
+	#define Exp_mask 0x7ff00000
+	#define P 53
+	#define Bias 1023
+	#define Emin (-1022)
+	#define Exp_1 0x3ff00000
+	#define Exp_11 0x3ff00000
+	#define Ebits 11
+	#define Frac_mask 0xfffff
+	#define Frac_mask1 0xfffff
+	#define Ten_pmax 22
+	#define Bletch 0x10
+	#define Bndry_mask 0xfffff
+	#define Bndry_mask1 0xfffff
+	#define LSB 1
+	#define Sign_bit 0x80000000
+	#define Log2P 1
+	#define Tiny0 0
+	#define Tiny1 1
+	#define Quick_max 14
+	#define Int_max 14
+
+	#ifndef Flt_Rounds
+		#ifdef FLT_ROUNDS
+			#define Flt_Rounds FLT_ROUNDS
+		#else
+			#define Flt_Rounds 1
+		#endif
+	#endif /*Flt_Rounds*/
 
 #else /* ifndef IEEE_Arith */
-#undef Sudden_Underflow
-#define Sudden_Underflow
-#ifdef IBM
-#undef Flt_Rounds
-#define Flt_Rounds 0
-#define Exp_shift 24
-#define Exp_shift1 24
-#define Exp_msk1 0x1000000
-#define Exp_msk11 0x1000000
-#define Exp_mask 0x7f000000
-#define P 14
-#define Bias 65
-#define Exp_1 0x41000000
-#define Exp_11 0x41000000
-#define Ebits 8 /* exponent has 7 bits, but 8 is the right value in b2d */
-#define Frac_mask 0xffffff
-#define Frac_mask1 0xffffff
-#define Bletch 4
-#define Ten_pmax 22
-#define Bndry_mask 0xefffff
-#define Bndry_mask1 0xffffff
-#define LSB 1
-#define Sign_bit 0x80000000
-#define Log2P 4
-#define Tiny0 0x100000
-#define Tiny1 0
-#define Quick_max 14
-#define Int_max 15
-#else /* VAX */
-#undef Flt_Rounds
-#define Flt_Rounds 1
-#define Exp_shift 23
-#define Exp_shift1 7
-#define Exp_msk1 0x80
-#define Exp_msk11 0x800000
-#define Exp_mask 0x7f80
-#define P 56
-#define Bias 129
-#define Exp_1 0x40800000
-#define Exp_11 0x4080
-#define Ebits 8
-#define Frac_mask 0x7fffff
-#define Frac_mask1 0xffff007f
-#define Ten_pmax 24
-#define Bletch 2
-#define Bndry_mask 0xffff007f
-#define Bndry_mask1 0xffff007f
-#define LSB 0x10000
-#define Sign_bit 0x8000
-#define Log2P 1
-#define Tiny0 0x80
-#define Tiny1 0
-#define Quick_max 15
-#define Int_max 15
-#endif /* IBM, VAX */
+	#undef Sudden_Underflow
+	#define Sudden_Underflow
+	#ifdef IBM
+		#undef Flt_Rounds
+		#define Flt_Rounds 0
+		#define Exp_shift 24
+		#define Exp_shift1 24
+		#define Exp_msk1 0x1000000
+		#define Exp_msk11 0x1000000
+		#define Exp_mask 0x7f000000
+		#define P 14
+		#define Bias 65
+		#define Exp_1 0x41000000
+		#define Exp_11 0x41000000
+		#define Ebits 8 /* exponent has 7 bits, but 8 is the right value in b2d */
+		#define Frac_mask 0xffffff
+		#define Frac_mask1 0xffffff
+		#define Bletch 4
+		#define Ten_pmax 22
+		#define Bndry_mask 0xefffff
+		#define Bndry_mask1 0xffffff
+		#define LSB 1
+		#define Sign_bit 0x80000000
+		#define Log2P 4
+		#define Tiny0 0x100000
+		#define Tiny1 0
+		#define Quick_max 14
+		#define Int_max 15
+	#else /* VAX */
+		#undef Flt_Rounds
+		#define Flt_Rounds 1
+		#define Exp_shift 23
+		#define Exp_shift1 7
+		#define Exp_msk1 0x80
+		#define Exp_msk11 0x800000
+		#define Exp_mask 0x7f80
+		#define P 56
+		#define Bias 129
+		#define Exp_1 0x40800000
+		#define Exp_11 0x4080
+		#define Ebits 8
+		#define Frac_mask 0x7fffff
+		#define Frac_mask1 0xffff007f
+		#define Ten_pmax 24
+		#define Bletch 2
+		#define Bndry_mask 0xffff007f
+		#define Bndry_mask1 0xffff007f
+		#define LSB 0x10000
+		#define Sign_bit 0x8000
+		#define Log2P 1
+		#define Tiny0 0x80
+		#define Tiny1 0
+		#define Quick_max 15
+		#define Int_max 15
+	#endif /* IBM, VAX */
 #endif /* IEEE_Arith */
 
 #ifndef IEEE_Arith
-#define ROUND_BIASED
+	#define ROUND_BIASED
 #endif
 
 #ifdef RND_PRODQUOT
-#define rounded_product(a, b) a = rnd_prod(a, b)
-#define rounded_quotient(a, b) a = rnd_quot(a, b) extern double rnd_prod(double, double), rnd_quot(double, double);
+	#define rounded_product(a, b) a = rnd_prod(a, b)
+	#define rounded_quotient(a, b) \
+		a = rnd_quot(a, b) extern double rnd_prod(double, double), rnd_quot(double, double);
 #else
-#define rounded_product(a, b) a *= b
-#define rounded_quotient(a, b) a /= b
+	#define rounded_product(a, b) a *= b
+	#define rounded_quotient(a, b) a /= b
 #endif
 
 #define Big0 (Frac_mask1 | Exp_msk1 * (DBL_MAX_EXP + Bias - 1))
@@ -427,108 +431,109 @@ Exactly one of IEEE_8087, VAX, or IBM should be defined.
 
 #undef Pack_16
 #ifndef Pack_32
-#define Pack_32
+	#define Pack_32
 #endif
 
 #ifdef NO_LONG_LONG
-#ifdef Just_16
-#undef Pack_32
-#define Pack_16
-/* When Pack_32 is not defined, we store 16 bits per 32-bit int32_t.
- * This makes some inner loops simpler and sometimes saves work
- * during multiplications, but it often seems to make things slightly
- * slower.  Hence the default is now to store 32 bits per int32_t.
- */
-#endif
+	#ifdef Just_16
+		#undef Pack_32
+		#define Pack_16
+	/* When Pack_32 is not defined, we store 16 bits per 32-bit int32_t.
+	 * This makes some inner loops simpler and sometimes saves work
+	 * during multiplications, but it often seems to make things slightly
+	 * slower.  Hence the default is now to store 32 bits per int32_t.
+	 */
+	#endif
 #endif /* NO_LONG_LONG */
 
 #ifdef Pack_32
-#define ULbits 32
-#define kshift 5
-#define kmask 31
-#define ALL_ON 0xffffffff
+	#define ULbits 32
+	#define kshift 5
+	#define kmask 31
+	#define ALL_ON 0xffffffff
 #else
-#define ULbits 16
-#define kshift 4
-#define kmask 15
-#define ALL_ON 0xffff
+	#define ULbits 16
+	#define kshift 4
+	#define kmask 15
+	#define ALL_ON 0xffff
 #endif
 
 #ifndef MULTIPLE_THREADS
-#define ACQUIRE_DTOA_LOCK(n) /*nothing*/
-#define FREE_DTOA_LOCK(n) /*nothing*/
+	#define ACQUIRE_DTOA_LOCK(n) /*nothing*/
+	#define FREE_DTOA_LOCK(n) /*nothing*/
 #endif
 
 #define Kmax 15
 
-struct Bigint
-{
-	struct Bigint* next;
-	int k, maxwds, sign, wds;
-	uint32_t x[1];
-};
+	struct Bigint
+	{
+		struct Bigint* next;
+		int k, maxwds, sign, wds;
+		uint32_t x[1];
+	};
 
-typedef struct Bigint Bigint;
+	typedef struct Bigint Bigint;
 
 #ifdef NO_STRING_H
-#ifdef DECLARE_SIZE_T
-typedef unsigned int size_t;
-#endif
-extern void memcpy(void*, const void*, size_t);
-#define Bcopy(x, y) \
-	memcpy(&x->sign, &y->sign, (size_t)(y->wds) * sizeof(uint32_t) + 2 * sizeof(int))
+	#ifdef DECLARE_SIZE_T
+	typedef unsigned int size_t;
+	#endif
+	extern void memcpy(void*, const void*, size_t);
+	#define Bcopy(x, y) \
+		memcpy(&x->sign, &y->sign, (size_t)(y->wds) * sizeof(uint32_t) + 2 * sizeof(int))
 #else /* !NO_STRING_H */
-#define Bcopy(x, y) memcpy(&x->sign, &y->sign, (size_t)(y->wds) * sizeof(uint32_t) + 2 * sizeof(int))
+	#define Bcopy(x, y) \
+		memcpy(&x->sign, &y->sign, (size_t)(y->wds) * sizeof(uint32_t) + 2 * sizeof(int))
 #endif /* NO_STRING_H */
 
 // This is still required at the moment because strtod switches out tinytens
 // for its own copy.
 #define tinytens tinytens_D2A
 
-extern char* dtoa_result;
-extern const double bigtens[], tens[], tinytens[];
-extern unsigned char hexdig[];
-
-extern Bigint* Balloc(int);
-extern void Bfree(Bigint*);
-extern void ULtof(uint32_t*, const uint32_t*, int32_t, int);
-extern void ULtod(uint32_t*, const uint32_t*, int32_t, int);
-extern void ULtodd(uint32_t*, uint32_t*, int32_t, int);
-extern void ULtoQ(uint32_t*, const uint32_t*, int32_t, int);
-extern void ULtox(uint16_t*, const uint32_t*, int32_t, int);
-extern void ULtoxL(uint32_t*, const uint32_t*, int32_t, int);
-extern uint32_t any_on(Bigint*, int);
-extern double b2d(Bigint*, int*);
-extern int cmp(Bigint*, Bigint*);
-extern void copybits(uint32_t*, int, Bigint*);
-extern Bigint* d2b(double, int*, int*);
-extern int decrement(Bigint*);
-extern Bigint* diff(Bigint*, Bigint*);
-extern char* g__fmt(char*, char*, const char*, int, uint32_t);
-extern int gethex(const char**, FPI*, int32_t*, Bigint**, int);
-extern void hexdig_init(void);
-extern int hexnan(const char**, FPI*, uint32_t*);
-extern int hi0bits(uint32_t);
-extern Bigint* i2b(int);
-extern Bigint* increment(Bigint*);
-extern int lo0bits(uint32_t*);
-extern Bigint* lshift(Bigint*, int);
-extern int match(const char**, char*);
-extern Bigint* mult(Bigint*, Bigint*);
-extern Bigint* multadd(Bigint*, int, int);
-extern char* nrv_alloc(const char*, char**, int);
-extern Bigint* pow5mult(Bigint*, int);
-extern int quorem(Bigint*, Bigint*);
-extern double ratio(Bigint*, Bigint*);
-extern void rshift(Bigint*, int);
-extern char* rv_alloc(int);
-extern Bigint* s2b(const char*, int, int, uint32_t);
-extern Bigint* set_ones(Bigint*, int);
-extern char* strcp(char*, const char*);
-extern int strtoIg(const char*, char**, FPI*, int32_t*, Bigint**, int*);
-extern Bigint* sum(Bigint*, Bigint*);
-extern int trailz(Bigint*);
-extern double ulp(double);
+	extern char* dtoa_result;
+	extern const double bigtens[], tens[], tinytens[];
+	extern unsigned char hexdig[];
+
+	extern Bigint* Balloc(int);
+	extern void Bfree(Bigint*);
+	extern void ULtof(uint32_t*, const uint32_t*, int32_t, int);
+	extern void ULtod(uint32_t*, const uint32_t*, int32_t, int);
+	extern void ULtodd(uint32_t*, uint32_t*, int32_t, int);
+	extern void ULtoQ(uint32_t*, const uint32_t*, int32_t, int);
+	extern void ULtox(uint16_t*, const uint32_t*, int32_t, int);
+	extern void ULtoxL(uint32_t*, const uint32_t*, int32_t, int);
+	extern uint32_t any_on(Bigint*, int);
+	extern double b2d(Bigint*, int*);
+	extern int cmp(Bigint*, Bigint*);
+	extern void copybits(uint32_t*, int, Bigint*);
+	extern Bigint* d2b(double, int*, int*);
+	extern int decrement(Bigint*);
+	extern Bigint* diff(Bigint*, Bigint*);
+	extern char* g__fmt(char*, char*, const char*, int, uint32_t);
+	extern int gethex(const char**, FPI*, int32_t*, Bigint**, int);
+	extern void hexdig_init(void);
+	extern int hexnan(const char**, FPI*, uint32_t*);
+	extern int hi0bits(uint32_t);
+	extern Bigint* i2b(int);
+	extern Bigint* increment(Bigint*);
+	extern int lo0bits(uint32_t*);
+	extern Bigint* lshift(Bigint*, int);
+	extern int match(const char**, char*);
+	extern Bigint* mult(Bigint*, Bigint*);
+	extern Bigint* multadd(Bigint*, int, int);
+	extern char* nrv_alloc(const char*, char**, int);
+	extern Bigint* pow5mult(Bigint*, int);
+	extern int quorem(Bigint*, Bigint*);
+	extern double ratio(Bigint*, Bigint*);
+	extern void rshift(Bigint*, int);
+	extern char* rv_alloc(int);
+	extern Bigint* s2b(const char*, int, int, uint32_t);
+	extern Bigint* set_ones(Bigint*, int);
+	extern char* strcp(char*, const char*);
+	extern int strtoIg(const char*, char**, FPI*, int32_t*, Bigint**, int*);
+	extern Bigint* sum(Bigint*, Bigint*);
+	extern int trailz(Bigint*);
+	extern double ulp(double);
 
 #ifdef __cplusplus
 }
@@ -543,34 +548,34 @@ extern double ulp(double);
  * (On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)
  */
 #ifdef IEEE_Arith
-#ifdef IEEE_MC68k
-#define _0 0
-#define _1 1
-#ifndef NAN_WORD0
-#define NAN_WORD0 d_QNAN0
-#endif
-#ifndef NAN_WORD1
-#define NAN_WORD1 d_QNAN1
-#endif
-#else
-#define _0 1
-#define _1 0
-#ifndef NAN_WORD0
-#define NAN_WORD0 d_QNAN1
-#endif
-#ifndef NAN_WORD1
-#define NAN_WORD1 d_QNAN0
-#endif
-#endif
+	#ifdef IEEE_MC68k
+		#define _0 0
+		#define _1 1
+		#ifndef NAN_WORD0
+			#define NAN_WORD0 d_QNAN0
+		#endif
+		#ifndef NAN_WORD1
+			#define NAN_WORD1 d_QNAN1
+		#endif
+	#else
+		#define _0 1
+		#define _1 0
+		#ifndef NAN_WORD0
+			#define NAN_WORD0 d_QNAN1
+		#endif
+		#ifndef NAN_WORD1
+			#define NAN_WORD1 d_QNAN0
+		#endif
+	#endif
 #else
-#undef INFNAN_CHECK
+	#undef INFNAN_CHECK
 #endif
 
 #undef SI
 #ifdef Sudden_Underflow
-#define SI 1
+	#define SI 1
 #else
-#define SI 0
+	#define SI 0
 #endif
 
 #endif /* GDTOAIMP_H_INCLUDED */
diff --git a/Cmake/libc-skeleton/src/gdtoa/src/dtoa.c b/Cmake/libc-skeleton/src/gdtoa/src/dtoa.c
index 2467f9b..58f2583 100644
--- a/Cmake/libc-skeleton/src/gdtoa/src/dtoa.c
+++ b/Cmake/libc-skeleton/src/gdtoa/src/dtoa.c
@@ -623,7 +623,7 @@ if(leftright)
 		denorm ? be + (Bias + (P - 1) - 1 + 1) :
 #endif
 #ifdef IBM
-				   1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
+				 1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
 #else
 				1 + P - bbits;
 #endif
diff --git a/Cmake/libc-skeleton/src/gdtoa/src/strtod.c b/Cmake/libc-skeleton/src/gdtoa/src/strtod.c
index fd76cc1..8e422f6 100644
--- a/Cmake/libc-skeleton/src/gdtoa/src/strtod.c
+++ b/Cmake/libc-skeleton/src/gdtoa/src/strtod.c
@@ -980,7 +980,7 @@ for(;;)
 								(scale && (y = word0(rv) & Exp_mask) <= 2 * P * Exp_msk1) ?
 									(0xffffffff & (0xffffffff << (2 * P + 1 - (y >> Exp_shift)))) :
 #endif
-									  0xffffffff))
+									0xffffffff))
 			{
 				/*boundary case -- increment exponent*/
 				word0(rv) = (word0(rv) & Exp_mask) + Exp_msk1
diff --git a/Cmake/libc-skeleton/test/CMakeLists.txt b/Cmake/libc-skeleton/test/CMakeLists.txt
index 9f185ba..04f3a2e 100644
--- a/Cmake/libc-skeleton/test/CMakeLists.txt
+++ b/Cmake/libc-skeleton/test/CMakeLists.txt
@@ -1,103 +1,117 @@
-add_executable(libc_tests)
-target_include_directories(libc_tests PRIVATE . test/)
-target_link_libraries(libc_tests PRIVATE c_hosted cmocka::cmocka)
-
-list(APPEND desired_libc_test_flags
-    "-Wno-stringop-overflow"
-    "-Wno-unused-parameter"
-    "-Wno-nonnull-compare"
-    "-Wno-nonnull"
-    "-Wno-stringop-truncation"
-    "-Wno-unknown-pragmas"
-)
-
-apply_supported_compiler_flags(C libc_tests PRIVATE desired_libc_test_flags)
-
-target_sources(libc_tests PRIVATE 
-               main.c
-               ctype/ctype_tests.c
-               ctype/isalnum.c
-               ctype/isalpha.c
-               ctype/isascii.c
-               ctype/isblank.c
-               ctype/iscntrl.c
-               ctype/isdigit.c
-               ctype/isgraph.c
-               ctype/islower.c
-               ctype/isprint.c
-               ctype/ispunct.c
-               ctype/isspace.c
-               ctype/isupper.c
-               ctype/isxdigit.c
-               ctype/toascii.c
-               ctype/tolower.c
-               ctype/toupper.c
-               stdlib/abs.c
-               stdlib/atof.c
-               stdlib/atoi.c
-               stdlib/atol.c
-               stdlib/atoll.c
-               stdlib/bsearch.c
-               stdlib/calloc.c
-               stdlib/div.c
-               stdlib/heapsort.c
-               stdlib/imaxabs.c
-               stdlib/imaxdiv.c
-               stdlib/labs.c
-               stdlib/ldiv.c
-               stdlib/llabs.c
-               stdlib/lldiv.c
-               stdlib/qsort_r.c
-               stdlib/qsort.c
-               stdlib/rand.c
-               stdlib/realloc.c
-               stdlib/stdlib_tests.c
-               stdlib/strtod.c
-               stdlib/strtof.c
-               stdlib/strtol.c
-               stdlib/strtoll.c
-               stdlib/strtoul.c
-               stdlib/strtoull.c
-               string/memcmp.c
-               string/memcpy.c
-               string/memmem.c
-               string/memmove.c
-               string/memset.c
-               string/strcat.c
-               string/strchr.c
-               string/strcmp.c
-               string/strcpy.c
-               string/strdup.c
-               string/string_tests.c
-               string/strlen.c
-               string/strncat.c
-               string/strncmp.c
-               string/strncpy.c
-               string/strndup.c
-               string/strnlen.c
-               string/strnstr.c
-               string/strrchr.c
-               string/strstr.c
-               string/strtok.c
-               test/rand.c)
-
-
-add_custom_target(test-clear-results
-    COMMAND ${CMAKE_COMMAND} -E rm -f ${CMAKE_BINARY_DIR}/test/*.xml
-    COMMENT "Removing XML files in the test/ directory")
-
-add_custom_target(test-libc
-    COMMAND export CMOCKA_MESSAGE_OUTPUT=stdout              
-    COMMAND libc_tests)
-
-add_test(NAME Libc.ClearResults
-    COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target test-clear-results)
-
-add_test(NAME Libc.Test COMMAND libc_tests)
-
-set_tests_properties(Libc.Test 
-    PROPERTIES 
-    	ENVIRONMENT CMOCKA_XML_FILE=${CMAKE_CURRENT_BINARY_DIR}/%g.xml
-    	DEPENDS Libc.ClearResults)
-
-target_linker_map(libc_tests)
+if(LIBC_TESTING_IS_ENABLED)
+    add_executable(libc_tests)
+    target_include_directories(libc_tests PRIVATE . test/)
+    target_link_libraries(libc_tests PRIVATE c_hosted cmocka::cmocka)
+
+    list(APPEND desired_libc_test_flags
+        "-Wno-stringop-overflow"
+        "-Wno-unused-parameter"
+        "-Wno-nonnull-compare"
+        "-Wno-nonnull"
+        "-Wno-stringop-truncation"
+        "-Wno-unknown-pragmas"
+    )
+
+    apply_supported_compiler_flags(C libc_tests PRIVATE desired_libc_test_flags)
+
+    target_sources(libc_tests PRIVATE 
+                   main.c
+                   ctype/ctype_tests.c
+                   ctype/isalnum.c
+                   ctype/isalpha.c
+                   ctype/isascii.c
+                   ctype/isblank.c
+                   ctype/iscntrl.c
+                   ctype/isdigit.c
+                   ctype/isgraph.c
+                   ctype/islower.c
+                   ctype/isprint.c
+                   ctype/ispunct.c
+                   ctype/isspace.c
+                   ctype/isupper.c
+                   ctype/isxdigit.c
+                   ctype/toascii.c
+                   ctype/tolower.c
+                   ctype/toupper.c
+                   stdlib/abs.c
+                   stdlib/atof.c
+                   stdlib/atoi.c
+                   stdlib/atol.c
+                   stdlib/atoll.c
+                   stdlib/bsearch.c
+                   stdlib/calloc.c
+                   stdlib/div.c
+                   stdlib/heapsort.c
+                   stdlib/imaxabs.c
+                   stdlib/imaxdiv.c
+                   stdlib/labs.c
+                   stdlib/ldiv.c
+                   stdlib/llabs.c
+                   stdlib/lldiv.c
+                   stdlib/qsort_r.c
+                   stdlib/qsort.c
+                   stdlib/rand.c
+                   stdlib/realloc.c
+                   stdlib/stdlib_tests.c
+                   stdlib/strtod.c
+                   stdlib/strtof.c
+                   stdlib/strtol.c
+                   stdlib/strtoll.c
+                   stdlib/strtoul.c
+                   stdlib/strtoull.c
+                   string/memcmp.c
+                   string/memcpy.c
+                   string/memmem.c
+                   string/memmove.c
+                   string/memset.c
+                   string/strcat.c
+                   string/strchr.c
+                   string/strcmp.c
+                   string/strcpy.c
+                   string/strdup.c
+                   string/string_tests.c
+                   string/strlen.c
+                   string/strncat.c
+                   string/strncmp.c
+                   string/strncpy.c
+                   string/strndup.c
+                   string/strnlen.c
+                   string/strnstr.c
+                   string/strrchr.c
+                   string/strstr.c
+                   string/strtok.c
+                   test/rand.c)
+
+
+    add_custom_target(test-clear-results
+        COMMAND ${CMAKE_COMMAND} -E rm -f ${CMAKE_BINARY_DIR}/test/*.xml
+        COMMENT "Removing XML files in the test/ directory")
+
+    add_custom_target(test-libc
+        COMMAND export CMOCKA_MESSAGE_OUTPUT=stdout              
+        COMMAND libc_tests)
+
+    add_test(NAME Libc.ClearResults
+        COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target test-clear-results)
+
+    add_test(NAME Libc.Test COMMAND libc_tests)
+
+    set_tests_properties(Libc.Test 
+        PROPERTIES 
+        	ENVIRONMENT CMOCKA_XML_FILE=${CMAKE_CURRENT_BINARY_DIR}/%g.xml
+        	DEPENDS Libc.ClearResults)
+
+    target_linker_map(libc_tests)
+
+
+endif(LIBC_TESTING_IS_ENABLED)
+
+# this barebones executable can be used to test linking when cross-compiling
+if(CMAKE_CROSSCOMPILING AND (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME))
+    add_executable(sample_app)
+    target_sources(sample_app PRIVATE app/main.c)
+    target_link_libraries(sample_app PRIVATE c)    
+    target_linker_map(sample_app)
+    convert_to_hex(sample_app)
+    convert_to_bin(sample_app)
+endif()
diff --git a/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.c b/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.c
index 960f4df..8dba147 100644
--- a/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.c	
+++ b/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.c	
@@ -1,11 +1,11 @@
-#include <stdio.h>
-
-int main( void )
-{
-	int x = 1;
-	int y = 2;
-	int z = x + y;
-	printf("lol get fucked robots, 1+1=%d \n", z);
-	
-	return 0;
-}
+#include <stdio.h>
+
+int main( void )
+{
+	int x = 1;
+	int y = 2;
+	int z = x + y;
+	printf("lol get fucked robots, 1+1=%d \n", z);
+	
+	return 0;
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.s b/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.s
index 06ff1a1..2c60937 100644
--- a/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.s	
+++ b/Introduction to Build Systems Using Make/Compilation/Exercises/Single Source/single_source.s	
@@ -1,37 +1,37 @@
-	.file	"single_source.c"
-	.text
-	.def	__main;	.scl	2;	.type	32;	.endef
-	.section .rdata,"dr"
-	.align 8
-.LC0:
-	.ascii "lol get fucked robots, 1+1=%d \12\0"
-	.text
-	.globl	main
-	.def	main;	.scl	2;	.type	32;	.endef
-	.seh_proc	main
-main:
-	pushq	%rbp
-	.seh_pushreg	%rbp
-	movq	%rsp, %rbp
-	.seh_setframe	%rbp, 0
-	subq	$48, %rsp
-	.seh_stackalloc	48
-	.seh_endprologue
-	call	__main
-	movl	$1, -4(%rbp)
-	movl	$2, -8(%rbp)
-	movl	-4(%rbp), %edx
-	movl	-8(%rbp), %eax
-	addl	%edx, %eax
-	movl	%eax, -12(%rbp)
-	movl	-12(%rbp), %eax
-	movl	%eax, %edx
-	leaq	.LC0(%rip), %rcx
-	call	printf
-	movl	$0, %eax
-	addq	$48, %rsp
-	popq	%rbp
-	ret
-	.seh_endproc
-	.ident	"GCC: (Rev2, Built by MSYS2 project) 9.2.0"
-	.def	printf;	.scl	2;	.type	32;	.endef
+	.file	"single_source.c"
+	.text
+	.def	__main;	.scl	2;	.type	32;	.endef
+	.section .rdata,"dr"
+	.align 8
+.LC0:
+	.ascii "lol get fucked robots, 1+1=%d \12\0"
+	.text
+	.globl	main
+	.def	main;	.scl	2;	.type	32;	.endef
+	.seh_proc	main
+main:
+	pushq	%rbp
+	.seh_pushreg	%rbp
+	movq	%rsp, %rbp
+	.seh_setframe	%rbp, 0
+	subq	$48, %rsp
+	.seh_stackalloc	48
+	.seh_endprologue
+	call	__main
+	movl	$1, -4(%rbp)
+	movl	$2, -8(%rbp)
+	movl	-4(%rbp), %edx
+	movl	-8(%rbp), %eax
+	addl	%edx, %eax
+	movl	%eax, -12(%rbp)
+	movl	-12(%rbp), %eax
+	movl	%eax, %edx
+	leaq	.LC0(%rip), %rcx
+	call	printf
+	movl	$0, %eax
+	addq	$48, %rsp
+	popq	%rbp
+	ret
+	.seh_endproc
+	.ident	"GCC: (Rev2, Built by MSYS2 project) 9.2.0"
+	.def	printf;	.scl	2;	.type	32;	.endef
diff --git a/Introduction to Build Systems Using Make/Compilation/include/multifile_func.h b/Introduction to Build Systems Using Make/Compilation/include/multifile_func.h
index eb10a61..6a3a150 100644
--- a/Introduction to Build Systems Using Make/Compilation/include/multifile_func.h	
+++ b/Introduction to Build Systems Using Make/Compilation/include/multifile_func.h	
@@ -1,7 +1,7 @@
-#ifndef MULTIFILE_FUNC_H_
-#define MULTIFILE_FUNC_H_
-
-void say_hello(void);
-void print_the_time(void);
-
-#endif /* MULTIFILE_FUNC_H */
+#ifndef MULTIFILE_FUNC_H_
+#define MULTIFILE_FUNC_H_
+
+void say_hello(void);
+void print_the_time(void);
+
+#endif /* MULTIFILE_FUNC_H */
diff --git a/Introduction to Build Systems Using Make/Compilation/multifile_func.c b/Introduction to Build Systems Using Make/Compilation/multifile_func.c
index bd4bf71..01e5681 100644
--- a/Introduction to Build Systems Using Make/Compilation/multifile_func.c	
+++ b/Introduction to Build Systems Using Make/Compilation/multifile_func.c	
@@ -1,16 +1,16 @@
-#include <stdio.h>
-#include <time.h>
-#include "multifile_func.h"
-
-void say_hello(void)
-{
-	printf("Hello, human. How are you today?\n");
-}
-
-void print_the_time(void)
-{
-	time_t current_time;
-	time(&current_time);
-
-	printf("Right now it is: %s", ctime(&current_time));
-}
+#include <stdio.h>
+#include <time.h>
+#include "multifile_func.h"
+
+void say_hello(void)
+{
+	printf("Hello, human. How are you today?\n");
+}
+
+void print_the_time(void)
+{
+	time_t current_time;
+	time(&current_time);
+
+	printf("Right now it is: %s", ctime(&current_time));
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/multifile_func.h b/Introduction to Build Systems Using Make/Compilation/multifile_func.h
index eb10a61..6a3a150 100644
--- a/Introduction to Build Systems Using Make/Compilation/multifile_func.h	
+++ b/Introduction to Build Systems Using Make/Compilation/multifile_func.h	
@@ -1,7 +1,7 @@
-#ifndef MULTIFILE_FUNC_H_
-#define MULTIFILE_FUNC_H_
-
-void say_hello(void);
-void print_the_time(void);
-
-#endif /* MULTIFILE_FUNC_H */
+#ifndef MULTIFILE_FUNC_H_
+#define MULTIFILE_FUNC_H_
+
+void say_hello(void);
+void print_the_time(void);
+
+#endif /* MULTIFILE_FUNC_H */
diff --git a/Introduction to Build Systems Using Make/Compilation/multifile_main.c b/Introduction to Build Systems Using Make/Compilation/multifile_main.c
index 9708c6a..a828ae3 100644
--- a/Introduction to Build Systems Using Make/Compilation/multifile_main.c	
+++ b/Introduction to Build Systems Using Make/Compilation/multifile_main.c	
@@ -1,9 +1,9 @@
-#include "multifile_func.h"
-
-int main(void)
-{
-	say_hello();
-	print_the_time();
-
-	return 0;
-}
+#include "multifile_func.h"
+
+int main(void)
+{
+	say_hello();
+	print_the_time();
+
+	return 0;
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/src/lib/multifile_func.c b/Introduction to Build Systems Using Make/Compilation/src/lib/multifile_func.c
index bd4bf71..01e5681 100644
--- a/Introduction to Build Systems Using Make/Compilation/src/lib/multifile_func.c	
+++ b/Introduction to Build Systems Using Make/Compilation/src/lib/multifile_func.c	
@@ -1,16 +1,16 @@
-#include <stdio.h>
-#include <time.h>
-#include "multifile_func.h"
-
-void say_hello(void)
-{
-	printf("Hello, human. How are you today?\n");
-}
-
-void print_the_time(void)
-{
-	time_t current_time;
-	time(&current_time);
-
-	printf("Right now it is: %s", ctime(&current_time));
-}
+#include <stdio.h>
+#include <time.h>
+#include "multifile_func.h"
+
+void say_hello(void)
+{
+	printf("Hello, human. How are you today?\n");
+}
+
+void print_the_time(void)
+{
+	time_t current_time;
+	time(&current_time);
+
+	printf("Right now it is: %s", ctime(&current_time));
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/src/multifile_main.c b/Introduction to Build Systems Using Make/Compilation/src/multifile_main.c
index 9708c6a..a828ae3 100644
--- a/Introduction to Build Systems Using Make/Compilation/src/multifile_main.c	
+++ b/Introduction to Build Systems Using Make/Compilation/src/multifile_main.c	
@@ -1,9 +1,9 @@
-#include "multifile_func.h"
-
-int main(void)
-{
-	say_hello();
-	print_the_time();
-
-	return 0;
-}
+#include "multifile_func.h"
+
+int main(void)
+{
+	say_hello();
+	print_the_time();
+
+	return 0;
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/standalone_program.c b/Introduction to Build Systems Using Make/Compilation/standalone_program.c
index 025786d..2932e99 100644
--- a/Introduction to Build Systems Using Make/Compilation/standalone_program.c	
+++ b/Introduction to Build Systems Using Make/Compilation/standalone_program.c	
@@ -1,7 +1,7 @@
-#include <stdio.h>
-
-int main(void)
-{
-	printf("Hello, human. How are you today?\n");
-	return 0;
-}
+#include <stdio.h>
+
+int main(void)
+{
+	printf("Hello, human. How are you today?\n");
+	return 0;
+}
diff --git a/Introduction to Build Systems Using Make/Compilation/standalone_program.s b/Introduction to Build Systems Using Make/Compilation/standalone_program.s
index b49ef54..12f95e1 100644
--- a/Introduction to Build Systems Using Make/Compilation/standalone_program.s	
+++ b/Introduction to Build Systems Using Make/Compilation/standalone_program.s	
@@ -1,45 +1,45 @@
-	.file	"standalone_program.c"
-	.text
-	.section	.rodata
-	.align 8
-.LC0:
-	.string	"Hello, human. How are you today?"
-	.text
-	.globl	main
-	.type	main, @function
-main:
-.LFB0:
-	.cfi_startproc
-	endbr64
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	leaq	.LC0(%rip), %rdi
-	call	puts@PLT
-	movl	$0, %eax
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE0:
-	.size	main, .-main
-	.ident	"GCC: (Ubuntu 9.3.0-10ubuntu2) 9.3.0"
-	.section	.note.GNU-stack,"",@progbits
-	.section	.note.gnu.property,"a"
-	.align 8
-	.long	 1f - 0f
-	.long	 4f - 1f
-	.long	 5
-0:
-	.string	 "GNU"
-1:
-	.align 8
-	.long	 0xc0000002
-	.long	 3f - 2f
-2:
-	.long	 0x3
-3:
-	.align 8
-4:
+	.file	"standalone_program.c"
+	.text
+	.section	.rodata
+	.align 8
+.LC0:
+	.string	"Hello, human. How are you today?"
+	.text
+	.globl	main
+	.type	main, @function
+main:
+.LFB0:
+	.cfi_startproc
+	endbr64
+	pushq	%rbp
+	.cfi_def_cfa_offset 16
+	.cfi_offset 6, -16
+	movq	%rsp, %rbp
+	.cfi_def_cfa_register 6
+	leaq	.LC0(%rip), %rdi
+	call	puts@PLT
+	movl	$0, %eax
+	popq	%rbp
+	.cfi_def_cfa 7, 8
+	ret
+	.cfi_endproc
+.LFE0:
+	.size	main, .-main
+	.ident	"GCC: (Ubuntu 9.3.0-10ubuntu2) 9.3.0"
+	.section	.note.GNU-stack,"",@progbits
+	.section	.note.gnu.property,"a"
+	.align 8
+	.long	 1f - 0f
+	.long	 4f - 1f
+	.long	 5
+0:
+	.string	 "GNU"
+1:
+	.align 8
+	.long	 0xc0000002
+	.long	 3f - 2f
+2:
+	.long	 0x3
+3:
+	.align 8
+4:
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/lib/linkedlist/ll.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/lib/linkedlist/ll.h
index 4311d94..0ed3930 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/lib/linkedlist/ll.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/lib/linkedlist/ll.h	
@@ -1,367 +1,367 @@
-#ifndef LL_H__
-#define LL_H__
-
-#include <stdint.h>
-#include <stdlib.h> //size_t, NULL
-
-/** @defgroup linkedlist-C C Linked List Interface
- * A linked list library for C modules
- *
- * @ingroup FrameworkUtils
- * @{
- */
-
-/**
- * Define offsetof if we don't have it already
- */
-#ifndef offsetof
-#ifdef __compiler_offsetof
-#define offsetof(TYPE, MEMBER) __compiler_offsetof(TYPE, MEMBER)
-#else
-#define offsetof(TYPE, MEMBER) ((size_t) & ((TYPE*)0)->MEMBER)
-#endif
-#endif // offsetof
-
-/**
- * Define container_of if we don't have it already
- */
-#ifndef container_of
-#ifdef __GNUC__
-#ifndef __clang__
-// Isolate the GNU-specific expression
-#define container_of(ptr, type, member)                       \
-	__extension__ ({                                                        \
-		const __typeof__(((type*)0)->member)* __mptr = (ptr); \
-		(type*)((uintptr_t)__mptr - offsetof(type, member));  \
-	})
-#else // we are clang - avoid GNU expression
-#define container_of(ptr, type, member) ((type*)((uintptr_t)(ptr)-offsetof(type, member)))
-#endif // GNU and not clang
-#else
-#define container_of(ptr, type, member) ((type*)((uintptr_t)(ptr)-offsetof(type, member)))
-#endif // not GNU
-#endif // container_of
-
-#ifdef __cplusplus
-extern "C" {
-#endif //__cplusplus
-
-/** Linked list struct
- *
- * This is a doubly linked list structure.
- * The ll_t structure should be embedded in a container structure that you want to list.
- *
- * Example:
- *
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- */
-typedef struct ll_head
-{
-	/// Pointer to the next element in the list.
-	struct ll_head* next;
-	/// Pointer to the previous element in the list.
-	struct ll_head* prev;
-} ll_t;
-
-#pragma mark - List Manipulation -
-
-/// @name Get Containers
-/// @{
-
-/** Get the container for a list entry
- *
- * @param[in] ptr The pointer to the target ll_t node.
- * @param[in] type The struct type which contains the ll_t node. For this example struct,
- * type would refer to alloc_node_t:
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- *
- * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
- * example struct, member would refer to `node`.
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- *
- * @returns a pointer to the struct containing the linked list node at `ptr`, cast to type `type`.
- */
-#define list_entry(ptr, type, member) container_of(ptr, type, member)
-
-/** Get the container for the first item in the list
- *
- * @param[in] head The pointer to the head of the list.
- * @param[in] type The struct type which contains the ll_t node. For this example struct,
- * type would refer to alloc_node_t:
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
-
- * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
- * example struct, member would refer to `node`.
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- *
- * @returns a pointer to the struct containing the linked list node at `ptr`, cast to type `type`.
- */
-#define list_first_entry(head, type, member) list_entry((head)->next, type, member)
-
-/// @}
-// Get containers
-
-#pragma mark - Foreach -
-
-/// @name Foreach Operations
-/// @{
-
-/** Declare a foreach loop which iterates over the list
- *
- * list_for_each() will run as long as the current object's next pointer is not equal to the
- * head of the list. It's possible for a malformed list to loop forever.
- *
- * @param[in] pos The variable which will hold the current iteration's position value.
- *	This variable must be a pointer and should be pre-declared before instantiating the loop.
- *	@code
- *	ll_t *b;
- *	list_for_each(b, &free_list)
- *   {
- *	...
- * 	}
- *   @endcode
- * @param[in] head The head of of the linked list. Input should be a pointer.
- */
-#define list_for_each(pos, head) for(pos = (head)->next; pos != (head); pos = pos->next)
-
-/** Declare a foreach loop which iterates over the list, copy current node pointer.
- *
- * list_for_each_safe() will run as long as the current object's next pointer is not equal to the
- * head of the list. It's possible for a malformed list to loop forever.
- *
- * The list_for_each_safe() variant makes a copy of the current node pointer, enabling the loop
- * to get to the next pointer if there is a deletion.
- *
- * @param[in] pos The variable which will hold the current iteration's position value.
- *	This variable must be a pointer should be pre-declared before instantiating the loop.
- *	@code
- *	ll_t *b, *t;
- *	list_for_each_safe(b, t, &free_list)
- *   {
- *	...
- * 	}
- *  @endcode
- * @param[in] n The variable which will hold the current iteration's position value **copy**.
- *	This variable must be a pointer and should be pre-declared before instantiating the loop.
- *	@code
- *	alloc_node_t *b, *t;
- *	list_for_each_safe(b, t, &free_list)
- *   {
- *	...
- * 	}
- *	@endcode
- * @param[in] head The head of of the linked list. Input should be a pointer.
- */
-#define list_for_each_safe(pos, n, head) \
-	for(pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)
-
-/** Declare a for loop which operates on each node in the list using the container value.
- *
- * @param[in] pos The variable which will hold the current iteration's position value.
- *	This variable must be a pointer and should be pre-declared before instantiating the loop.
- *  The `pos` variable must be the container type.
- *	@code
- *	alloc_node_t *b, *t;
- *	list_for_each_entry(b, &free_list, node)
- *   {
- *	...
- * 	}
- *  @endcode
- *
- * @param[in] head The head of of the linked list. Input should be a pointer.
- *
- * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
- * example struct, member would refer to `node`.
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- */
-#define list_for_each_entry(pos, head, member)                                            \
-	for(pos = list_entry((head)->next, __typeof__(*pos), member); &pos->member != (head); \
-		pos = list_entry(pos->member.next, __typeof__(*pos), member))
-
-/** Declare a for loop which operates on each node in the list using a copy of the container value.
- *
- * @param[in] pos The variable which will hold the current iteration's position value.
- *	This variable must be a pointer and should be pre-declared before instantiating the loop.
- *  The `pos` variable must be the container type.
- *	@code
- *	alloc_node_t *b, *t;
- *	list_for_each_entry(b, &free_list, node)
- *   {
- *	...
- * 	}
- *  @endcode
- * @param[in] n The variable which will hold the current iteration's position value **copy**.
- *	This variable must be a pointer and should be pre-declared before instantiating the loop.
- *  The `n` variable must be the container type.
- *	@code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- *
- *	alloc_node_t *b, *t;
- *	list_for_each_entrysafe(b, t, &free_list, node)
- *   {
- *	...
- * 	}
- *   @endcode
- * @param[in] head The head of of the linked list. Input should be a pointer.
- * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
- * example struct, member would refer to `node`.
- * @code
- * typedef struct
- * {
- * 	ll_t node;
- * 	size_t size;
- * 	char* block;
- * } alloc_node_t;
- * @endcode
- */
-#define list_for_each_entry_safe(pos, n, head, member)            \
-	for(pos = list_entry((head)->next, __typeof__(*pos), member), \
-	n = list_entry(pos->member.next, __typeof__(*pos), member);   \
-		&pos->member != (head); pos = n, n = list_entry(n->member.next, __typeof__(*n), member))
-
-/// @}
-// End foreach
-
-#pragma mark - Init -
-
-/// @name Initialization
-/// @{
-
-/// Initialize a linked list so it points to itself
-/// @param[in] name of the linked list object
-#define ll_head_INIT(name) \
-	{                      \
-		&(name), &(name)   \
-	}
-
-/** Initialize a linked list
- *
- * @code
- * // This macro declares and initializes our linked list
- * static LIST_INIT(free_list);
- * @endcode
- * @param[in] name The name of the linked list object to declare
- */
-#define LIST_INIT(name) struct ll_head name = ll_head_INIT(name)
-
-/// @}
-
-#pragma mark - Add -
-
-/// @name Addition
-/// @{
-
-/// Insert a new element between two existing elements.
-/// @param[in] n The node to add to the list.
-/// @param[in] prev The pointer to the node before where the new node will be inserted.
-/// @param[in] next The pointer to the new node after where the new node will be inserted.
-static inline void list_insert(struct ll_head* n, struct ll_head* prev, struct ll_head* next)
-{
-	next->prev = n;
-	n->next = next;
-	n->prev = prev;
-	prev->next = n;
-}
-
-/// Add a node to the front of the list
-/// @param[in] n The node to add to the list.
-/// @param[in] head The head of the list.
-static inline void list_add(struct ll_head* n, struct ll_head* head)
-{
-	list_insert(n, head, head->next);
-}
-
-/// Add a node to the end of the list
-/// @param[in] n The node to add to the list.
-/// @param[in] head The head of the list.
-static inline void list_add_tail(struct ll_head* n, struct ll_head* head)
-{
-	list_insert(n, head->prev, head);
-}
-
-/// @}
-
-#pragma mark - Delete -
-
-/// @name Deletion
-/// @{
-
-/// Remove the node between two element pointers.
-///
-/// Joins the `prev` and `next` elements together, effectively removing
-/// the element in the middle.
-///
-/// @param[in] prev The previous element in the list, which will now be joined to next.
-/// @param[in] next The next element in the list, which will now be joined to prev.
-static inline void list_join_nodes(struct ll_head* prev, struct ll_head* next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/// Remove an entry from the list
-/// @param[in] entry The pointer to the entry to remove from the list.
-static inline void list_del(struct ll_head* entry)
-{
-	list_join_nodes(entry->prev, entry->next);
-	entry->next = NULL;
-	entry->prev = NULL;
-}
-
-/// @}
-
-/// @}
-// end group
-
-#ifdef __cplusplus
-}
-#endif //__cplusplus
-
-#endif // LL_H__
+#ifndef LL_H__
+#define LL_H__
+
+#include <stdint.h>
+#include <stdlib.h> //size_t, NULL
+
+/** @defgroup linkedlist-C C Linked List Interface
+ * A linked list library for C modules
+ *
+ * @ingroup FrameworkUtils
+ * @{
+ */
+
+/**
+ * Define offsetof if we don't have it already
+ */
+#ifndef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE, MEMBER) __compiler_offsetof(TYPE, MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) & ((TYPE*)0)->MEMBER)
+#endif
+#endif // offsetof
+
+/**
+ * Define container_of if we don't have it already
+ */
+#ifndef container_of
+#ifdef __GNUC__
+#ifndef __clang__
+// Isolate the GNU-specific expression
+#define container_of(ptr, type, member)                       \
+	__extension__ ({                                                        \
+		const __typeof__(((type*)0)->member)* __mptr = (ptr); \
+		(type*)((uintptr_t)__mptr - offsetof(type, member));  \
+	})
+#else // we are clang - avoid GNU expression
+#define container_of(ptr, type, member) ((type*)((uintptr_t)(ptr)-offsetof(type, member)))
+#endif // GNU and not clang
+#else
+#define container_of(ptr, type, member) ((type*)((uintptr_t)(ptr)-offsetof(type, member)))
+#endif // not GNU
+#endif // container_of
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+/** Linked list struct
+ *
+ * This is a doubly linked list structure.
+ * The ll_t structure should be embedded in a container structure that you want to list.
+ *
+ * Example:
+ *
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ */
+typedef struct ll_head
+{
+	/// Pointer to the next element in the list.
+	struct ll_head* next;
+	/// Pointer to the previous element in the list.
+	struct ll_head* prev;
+} ll_t;
+
+#pragma mark - List Manipulation -
+
+/// @name Get Containers
+/// @{
+
+/** Get the container for a list entry
+ *
+ * @param[in] ptr The pointer to the target ll_t node.
+ * @param[in] type The struct type which contains the ll_t node. For this example struct,
+ * type would refer to alloc_node_t:
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ *
+ * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
+ * example struct, member would refer to `node`.
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ *
+ * @returns a pointer to the struct containing the linked list node at `ptr`, cast to type `type`.
+ */
+#define list_entry(ptr, type, member) container_of(ptr, type, member)
+
+/** Get the container for the first item in the list
+ *
+ * @param[in] head The pointer to the head of the list.
+ * @param[in] type The struct type which contains the ll_t node. For this example struct,
+ * type would refer to alloc_node_t:
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+
+ * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
+ * example struct, member would refer to `node`.
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ *
+ * @returns a pointer to the struct containing the linked list node at `ptr`, cast to type `type`.
+ */
+#define list_first_entry(head, type, member) list_entry((head)->next, type, member)
+
+/// @}
+// Get containers
+
+#pragma mark - Foreach -
+
+/// @name Foreach Operations
+/// @{
+
+/** Declare a foreach loop which iterates over the list
+ *
+ * list_for_each() will run as long as the current object's next pointer is not equal to the
+ * head of the list. It's possible for a malformed list to loop forever.
+ *
+ * @param[in] pos The variable which will hold the current iteration's position value.
+ *	This variable must be a pointer and should be pre-declared before instantiating the loop.
+ *	@code
+ *	ll_t *b;
+ *	list_for_each(b, &free_list)
+ *   {
+ *	...
+ * 	}
+ *   @endcode
+ * @param[in] head The head of of the linked list. Input should be a pointer.
+ */
+#define list_for_each(pos, head) for(pos = (head)->next; pos != (head); pos = pos->next)
+
+/** Declare a foreach loop which iterates over the list, copy current node pointer.
+ *
+ * list_for_each_safe() will run as long as the current object's next pointer is not equal to the
+ * head of the list. It's possible for a malformed list to loop forever.
+ *
+ * The list_for_each_safe() variant makes a copy of the current node pointer, enabling the loop
+ * to get to the next pointer if there is a deletion.
+ *
+ * @param[in] pos The variable which will hold the current iteration's position value.
+ *	This variable must be a pointer should be pre-declared before instantiating the loop.
+ *	@code
+ *	ll_t *b, *t;
+ *	list_for_each_safe(b, t, &free_list)
+ *   {
+ *	...
+ * 	}
+ *  @endcode
+ * @param[in] n The variable which will hold the current iteration's position value **copy**.
+ *	This variable must be a pointer and should be pre-declared before instantiating the loop.
+ *	@code
+ *	alloc_node_t *b, *t;
+ *	list_for_each_safe(b, t, &free_list)
+ *   {
+ *	...
+ * 	}
+ *	@endcode
+ * @param[in] head The head of of the linked list. Input should be a pointer.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for(pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)
+
+/** Declare a for loop which operates on each node in the list using the container value.
+ *
+ * @param[in] pos The variable which will hold the current iteration's position value.
+ *	This variable must be a pointer and should be pre-declared before instantiating the loop.
+ *  The `pos` variable must be the container type.
+ *	@code
+ *	alloc_node_t *b, *t;
+ *	list_for_each_entry(b, &free_list, node)
+ *   {
+ *	...
+ * 	}
+ *  @endcode
+ *
+ * @param[in] head The head of of the linked list. Input should be a pointer.
+ *
+ * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
+ * example struct, member would refer to `node`.
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ */
+#define list_for_each_entry(pos, head, member)                                            \
+	for(pos = list_entry((head)->next, __typeof__(*pos), member); &pos->member != (head); \
+		pos = list_entry(pos->member.next, __typeof__(*pos), member))
+
+/** Declare a for loop which operates on each node in the list using a copy of the container value.
+ *
+ * @param[in] pos The variable which will hold the current iteration's position value.
+ *	This variable must be a pointer and should be pre-declared before instantiating the loop.
+ *  The `pos` variable must be the container type.
+ *	@code
+ *	alloc_node_t *b, *t;
+ *	list_for_each_entry(b, &free_list, node)
+ *   {
+ *	...
+ * 	}
+ *  @endcode
+ * @param[in] n The variable which will hold the current iteration's position value **copy**.
+ *	This variable must be a pointer and should be pre-declared before instantiating the loop.
+ *  The `n` variable must be the container type.
+ *	@code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ *
+ *	alloc_node_t *b, *t;
+ *	list_for_each_entrysafe(b, t, &free_list, node)
+ *   {
+ *	...
+ * 	}
+ *   @endcode
+ * @param[in] head The head of of the linked list. Input should be a pointer.
+ * @param[in] member The member which corresponds to the member name of the ll_t entry. For this
+ * example struct, member would refer to `node`.
+ * @code
+ * typedef struct
+ * {
+ * 	ll_t node;
+ * 	size_t size;
+ * 	char* block;
+ * } alloc_node_t;
+ * @endcode
+ */
+#define list_for_each_entry_safe(pos, n, head, member)            \
+	for(pos = list_entry((head)->next, __typeof__(*pos), member), \
+	n = list_entry(pos->member.next, __typeof__(*pos), member);   \
+		&pos->member != (head); pos = n, n = list_entry(n->member.next, __typeof__(*n), member))
+
+/// @}
+// End foreach
+
+#pragma mark - Init -
+
+/// @name Initialization
+/// @{
+
+/// Initialize a linked list so it points to itself
+/// @param[in] name of the linked list object
+#define ll_head_INIT(name) \
+	{                      \
+		&(name), &(name)   \
+	}
+
+/** Initialize a linked list
+ *
+ * @code
+ * // This macro declares and initializes our linked list
+ * static LIST_INIT(free_list);
+ * @endcode
+ * @param[in] name The name of the linked list object to declare
+ */
+#define LIST_INIT(name) struct ll_head name = ll_head_INIT(name)
+
+/// @}
+
+#pragma mark - Add -
+
+/// @name Addition
+/// @{
+
+/// Insert a new element between two existing elements.
+/// @param[in] n The node to add to the list.
+/// @param[in] prev The pointer to the node before where the new node will be inserted.
+/// @param[in] next The pointer to the new node after where the new node will be inserted.
+static inline void list_insert(struct ll_head* n, struct ll_head* prev, struct ll_head* next)
+{
+	next->prev = n;
+	n->next = next;
+	n->prev = prev;
+	prev->next = n;
+}
+
+/// Add a node to the front of the list
+/// @param[in] n The node to add to the list.
+/// @param[in] head The head of the list.
+static inline void list_add(struct ll_head* n, struct ll_head* head)
+{
+	list_insert(n, head, head->next);
+}
+
+/// Add a node to the end of the list
+/// @param[in] n The node to add to the list.
+/// @param[in] head The head of the list.
+static inline void list_add_tail(struct ll_head* n, struct ll_head* head)
+{
+	list_insert(n, head->prev, head);
+}
+
+/// @}
+
+#pragma mark - Delete -
+
+/// @name Deletion
+/// @{
+
+/// Remove the node between two element pointers.
+///
+/// Joins the `prev` and `next` elements together, effectively removing
+/// the element in the middle.
+///
+/// @param[in] prev The previous element in the list, which will now be joined to next.
+/// @param[in] next The next element in the list, which will now be joined to prev.
+static inline void list_join_nodes(struct ll_head* prev, struct ll_head* next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/// Remove an entry from the list
+/// @param[in] entry The pointer to the entry to remove from the list.
+static inline void list_del(struct ll_head* entry)
+{
+	list_join_nodes(entry->prev, entry->next);
+	entry->next = NULL;
+	entry->prev = NULL;
+}
+
+/// @}
+
+/// @}
+// end group
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+
+#endif // LL_H__
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOS.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOS.h
index 78d176a..f974c73 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOS.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOS.h	
@@ -1,1168 +1,1168 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef INC_FREERTOS_H
-#define INC_FREERTOS_H
-
-/*
- * Include the generic headers required for the FreeRTOS port being used.
- */
-#include <stddef.h>
-
-/*
- * If stdint.h cannot be located then:
- *   + If using GCC ensure the -nostdint options is *not* being used.
- *   + Ensure the project's include path includes the directory in which your
- *     compiler stores stdint.h.
- *   + Set any compiler options necessary for it to support C99, as technically
- *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
- *     other way).
- *   + The FreeRTOS download includes a simple stdint.h definition that can be
- *     used in cases where none is provided by the compiler.  The files only
- *     contains the typedefs required to build FreeRTOS.  Read the instructions
- *     in FreeRTOS/source/stdint.readme for more information.
- */
-#include <stdint.h> /* READ COMMENT ABOVE. */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Application specific configuration options. */
-#include "FreeRTOSConfig.h"
-
-/* Basic FreeRTOS definitions. */
-#include "projdefs.h"
-
-/* Definitions specific to the port being used. */
-#include "portable.h"
-
-/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
-#ifndef configUSE_NEWLIB_REENTRANT
-	#define configUSE_NEWLIB_REENTRANT 0
-#endif
-
-/* Required if struct _reent is used. */
-#if ( configUSE_NEWLIB_REENTRANT == 1 )
-	#include <reent.h>
-#endif
-/*
- * Check all the required application specific macros have been defined.
- * These macros are application specific and (as downloaded) are defined
- * within FreeRTOSConfig.h.
- */
-
-#ifndef configMINIMAL_STACK_SIZE
-	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
-#endif
-
-#ifndef configMAX_PRIORITIES
-	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#if configMAX_PRIORITIES < 1
-	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
-#endif
-
-#ifndef configUSE_PREEMPTION
-	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_IDLE_HOOK
-	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_TICK_HOOK
-	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_16_BIT_TICKS
-	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
-#endif
-
-#ifndef configUSE_CO_ROUTINES
-	#define configUSE_CO_ROUTINES 0
-#endif
-
-#ifndef INCLUDE_vTaskPrioritySet
-	#define INCLUDE_vTaskPrioritySet 0
-#endif
-
-#ifndef INCLUDE_uxTaskPriorityGet
-	#define INCLUDE_uxTaskPriorityGet 0
-#endif
-
-#ifndef INCLUDE_vTaskDelete
-	#define INCLUDE_vTaskDelete 0
-#endif
-
-#ifndef INCLUDE_vTaskSuspend
-	#define INCLUDE_vTaskSuspend 0
-#endif
-
-#ifndef INCLUDE_vTaskDelayUntil
-	#define INCLUDE_vTaskDelayUntil 0
-#endif
-
-#ifndef INCLUDE_vTaskDelay
-	#define INCLUDE_vTaskDelay 0
-#endif
-
-#ifndef INCLUDE_xTaskGetIdleTaskHandle
-	#define INCLUDE_xTaskGetIdleTaskHandle 0
-#endif
-
-#ifndef INCLUDE_xTaskAbortDelay
-	#define INCLUDE_xTaskAbortDelay 0
-#endif
-
-#ifndef INCLUDE_xQueueGetMutexHolder
-	#define INCLUDE_xQueueGetMutexHolder 0
-#endif
-
-#ifndef INCLUDE_xSemaphoreGetMutexHolder
-	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
-#endif
-
-#ifndef INCLUDE_xTaskGetHandle
-	#define INCLUDE_xTaskGetHandle 0
-#endif
-
-#ifndef INCLUDE_uxTaskGetStackHighWaterMark
-	#define INCLUDE_uxTaskGetStackHighWaterMark 0
-#endif
-
-#ifndef INCLUDE_eTaskGetState
-	#define INCLUDE_eTaskGetState 0
-#endif
-
-#ifndef INCLUDE_xTaskResumeFromISR
-	#define INCLUDE_xTaskResumeFromISR 1
-#endif
-
-#ifndef INCLUDE_xTimerPendFunctionCall
-	#define INCLUDE_xTimerPendFunctionCall 0
-#endif
-
-#ifndef INCLUDE_xTaskGetSchedulerState
-	#define INCLUDE_xTaskGetSchedulerState 0
-#endif
-
-#ifndef INCLUDE_xTaskGetCurrentTaskHandle
-	#define INCLUDE_xTaskGetCurrentTaskHandle 0
-#endif
-
-#if configUSE_CO_ROUTINES != 0
-	#ifndef configMAX_CO_ROUTINE_PRIORITIES
-		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
-	#endif
-#endif
-
-#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
-	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
-#endif
-
-#ifndef configUSE_APPLICATION_TASK_TAG
-	#define configUSE_APPLICATION_TASK_TAG 0
-#endif
-
-#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
-	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
-#endif
-
-#ifndef configUSE_RECURSIVE_MUTEXES
-	#define configUSE_RECURSIVE_MUTEXES 0
-#endif
-
-#ifndef configUSE_MUTEXES
-	#define configUSE_MUTEXES 0
-#endif
-
-#ifndef configUSE_TIMERS
-	#define configUSE_TIMERS 0
-#endif
-
-#ifndef configUSE_COUNTING_SEMAPHORES
-	#define configUSE_COUNTING_SEMAPHORES 0
-#endif
-
-#ifndef configUSE_ALTERNATIVE_API
-	#define configUSE_ALTERNATIVE_API 0
-#endif
-
-#ifndef portCRITICAL_NESTING_IN_TCB
-	#define portCRITICAL_NESTING_IN_TCB 0
-#endif
-
-#ifndef configMAX_TASK_NAME_LEN
-	#define configMAX_TASK_NAME_LEN 16
-#endif
-
-#ifndef configIDLE_SHOULD_YIELD
-	#define configIDLE_SHOULD_YIELD		1
-#endif
-
-#if configMAX_TASK_NAME_LEN < 1
-	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
-#endif
-
-#ifndef configASSERT
-	#define configASSERT( x )
-	#define configASSERT_DEFINED 0
-#else
-	#define configASSERT_DEFINED 1
-#endif
-
-/* The timers module relies on xTaskGetSchedulerState(). */
-#if configUSE_TIMERS == 1
-
-	#ifndef configTIMER_TASK_PRIORITY
-		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
-	#endif /* configTIMER_TASK_PRIORITY */
-
-	#ifndef configTIMER_QUEUE_LENGTH
-		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
-	#endif /* configTIMER_QUEUE_LENGTH */
-
-	#ifndef configTIMER_TASK_STACK_DEPTH
-		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
-	#endif /* configTIMER_TASK_STACK_DEPTH */
-
-#endif /* configUSE_TIMERS */
-
-#ifndef portSET_INTERRUPT_MASK_FROM_ISR
-	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
-#endif
-
-#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
-	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
-#endif
-
-#ifndef portCLEAN_UP_TCB
-	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
-#endif
-
-#ifndef portPRE_TASK_DELETE_HOOK
-	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
-#endif
-
-#ifndef portSETUP_TCB
-	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
-#endif
-
-#ifndef configQUEUE_REGISTRY_SIZE
-	#define configQUEUE_REGISTRY_SIZE 0U
-#endif
-
-#if ( configQUEUE_REGISTRY_SIZE < 1 )
-	#define vQueueAddToRegistry( xQueue, pcName )
-	#define vQueueUnregisterQueue( xQueue )
-	#define pcQueueGetName( xQueue )
-#endif
-
-#ifndef portPOINTER_SIZE_TYPE
-	#define portPOINTER_SIZE_TYPE uint32_t
-#endif
-
-/* Remove any unused trace macros. */
-#ifndef traceSTART
-	/* Used to perform any necessary initialisation - for example, open a file
-	into which trace is to be written. */
-	#define traceSTART()
-#endif
-
-#ifndef traceEND
-	/* Use to close a trace, for example close a file into which trace has been
-	written. */
-	#define traceEND()
-#endif
-
-#ifndef traceTASK_SWITCHED_IN
-	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
-	to the task control block of the selected task. */
-	#define traceTASK_SWITCHED_IN()
-#endif
-
-#ifndef traceINCREASE_TICK_COUNT
-	/* Called before stepping the tick count after waking from tickless idle
-	sleep. */
-	#define traceINCREASE_TICK_COUNT( x )
-#endif
-
-#ifndef traceLOW_POWER_IDLE_BEGIN
-	/* Called immediately before entering tickless idle. */
-	#define traceLOW_POWER_IDLE_BEGIN()
-#endif
-
-#ifndef	traceLOW_POWER_IDLE_END
-	/* Called when returning to the Idle task after a tickless idle. */
-	#define traceLOW_POWER_IDLE_END()
-#endif
-
-#ifndef traceTASK_SWITCHED_OUT
-	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
-	to the task control block of the task being switched out. */
-	#define traceTASK_SWITCHED_OUT()
-#endif
-
-#ifndef traceTASK_PRIORITY_INHERIT
-	/* Called when a task attempts to take a mutex that is already held by a
-	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
-	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
-	will inherit (the priority of the task that is attempting to obtain the
-	muted. */
-	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
-#endif
-
-#ifndef traceTASK_PRIORITY_DISINHERIT
-	/* Called when a task releases a mutex, the holding of which had resulted in
-	the task inheriting the priority of a higher priority task.
-	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
-	mutex.  uxOriginalPriority is the task's configured (base) priority. */
-	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
-	/* Task is about to block because it cannot read from a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the read. */
-	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_PEEK
-	/* Task is about to block because it cannot read from a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the read. */
-	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
-#endif
-
-#ifndef traceBLOCKING_ON_QUEUE_SEND
-	/* Task is about to block because it cannot write to a
-	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
-	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
-	task that attempted the write. */
-	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
-#endif
-
-#ifndef configCHECK_FOR_STACK_OVERFLOW
-	#define configCHECK_FOR_STACK_OVERFLOW 0
-#endif
-
-#ifndef configRECORD_STACK_HIGH_ADDRESS
-	#define configRECORD_STACK_HIGH_ADDRESS 0
-#endif
-
-#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
-	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
-#endif
-
-/* The following event macros are embedded in the kernel API calls. */
-
-#ifndef traceMOVED_TASK_TO_READY_STATE
-	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
-#endif
-
-#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
-	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
-#endif
-
-#ifndef traceQUEUE_CREATE
-	#define traceQUEUE_CREATE( pxNewQueue )
-#endif
-
-#ifndef traceQUEUE_CREATE_FAILED
-	#define traceQUEUE_CREATE_FAILED( ucQueueType )
-#endif
-
-#ifndef traceCREATE_MUTEX
-	#define traceCREATE_MUTEX( pxNewQueue )
-#endif
-
-#ifndef traceCREATE_MUTEX_FAILED
-	#define traceCREATE_MUTEX_FAILED()
-#endif
-
-#ifndef traceGIVE_MUTEX_RECURSIVE
-	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
-#endif
-
-#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
-	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
-#endif
-
-#ifndef traceTAKE_MUTEX_RECURSIVE
-	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
-#endif
-
-#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
-	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
-#endif
-
-#ifndef traceCREATE_COUNTING_SEMAPHORE
-	#define traceCREATE_COUNTING_SEMAPHORE()
-#endif
-
-#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
-	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
-#endif
-
-#ifndef traceQUEUE_SEND
-	#define traceQUEUE_SEND( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FAILED
-	#define traceQUEUE_SEND_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE
-	#define traceQUEUE_RECEIVE( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK
-	#define traceQUEUE_PEEK( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FAILED
-	#define traceQUEUE_PEEK_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FROM_ISR
-	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FAILED
-	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FROM_ISR
-	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
-	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FROM_ISR
-	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
-#endif
-
-#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
-	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
-	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
-#endif
-
-#ifndef traceQUEUE_DELETE
-	#define traceQUEUE_DELETE( pxQueue )
-#endif
-
-#ifndef traceTASK_CREATE
-	#define traceTASK_CREATE( pxNewTCB )
-#endif
-
-#ifndef traceTASK_CREATE_FAILED
-	#define traceTASK_CREATE_FAILED()
-#endif
-
-#ifndef traceTASK_DELETE
-	#define traceTASK_DELETE( pxTaskToDelete )
-#endif
-
-#ifndef traceTASK_DELAY_UNTIL
-	#define traceTASK_DELAY_UNTIL( x )
-#endif
-
-#ifndef traceTASK_DELAY
-	#define traceTASK_DELAY()
-#endif
-
-#ifndef traceTASK_PRIORITY_SET
-	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
-#endif
-
-#ifndef traceTASK_SUSPEND
-	#define traceTASK_SUSPEND( pxTaskToSuspend )
-#endif
-
-#ifndef traceTASK_RESUME
-	#define traceTASK_RESUME( pxTaskToResume )
-#endif
-
-#ifndef traceTASK_RESUME_FROM_ISR
-	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
-#endif
-
-#ifndef traceTASK_INCREMENT_TICK
-	#define traceTASK_INCREMENT_TICK( xTickCount )
-#endif
-
-#ifndef traceTIMER_CREATE
-	#define traceTIMER_CREATE( pxNewTimer )
-#endif
-
-#ifndef traceTIMER_CREATE_FAILED
-	#define traceTIMER_CREATE_FAILED()
-#endif
-
-#ifndef traceTIMER_COMMAND_SEND
-	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
-#endif
-
-#ifndef traceTIMER_EXPIRED
-	#define traceTIMER_EXPIRED( pxTimer )
-#endif
-
-#ifndef traceTIMER_COMMAND_RECEIVED
-	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
-#endif
-
-#ifndef traceMALLOC
-    #define traceMALLOC( pvAddress, uiSize )
-#endif
-
-#ifndef traceFREE
-    #define traceFREE( pvAddress, uiSize )
-#endif
-
-#ifndef traceEVENT_GROUP_CREATE
-	#define traceEVENT_GROUP_CREATE( xEventGroup )
-#endif
-
-#ifndef traceEVENT_GROUP_CREATE_FAILED
-	#define traceEVENT_GROUP_CREATE_FAILED()
-#endif
-
-#ifndef traceEVENT_GROUP_SYNC_BLOCK
-	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
-#endif
-
-#ifndef traceEVENT_GROUP_SYNC_END
-	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
-#endif
-
-#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
-	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
-#endif
-
-#ifndef traceEVENT_GROUP_WAIT_BITS_END
-	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
-#endif
-
-#ifndef traceEVENT_GROUP_CLEAR_BITS
-	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
-#endif
-
-#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
-	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
-#endif
-
-#ifndef traceEVENT_GROUP_SET_BITS
-	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
-#endif
-
-#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
-	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
-#endif
-
-#ifndef traceEVENT_GROUP_DELETE
-	#define traceEVENT_GROUP_DELETE( xEventGroup )
-#endif
-
-#ifndef tracePEND_FUNC_CALL
-	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
-#endif
-
-#ifndef tracePEND_FUNC_CALL_FROM_ISR
-	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
-#endif
-
-#ifndef traceQUEUE_REGISTRY_ADD
-	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
-#endif
-
-#ifndef traceTASK_NOTIFY_TAKE_BLOCK
-	#define traceTASK_NOTIFY_TAKE_BLOCK()
-#endif
-
-#ifndef traceTASK_NOTIFY_TAKE
-	#define traceTASK_NOTIFY_TAKE()
-#endif
-
-#ifndef traceTASK_NOTIFY_WAIT_BLOCK
-	#define traceTASK_NOTIFY_WAIT_BLOCK()
-#endif
-
-#ifndef traceTASK_NOTIFY_WAIT
-	#define traceTASK_NOTIFY_WAIT()
-#endif
-
-#ifndef traceTASK_NOTIFY
-	#define traceTASK_NOTIFY()
-#endif
-
-#ifndef traceTASK_NOTIFY_FROM_ISR
-	#define traceTASK_NOTIFY_FROM_ISR()
-#endif
-
-#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
-	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE_FAILED
-	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
-	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_CREATE
-	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_DELETE
-	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RESET
-	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
-#endif
-
-#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
-	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND
-	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND_FAILED
-	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
-	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
-#endif
-
-#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
-	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE
-	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
-	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
-#endif
-
-#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
-	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
-#endif
-
-#ifndef configGENERATE_RUN_TIME_STATS
-	#define configGENERATE_RUN_TIME_STATS 0
-#endif
-
-#if ( configGENERATE_RUN_TIME_STATS == 1 )
-
-	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
-		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
-	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
-
-	#ifndef portGET_RUN_TIME_COUNTER_VALUE
-		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
-			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
-		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
-	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
-
-#endif /* configGENERATE_RUN_TIME_STATS */
-
-#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
-	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
-#endif
-
-#ifndef configUSE_MALLOC_FAILED_HOOK
-	#define configUSE_MALLOC_FAILED_HOOK 0
-#endif
-
-#ifndef portPRIVILEGE_BIT
-	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
-#endif
-
-#ifndef portYIELD_WITHIN_API
-	#define portYIELD_WITHIN_API portYIELD
-#endif
-
-#ifndef portSUPPRESS_TICKS_AND_SLEEP
-	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
-#endif
-
-#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
-	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
-#endif
-
-#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
-	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
-#endif
-
-#ifndef configUSE_TICKLESS_IDLE
-	#define configUSE_TICKLESS_IDLE 0
-#endif
-
-#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
-	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configPRE_SLEEP_PROCESSING
-	#define configPRE_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configPOST_SLEEP_PROCESSING
-	#define configPOST_SLEEP_PROCESSING( x )
-#endif
-
-#ifndef configUSE_QUEUE_SETS
-	#define configUSE_QUEUE_SETS 0
-#endif
-
-#ifndef portTASK_USES_FLOATING_POINT
-	#define portTASK_USES_FLOATING_POINT()
-#endif
-
-#ifndef portTASK_CALLS_SECURE_FUNCTIONS
-	#define portTASK_CALLS_SECURE_FUNCTIONS()
-#endif
-
-#ifndef configUSE_TIME_SLICING
-	#define configUSE_TIME_SLICING 1
-#endif
-
-#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
-	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
-#endif
-
-#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
-	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
-#endif
-
-#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
-	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
-#endif
-
-#ifndef configUSE_TRACE_FACILITY
-	#define configUSE_TRACE_FACILITY 0
-#endif
-
-#ifndef mtCOVERAGE_TEST_MARKER
-	#define mtCOVERAGE_TEST_MARKER()
-#endif
-
-#ifndef mtCOVERAGE_TEST_DELAY
-	#define mtCOVERAGE_TEST_DELAY()
-#endif
-
-#ifndef portASSERT_IF_IN_ISR
-	#define portASSERT_IF_IN_ISR()
-#endif
-
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
-#endif
-
-#ifndef configAPPLICATION_ALLOCATED_HEAP
-	#define configAPPLICATION_ALLOCATED_HEAP 0
-#endif
-
-#ifndef configUSE_TASK_NOTIFICATIONS
-	#define configUSE_TASK_NOTIFICATIONS 1
-#endif
-
-#ifndef portTICK_TYPE_IS_ATOMIC
-	#define portTICK_TYPE_IS_ATOMIC 0
-#endif
-
-#ifndef configSUPPORT_STATIC_ALLOCATION
-	/* Defaults to 0 for backward compatibility. */
-	#define configSUPPORT_STATIC_ALLOCATION 0
-#endif
-
-#ifndef configSUPPORT_DYNAMIC_ALLOCATION
-	/* Defaults to 1 for backward compatibility. */
-	#define configSUPPORT_DYNAMIC_ALLOCATION 1
-#endif
-
-#ifndef configSTACK_DEPTH_TYPE
-	/* Defaults to uint16_t for backward compatibility, but can be overridden
-	in FreeRTOSConfig.h if uint16_t is too restrictive. */
-	#define configSTACK_DEPTH_TYPE uint16_t
-#endif
-
-/* Sanity check the configuration. */
-#if( configUSE_TICKLESS_IDLE != 0 )
-	#if( INCLUDE_vTaskSuspend != 1 )
-		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
-	#endif /* INCLUDE_vTaskSuspend */
-#endif /* configUSE_TICKLESS_IDLE */
-
-#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
-	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
-#endif
-
-#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
-	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
-#endif
-
-#ifndef configINITIAL_TICK_COUNT
-	#define configINITIAL_TICK_COUNT 0
-#endif
-
-#if( portTICK_TYPE_IS_ATOMIC == 0 )
-	/* Either variables of tick type cannot be read atomically, or
-	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
-	the tick count is returned to the standard critical section macros. */
-	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
-	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
-	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
-	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
-#else
-	/* The tick type can be read atomically, so critical sections used when the
-	tick count is returned can be defined away. */
-	#define portTICK_TYPE_ENTER_CRITICAL()
-	#define portTICK_TYPE_EXIT_CRITICAL()
-	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
-	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
-#endif
-
-/* Definitions to allow backward compatibility with FreeRTOS versions prior to
-V8 if desired. */
-#ifndef configENABLE_BACKWARD_COMPATIBILITY
-	#define configENABLE_BACKWARD_COMPATIBILITY 1
-#endif
-
-#ifndef configPRINTF
-	/* configPRINTF() was not defined, so define it away to nothing.  To use
-	configPRINTF() then define it as follows (where MyPrintFunction() is
-	provided by the application writer):
-
-	void MyPrintFunction(const char *pcFormat, ... );
-	#define configPRINTF( X )   MyPrintFunction X
-
-	Then call like a standard printf() function, but placing brackets around
-	all parameters so they are passed as a single parameter.  For example:
-	configPRINTF( ("Value = %d", MyVariable) ); */
-	#define configPRINTF( X )
-#endif
-
-#ifndef configMAX
-	/* The application writer has not provided their own MAX macro, so define
-	the following generic implementation. */
-	#define configMAX( a, b ) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )
-#endif
-
-#ifndef configMIN
-	/* The application writer has not provided their own MAX macro, so define
-	the following generic implementation. */
-	#define configMIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
-#endif
-
-#if configENABLE_BACKWARD_COMPATIBILITY == 1
-	#define eTaskStateGet eTaskGetState
-	#define portTickType TickType_t
-	#define xTaskHandle TaskHandle_t
-	#define xQueueHandle QueueHandle_t
-	#define xSemaphoreHandle SemaphoreHandle_t
-	#define xQueueSetHandle QueueSetHandle_t
-	#define xQueueSetMemberHandle QueueSetMemberHandle_t
-	#define xTimeOutType TimeOut_t
-	#define xMemoryRegion MemoryRegion_t
-	#define xTaskParameters TaskParameters_t
-	#define xTaskStatusType	TaskStatus_t
-	#define xTimerHandle TimerHandle_t
-	#define xCoRoutineHandle CoRoutineHandle_t
-	#define pdTASK_HOOK_CODE TaskHookFunction_t
-	#define portTICK_RATE_MS portTICK_PERIOD_MS
-	#define pcTaskGetTaskName pcTaskGetName
-	#define pcTimerGetTimerName pcTimerGetName
-	#define pcQueueGetQueueName pcQueueGetName
-	#define vTaskGetTaskInfo vTaskGetInfo
-
-	/* Backward compatibility within the scheduler code only - these definitions
-	are not really required but are included for completeness. */
-	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
-	#define pdTASK_CODE TaskFunction_t
-	#define xListItem ListItem_t
-	#define xList List_t
-#endif /* configENABLE_BACKWARD_COMPATIBILITY */
-
-#if( configUSE_ALTERNATIVE_API != 0 )
-	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
-#endif
-
-/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
-if floating point hardware is otherwise supported by the FreeRTOS port in use.
-This constant is not supported by all FreeRTOS ports that include floating
-point support. */
-#ifndef configUSE_TASK_FPU_SUPPORT
-	#define configUSE_TASK_FPU_SUPPORT 1
-#endif
-
-/*
- * In line with software engineering best practice, FreeRTOS implements a strict
- * data hiding policy, so the real structures used by FreeRTOS to maintain the
- * state of tasks, queues, semaphores, etc. are not accessible to the application
- * code.  However, if the application writer wants to statically allocate such
- * an object then the size of the object needs to be know.  Dummy structures
- * that are guaranteed to have the same size and alignment requirements of the
- * real objects are used for this purpose.  The dummy list and list item
- * structures below are used for inclusion in such a dummy structure.
- */
-struct xSTATIC_LIST_ITEM
-{
-	TickType_t xDummy1;
-	void *pvDummy2[ 4 ];
-};
-typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
-
-/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
-struct xSTATIC_MINI_LIST_ITEM
-{
-	TickType_t xDummy1;
-	void *pvDummy2[ 2 ];
-};
-typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
-
-/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
-typedef struct xSTATIC_LIST
-{
-	UBaseType_t uxDummy1;
-	void *pvDummy2;
-	StaticMiniListItem_t xDummy3;
-} StaticList_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the Task structure used internally by
- * FreeRTOS is not accessible to application code.  However, if the application
- * writer wants to statically allocate the memory required to create a task then
- * the size of the task object needs to be know.  The StaticTask_t structure
- * below is provided for this purpose.  Its sizes and alignment requirements are
- * guaranteed to match those of the genuine structure, no matter which
- * architecture is being used, and no matter how the values in FreeRTOSConfig.h
- * are set.  Its contents are somewhat obfuscated in the hope users will
- * recognise that it would be unwise to make direct use of the structure members.
- */
-typedef struct xSTATIC_TCB
-{
-	void				*pxDummy1;
-	#if ( portUSING_MPU_WRAPPERS == 1 )
-		xMPU_SETTINGS	xDummy2;
-	#endif
-	StaticListItem_t	xDummy3[ 2 ];
-	UBaseType_t			uxDummy5;
-	void				*pxDummy6;
-	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
-	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
-		void			*pxDummy8;
-	#endif
-	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
-		UBaseType_t		uxDummy9;
-	#endif
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t		uxDummy10[ 2 ];
-	#endif
-	#if ( configUSE_MUTEXES == 1 )
-		UBaseType_t		uxDummy12[ 2 ];
-	#endif
-	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
-		void			*pxDummy14;
-	#endif
-	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
-		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
-	#endif
-	#if ( configGENERATE_RUN_TIME_STATS == 1 )
-		uint32_t		ulDummy16;
-	#endif
-	#if ( configUSE_NEWLIB_REENTRANT == 1 )
-		struct	_reent	xDummy17;
-	#endif
-	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
-		uint32_t 		ulDummy18;
-		uint8_t 		ucDummy19;
-	#endif
-	#if( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
-		uint8_t			uxDummy20;
-	#endif
-
-	#if( INCLUDE_xTaskAbortDelay == 1 )
-		uint8_t ucDummy21;
-	#endif
-
-} StaticTask_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the Queue structure used internally by
- * FreeRTOS is not accessible to application code.  However, if the application
- * writer wants to statically allocate the memory required to create a queue
- * then the size of the queue object needs to be know.  The StaticQueue_t
- * structure below is provided for this purpose.  Its sizes and alignment
- * requirements are guaranteed to match those of the genuine structure, no
- * matter which architecture is being used, and no matter how the values in
- * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
- * users will recognise that it would be unwise to make direct use of the
- * structure members.
- */
-typedef struct xSTATIC_QUEUE
-{
-	void *pvDummy1[ 3 ];
-
-	union
-	{
-		void *pvDummy2;
-		UBaseType_t uxDummy2;
-	} u;
-
-	StaticList_t xDummy3[ 2 ];
-	UBaseType_t uxDummy4[ 3 ];
-	uint8_t ucDummy5[ 2 ];
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-		uint8_t ucDummy6;
-	#endif
-
-	#if ( configUSE_QUEUE_SETS == 1 )
-		void *pvDummy7;
-	#endif
-
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy8;
-		uint8_t ucDummy9;
-	#endif
-
-} StaticQueue_t;
-typedef StaticQueue_t StaticSemaphore_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the event group structure used
- * internally by FreeRTOS is not accessible to application code.  However, if
- * the application writer wants to statically allocate the memory required to
- * create an event group then the size of the event group object needs to be
- * know.  The StaticEventGroup_t structure below is provided for this purpose.
- * Its sizes and alignment requirements are guaranteed to match those of the
- * genuine structure, no matter which architecture is being used, and no matter
- * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
- * obfuscated in the hope users will recognise that it would be unwise to make
- * direct use of the structure members.
- */
-typedef struct xSTATIC_EVENT_GROUP
-{
-	TickType_t xDummy1;
-	StaticList_t xDummy2;
-
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy3;
-	#endif
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-			uint8_t ucDummy4;
-	#endif
-
-} StaticEventGroup_t;
-
-/*
- * In line with software engineering best practice, especially when supplying a
- * library that is likely to change in future versions, FreeRTOS implements a
- * strict data hiding policy.  This means the software timer structure used
- * internally by FreeRTOS is not accessible to application code.  However, if
- * the application writer wants to statically allocate the memory required to
- * create a software timer then the size of the queue object needs to be know.
- * The StaticTimer_t structure below is provided for this purpose.  Its sizes
- * and alignment requirements are guaranteed to match those of the genuine
- * structure, no matter which architecture is being used, and no matter how the
- * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
- * the hope users will recognise that it would be unwise to make direct use of
- * the structure members.
- */
-typedef struct xSTATIC_TIMER
-{
-	void				*pvDummy1;
-	StaticListItem_t	xDummy2;
-	TickType_t			xDummy3;
-	UBaseType_t			uxDummy4;
-	void 				*pvDummy5[ 2 ];
-	#if( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t		uxDummy6;
-	#endif
-
-	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
-		uint8_t 		ucDummy7;
-	#endif
-
-} StaticTimer_t;
-
-/*
-* In line with software engineering best practice, especially when supplying a
-* library that is likely to change in future versions, FreeRTOS implements a
-* strict data hiding policy.  This means the stream buffer structure used
-* internally by FreeRTOS is not accessible to application code.  However, if
-* the application writer wants to statically allocate the memory required to
-* create a stream buffer then the size of the stream buffer object needs to be
-* know.  The StaticStreamBuffer_t structure below is provided for this purpose.
-* Its size and alignment requirements are guaranteed to match those of the
-* genuine structure, no matter which architecture is being used, and no matter
-* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
-* obfuscated in the hope users will recognise that it would be unwise to make
-* direct use of the structure members.
-*/
-typedef struct xSTATIC_STREAM_BUFFER
-{
-	size_t uxDummy1[ 4 ];
-	void * pvDummy2[ 3 ];
-	uint8_t ucDummy3;
-	#if ( configUSE_TRACE_FACILITY == 1 )
-		UBaseType_t uxDummy4;
-	#endif
-} StaticStreamBuffer_t;
-
-/* Message buffers are built on stream buffers. */
-typedef StaticStreamBuffer_t StaticMessageBuffer_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* INC_FREERTOS_H */
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef INC_FREERTOS_H
+#define INC_FREERTOS_H
+
+/*
+ * Include the generic headers required for the FreeRTOS port being used.
+ */
+#include <stddef.h>
+
+/*
+ * If stdint.h cannot be located then:
+ *   + If using GCC ensure the -nostdint options is *not* being used.
+ *   + Ensure the project's include path includes the directory in which your
+ *     compiler stores stdint.h.
+ *   + Set any compiler options necessary for it to support C99, as technically
+ *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
+ *     other way).
+ *   + The FreeRTOS download includes a simple stdint.h definition that can be
+ *     used in cases where none is provided by the compiler.  The files only
+ *     contains the typedefs required to build FreeRTOS.  Read the instructions
+ *     in FreeRTOS/source/stdint.readme for more information.
+ */
+#include <stdint.h> /* READ COMMENT ABOVE. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Application specific configuration options. */
+#include "FreeRTOSConfig.h"
+
+/* Basic FreeRTOS definitions. */
+#include "projdefs.h"
+
+/* Definitions specific to the port being used. */
+#include "portable.h"
+
+/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
+#ifndef configUSE_NEWLIB_REENTRANT
+	#define configUSE_NEWLIB_REENTRANT 0
+#endif
+
+/* Required if struct _reent is used. */
+#if ( configUSE_NEWLIB_REENTRANT == 1 )
+	#include <reent.h>
+#endif
+/*
+ * Check all the required application specific macros have been defined.
+ * These macros are application specific and (as downloaded) are defined
+ * within FreeRTOSConfig.h.
+ */
+
+#ifndef configMINIMAL_STACK_SIZE
+	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
+#endif
+
+#ifndef configMAX_PRIORITIES
+	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#if configMAX_PRIORITIES < 1
+	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
+#endif
+
+#ifndef configUSE_PREEMPTION
+	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_IDLE_HOOK
+	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_TICK_HOOK
+	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_16_BIT_TICKS
+	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
+#endif
+
+#ifndef configUSE_CO_ROUTINES
+	#define configUSE_CO_ROUTINES 0
+#endif
+
+#ifndef INCLUDE_vTaskPrioritySet
+	#define INCLUDE_vTaskPrioritySet 0
+#endif
+
+#ifndef INCLUDE_uxTaskPriorityGet
+	#define INCLUDE_uxTaskPriorityGet 0
+#endif
+
+#ifndef INCLUDE_vTaskDelete
+	#define INCLUDE_vTaskDelete 0
+#endif
+
+#ifndef INCLUDE_vTaskSuspend
+	#define INCLUDE_vTaskSuspend 0
+#endif
+
+#ifndef INCLUDE_vTaskDelayUntil
+	#define INCLUDE_vTaskDelayUntil 0
+#endif
+
+#ifndef INCLUDE_vTaskDelay
+	#define INCLUDE_vTaskDelay 0
+#endif
+
+#ifndef INCLUDE_xTaskGetIdleTaskHandle
+	#define INCLUDE_xTaskGetIdleTaskHandle 0
+#endif
+
+#ifndef INCLUDE_xTaskAbortDelay
+	#define INCLUDE_xTaskAbortDelay 0
+#endif
+
+#ifndef INCLUDE_xQueueGetMutexHolder
+	#define INCLUDE_xQueueGetMutexHolder 0
+#endif
+
+#ifndef INCLUDE_xSemaphoreGetMutexHolder
+	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
+#endif
+
+#ifndef INCLUDE_xTaskGetHandle
+	#define INCLUDE_xTaskGetHandle 0
+#endif
+
+#ifndef INCLUDE_uxTaskGetStackHighWaterMark
+	#define INCLUDE_uxTaskGetStackHighWaterMark 0
+#endif
+
+#ifndef INCLUDE_eTaskGetState
+	#define INCLUDE_eTaskGetState 0
+#endif
+
+#ifndef INCLUDE_xTaskResumeFromISR
+	#define INCLUDE_xTaskResumeFromISR 1
+#endif
+
+#ifndef INCLUDE_xTimerPendFunctionCall
+	#define INCLUDE_xTimerPendFunctionCall 0
+#endif
+
+#ifndef INCLUDE_xTaskGetSchedulerState
+	#define INCLUDE_xTaskGetSchedulerState 0
+#endif
+
+#ifndef INCLUDE_xTaskGetCurrentTaskHandle
+	#define INCLUDE_xTaskGetCurrentTaskHandle 0
+#endif
+
+#if configUSE_CO_ROUTINES != 0
+	#ifndef configMAX_CO_ROUTINE_PRIORITIES
+		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
+	#endif
+#endif
+
+#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
+	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
+#endif
+
+#ifndef configUSE_APPLICATION_TASK_TAG
+	#define configUSE_APPLICATION_TASK_TAG 0
+#endif
+
+#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
+	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
+#endif
+
+#ifndef configUSE_RECURSIVE_MUTEXES
+	#define configUSE_RECURSIVE_MUTEXES 0
+#endif
+
+#ifndef configUSE_MUTEXES
+	#define configUSE_MUTEXES 0
+#endif
+
+#ifndef configUSE_TIMERS
+	#define configUSE_TIMERS 0
+#endif
+
+#ifndef configUSE_COUNTING_SEMAPHORES
+	#define configUSE_COUNTING_SEMAPHORES 0
+#endif
+
+#ifndef configUSE_ALTERNATIVE_API
+	#define configUSE_ALTERNATIVE_API 0
+#endif
+
+#ifndef portCRITICAL_NESTING_IN_TCB
+	#define portCRITICAL_NESTING_IN_TCB 0
+#endif
+
+#ifndef configMAX_TASK_NAME_LEN
+	#define configMAX_TASK_NAME_LEN 16
+#endif
+
+#ifndef configIDLE_SHOULD_YIELD
+	#define configIDLE_SHOULD_YIELD		1
+#endif
+
+#if configMAX_TASK_NAME_LEN < 1
+	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
+#endif
+
+#ifndef configASSERT
+	#define configASSERT( x )
+	#define configASSERT_DEFINED 0
+#else
+	#define configASSERT_DEFINED 1
+#endif
+
+/* The timers module relies on xTaskGetSchedulerState(). */
+#if configUSE_TIMERS == 1
+
+	#ifndef configTIMER_TASK_PRIORITY
+		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
+	#endif /* configTIMER_TASK_PRIORITY */
+
+	#ifndef configTIMER_QUEUE_LENGTH
+		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
+	#endif /* configTIMER_QUEUE_LENGTH */
+
+	#ifndef configTIMER_TASK_STACK_DEPTH
+		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
+	#endif /* configTIMER_TASK_STACK_DEPTH */
+
+#endif /* configUSE_TIMERS */
+
+#ifndef portSET_INTERRUPT_MASK_FROM_ISR
+	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
+#endif
+
+#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
+	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
+#endif
+
+#ifndef portCLEAN_UP_TCB
+	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
+#endif
+
+#ifndef portPRE_TASK_DELETE_HOOK
+	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
+#endif
+
+#ifndef portSETUP_TCB
+	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
+#endif
+
+#ifndef configQUEUE_REGISTRY_SIZE
+	#define configQUEUE_REGISTRY_SIZE 0U
+#endif
+
+#if ( configQUEUE_REGISTRY_SIZE < 1 )
+	#define vQueueAddToRegistry( xQueue, pcName )
+	#define vQueueUnregisterQueue( xQueue )
+	#define pcQueueGetName( xQueue )
+#endif
+
+#ifndef portPOINTER_SIZE_TYPE
+	#define portPOINTER_SIZE_TYPE uint32_t
+#endif
+
+/* Remove any unused trace macros. */
+#ifndef traceSTART
+	/* Used to perform any necessary initialisation - for example, open a file
+	into which trace is to be written. */
+	#define traceSTART()
+#endif
+
+#ifndef traceEND
+	/* Use to close a trace, for example close a file into which trace has been
+	written. */
+	#define traceEND()
+#endif
+
+#ifndef traceTASK_SWITCHED_IN
+	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
+	to the task control block of the selected task. */
+	#define traceTASK_SWITCHED_IN()
+#endif
+
+#ifndef traceINCREASE_TICK_COUNT
+	/* Called before stepping the tick count after waking from tickless idle
+	sleep. */
+	#define traceINCREASE_TICK_COUNT( x )
+#endif
+
+#ifndef traceLOW_POWER_IDLE_BEGIN
+	/* Called immediately before entering tickless idle. */
+	#define traceLOW_POWER_IDLE_BEGIN()
+#endif
+
+#ifndef	traceLOW_POWER_IDLE_END
+	/* Called when returning to the Idle task after a tickless idle. */
+	#define traceLOW_POWER_IDLE_END()
+#endif
+
+#ifndef traceTASK_SWITCHED_OUT
+	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
+	to the task control block of the task being switched out. */
+	#define traceTASK_SWITCHED_OUT()
+#endif
+
+#ifndef traceTASK_PRIORITY_INHERIT
+	/* Called when a task attempts to take a mutex that is already held by a
+	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
+	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
+	will inherit (the priority of the task that is attempting to obtain the
+	muted. */
+	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
+#endif
+
+#ifndef traceTASK_PRIORITY_DISINHERIT
+	/* Called when a task releases a mutex, the holding of which had resulted in
+	the task inheriting the priority of a higher priority task.
+	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
+	mutex.  uxOriginalPriority is the task's configured (base) priority. */
+	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
+	/* Task is about to block because it cannot read from a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the read. */
+	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_PEEK
+	/* Task is about to block because it cannot read from a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the read. */
+	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
+#endif
+
+#ifndef traceBLOCKING_ON_QUEUE_SEND
+	/* Task is about to block because it cannot write to a
+	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
+	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
+	task that attempted the write. */
+	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
+#endif
+
+#ifndef configCHECK_FOR_STACK_OVERFLOW
+	#define configCHECK_FOR_STACK_OVERFLOW 0
+#endif
+
+#ifndef configRECORD_STACK_HIGH_ADDRESS
+	#define configRECORD_STACK_HIGH_ADDRESS 0
+#endif
+
+#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
+	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
+#endif
+
+/* The following event macros are embedded in the kernel API calls. */
+
+#ifndef traceMOVED_TASK_TO_READY_STATE
+	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
+#endif
+
+#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
+	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
+#endif
+
+#ifndef traceQUEUE_CREATE
+	#define traceQUEUE_CREATE( pxNewQueue )
+#endif
+
+#ifndef traceQUEUE_CREATE_FAILED
+	#define traceQUEUE_CREATE_FAILED( ucQueueType )
+#endif
+
+#ifndef traceCREATE_MUTEX
+	#define traceCREATE_MUTEX( pxNewQueue )
+#endif
+
+#ifndef traceCREATE_MUTEX_FAILED
+	#define traceCREATE_MUTEX_FAILED()
+#endif
+
+#ifndef traceGIVE_MUTEX_RECURSIVE
+	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
+#endif
+
+#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
+	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
+#endif
+
+#ifndef traceTAKE_MUTEX_RECURSIVE
+	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
+#endif
+
+#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
+	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
+#endif
+
+#ifndef traceCREATE_COUNTING_SEMAPHORE
+	#define traceCREATE_COUNTING_SEMAPHORE()
+#endif
+
+#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
+	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
+#endif
+
+#ifndef traceQUEUE_SEND
+	#define traceQUEUE_SEND( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FAILED
+	#define traceQUEUE_SEND_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE
+	#define traceQUEUE_RECEIVE( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK
+	#define traceQUEUE_PEEK( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FAILED
+	#define traceQUEUE_PEEK_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FROM_ISR
+	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FAILED
+	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FROM_ISR
+	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
+	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FROM_ISR
+	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
+#endif
+
+#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
+	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
+	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
+#endif
+
+#ifndef traceQUEUE_DELETE
+	#define traceQUEUE_DELETE( pxQueue )
+#endif
+
+#ifndef traceTASK_CREATE
+	#define traceTASK_CREATE( pxNewTCB )
+#endif
+
+#ifndef traceTASK_CREATE_FAILED
+	#define traceTASK_CREATE_FAILED()
+#endif
+
+#ifndef traceTASK_DELETE
+	#define traceTASK_DELETE( pxTaskToDelete )
+#endif
+
+#ifndef traceTASK_DELAY_UNTIL
+	#define traceTASK_DELAY_UNTIL( x )
+#endif
+
+#ifndef traceTASK_DELAY
+	#define traceTASK_DELAY()
+#endif
+
+#ifndef traceTASK_PRIORITY_SET
+	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
+#endif
+
+#ifndef traceTASK_SUSPEND
+	#define traceTASK_SUSPEND( pxTaskToSuspend )
+#endif
+
+#ifndef traceTASK_RESUME
+	#define traceTASK_RESUME( pxTaskToResume )
+#endif
+
+#ifndef traceTASK_RESUME_FROM_ISR
+	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
+#endif
+
+#ifndef traceTASK_INCREMENT_TICK
+	#define traceTASK_INCREMENT_TICK( xTickCount )
+#endif
+
+#ifndef traceTIMER_CREATE
+	#define traceTIMER_CREATE( pxNewTimer )
+#endif
+
+#ifndef traceTIMER_CREATE_FAILED
+	#define traceTIMER_CREATE_FAILED()
+#endif
+
+#ifndef traceTIMER_COMMAND_SEND
+	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
+#endif
+
+#ifndef traceTIMER_EXPIRED
+	#define traceTIMER_EXPIRED( pxTimer )
+#endif
+
+#ifndef traceTIMER_COMMAND_RECEIVED
+	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
+#endif
+
+#ifndef traceMALLOC
+    #define traceMALLOC( pvAddress, uiSize )
+#endif
+
+#ifndef traceFREE
+    #define traceFREE( pvAddress, uiSize )
+#endif
+
+#ifndef traceEVENT_GROUP_CREATE
+	#define traceEVENT_GROUP_CREATE( xEventGroup )
+#endif
+
+#ifndef traceEVENT_GROUP_CREATE_FAILED
+	#define traceEVENT_GROUP_CREATE_FAILED()
+#endif
+
+#ifndef traceEVENT_GROUP_SYNC_BLOCK
+	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
+#endif
+
+#ifndef traceEVENT_GROUP_SYNC_END
+	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
+#endif
+
+#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
+	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
+#endif
+
+#ifndef traceEVENT_GROUP_WAIT_BITS_END
+	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
+#endif
+
+#ifndef traceEVENT_GROUP_CLEAR_BITS
+	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
+#endif
+
+#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
+	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
+#endif
+
+#ifndef traceEVENT_GROUP_SET_BITS
+	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
+#endif
+
+#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
+	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
+#endif
+
+#ifndef traceEVENT_GROUP_DELETE
+	#define traceEVENT_GROUP_DELETE( xEventGroup )
+#endif
+
+#ifndef tracePEND_FUNC_CALL
+	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
+#endif
+
+#ifndef tracePEND_FUNC_CALL_FROM_ISR
+	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
+#endif
+
+#ifndef traceQUEUE_REGISTRY_ADD
+	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
+#endif
+
+#ifndef traceTASK_NOTIFY_TAKE_BLOCK
+	#define traceTASK_NOTIFY_TAKE_BLOCK()
+#endif
+
+#ifndef traceTASK_NOTIFY_TAKE
+	#define traceTASK_NOTIFY_TAKE()
+#endif
+
+#ifndef traceTASK_NOTIFY_WAIT_BLOCK
+	#define traceTASK_NOTIFY_WAIT_BLOCK()
+#endif
+
+#ifndef traceTASK_NOTIFY_WAIT
+	#define traceTASK_NOTIFY_WAIT()
+#endif
+
+#ifndef traceTASK_NOTIFY
+	#define traceTASK_NOTIFY()
+#endif
+
+#ifndef traceTASK_NOTIFY_FROM_ISR
+	#define traceTASK_NOTIFY_FROM_ISR()
+#endif
+
+#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
+	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE_FAILED
+	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
+	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_CREATE
+	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_DELETE
+	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RESET
+	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
+#endif
+
+#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
+	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND
+	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND_FAILED
+	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
+	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
+#endif
+
+#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
+	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE
+	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
+	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
+#endif
+
+#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
+	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
+#endif
+
+#ifndef configGENERATE_RUN_TIME_STATS
+	#define configGENERATE_RUN_TIME_STATS 0
+#endif
+
+#if ( configGENERATE_RUN_TIME_STATS == 1 )
+
+	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
+		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
+	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
+
+	#ifndef portGET_RUN_TIME_COUNTER_VALUE
+		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
+			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
+		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
+	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
+
+#endif /* configGENERATE_RUN_TIME_STATS */
+
+#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
+	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
+#endif
+
+#ifndef configUSE_MALLOC_FAILED_HOOK
+	#define configUSE_MALLOC_FAILED_HOOK 0
+#endif
+
+#ifndef portPRIVILEGE_BIT
+	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
+#endif
+
+#ifndef portYIELD_WITHIN_API
+	#define portYIELD_WITHIN_API portYIELD
+#endif
+
+#ifndef portSUPPRESS_TICKS_AND_SLEEP
+	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
+#endif
+
+#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
+	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
+#endif
+
+#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
+	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
+#endif
+
+#ifndef configUSE_TICKLESS_IDLE
+	#define configUSE_TICKLESS_IDLE 0
+#endif
+
+#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
+	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configPRE_SLEEP_PROCESSING
+	#define configPRE_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configPOST_SLEEP_PROCESSING
+	#define configPOST_SLEEP_PROCESSING( x )
+#endif
+
+#ifndef configUSE_QUEUE_SETS
+	#define configUSE_QUEUE_SETS 0
+#endif
+
+#ifndef portTASK_USES_FLOATING_POINT
+	#define portTASK_USES_FLOATING_POINT()
+#endif
+
+#ifndef portTASK_CALLS_SECURE_FUNCTIONS
+	#define portTASK_CALLS_SECURE_FUNCTIONS()
+#endif
+
+#ifndef configUSE_TIME_SLICING
+	#define configUSE_TIME_SLICING 1
+#endif
+
+#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
+	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
+#endif
+
+#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
+	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
+#endif
+
+#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
+	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
+#endif
+
+#ifndef configUSE_TRACE_FACILITY
+	#define configUSE_TRACE_FACILITY 0
+#endif
+
+#ifndef mtCOVERAGE_TEST_MARKER
+	#define mtCOVERAGE_TEST_MARKER()
+#endif
+
+#ifndef mtCOVERAGE_TEST_DELAY
+	#define mtCOVERAGE_TEST_DELAY()
+#endif
+
+#ifndef portASSERT_IF_IN_ISR
+	#define portASSERT_IF_IN_ISR()
+#endif
+
+#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
+	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
+#endif
+
+#ifndef configAPPLICATION_ALLOCATED_HEAP
+	#define configAPPLICATION_ALLOCATED_HEAP 0
+#endif
+
+#ifndef configUSE_TASK_NOTIFICATIONS
+	#define configUSE_TASK_NOTIFICATIONS 1
+#endif
+
+#ifndef portTICK_TYPE_IS_ATOMIC
+	#define portTICK_TYPE_IS_ATOMIC 0
+#endif
+
+#ifndef configSUPPORT_STATIC_ALLOCATION
+	/* Defaults to 0 for backward compatibility. */
+	#define configSUPPORT_STATIC_ALLOCATION 0
+#endif
+
+#ifndef configSUPPORT_DYNAMIC_ALLOCATION
+	/* Defaults to 1 for backward compatibility. */
+	#define configSUPPORT_DYNAMIC_ALLOCATION 1
+#endif
+
+#ifndef configSTACK_DEPTH_TYPE
+	/* Defaults to uint16_t for backward compatibility, but can be overridden
+	in FreeRTOSConfig.h if uint16_t is too restrictive. */
+	#define configSTACK_DEPTH_TYPE uint16_t
+#endif
+
+/* Sanity check the configuration. */
+#if( configUSE_TICKLESS_IDLE != 0 )
+	#if( INCLUDE_vTaskSuspend != 1 )
+		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
+	#endif /* INCLUDE_vTaskSuspend */
+#endif /* configUSE_TICKLESS_IDLE */
+
+#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
+	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
+#endif
+
+#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
+	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
+#endif
+
+#ifndef configINITIAL_TICK_COUNT
+	#define configINITIAL_TICK_COUNT 0
+#endif
+
+#if( portTICK_TYPE_IS_ATOMIC == 0 )
+	/* Either variables of tick type cannot be read atomically, or
+	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
+	the tick count is returned to the standard critical section macros. */
+	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
+	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
+	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
+	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
+#else
+	/* The tick type can be read atomically, so critical sections used when the
+	tick count is returned can be defined away. */
+	#define portTICK_TYPE_ENTER_CRITICAL()
+	#define portTICK_TYPE_EXIT_CRITICAL()
+	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
+	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
+#endif
+
+/* Definitions to allow backward compatibility with FreeRTOS versions prior to
+V8 if desired. */
+#ifndef configENABLE_BACKWARD_COMPATIBILITY
+	#define configENABLE_BACKWARD_COMPATIBILITY 1
+#endif
+
+#ifndef configPRINTF
+	/* configPRINTF() was not defined, so define it away to nothing.  To use
+	configPRINTF() then define it as follows (where MyPrintFunction() is
+	provided by the application writer):
+
+	void MyPrintFunction(const char *pcFormat, ... );
+	#define configPRINTF( X )   MyPrintFunction X
+
+	Then call like a standard printf() function, but placing brackets around
+	all parameters so they are passed as a single parameter.  For example:
+	configPRINTF( ("Value = %d", MyVariable) ); */
+	#define configPRINTF( X )
+#endif
+
+#ifndef configMAX
+	/* The application writer has not provided their own MAX macro, so define
+	the following generic implementation. */
+	#define configMAX( a, b ) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )
+#endif
+
+#ifndef configMIN
+	/* The application writer has not provided their own MAX macro, so define
+	the following generic implementation. */
+	#define configMIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
+#endif
+
+#if configENABLE_BACKWARD_COMPATIBILITY == 1
+	#define eTaskStateGet eTaskGetState
+	#define portTickType TickType_t
+	#define xTaskHandle TaskHandle_t
+	#define xQueueHandle QueueHandle_t
+	#define xSemaphoreHandle SemaphoreHandle_t
+	#define xQueueSetHandle QueueSetHandle_t
+	#define xQueueSetMemberHandle QueueSetMemberHandle_t
+	#define xTimeOutType TimeOut_t
+	#define xMemoryRegion MemoryRegion_t
+	#define xTaskParameters TaskParameters_t
+	#define xTaskStatusType	TaskStatus_t
+	#define xTimerHandle TimerHandle_t
+	#define xCoRoutineHandle CoRoutineHandle_t
+	#define pdTASK_HOOK_CODE TaskHookFunction_t
+	#define portTICK_RATE_MS portTICK_PERIOD_MS
+	#define pcTaskGetTaskName pcTaskGetName
+	#define pcTimerGetTimerName pcTimerGetName
+	#define pcQueueGetQueueName pcQueueGetName
+	#define vTaskGetTaskInfo vTaskGetInfo
+
+	/* Backward compatibility within the scheduler code only - these definitions
+	are not really required but are included for completeness. */
+	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
+	#define pdTASK_CODE TaskFunction_t
+	#define xListItem ListItem_t
+	#define xList List_t
+#endif /* configENABLE_BACKWARD_COMPATIBILITY */
+
+#if( configUSE_ALTERNATIVE_API != 0 )
+	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
+#endif
+
+/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
+if floating point hardware is otherwise supported by the FreeRTOS port in use.
+This constant is not supported by all FreeRTOS ports that include floating
+point support. */
+#ifndef configUSE_TASK_FPU_SUPPORT
+	#define configUSE_TASK_FPU_SUPPORT 1
+#endif
+
+/*
+ * In line with software engineering best practice, FreeRTOS implements a strict
+ * data hiding policy, so the real structures used by FreeRTOS to maintain the
+ * state of tasks, queues, semaphores, etc. are not accessible to the application
+ * code.  However, if the application writer wants to statically allocate such
+ * an object then the size of the object needs to be know.  Dummy structures
+ * that are guaranteed to have the same size and alignment requirements of the
+ * real objects are used for this purpose.  The dummy list and list item
+ * structures below are used for inclusion in such a dummy structure.
+ */
+struct xSTATIC_LIST_ITEM
+{
+	TickType_t xDummy1;
+	void *pvDummy2[ 4 ];
+};
+typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
+
+/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
+struct xSTATIC_MINI_LIST_ITEM
+{
+	TickType_t xDummy1;
+	void *pvDummy2[ 2 ];
+};
+typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
+
+/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
+typedef struct xSTATIC_LIST
+{
+	UBaseType_t uxDummy1;
+	void *pvDummy2;
+	StaticMiniListItem_t xDummy3;
+} StaticList_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the Task structure used internally by
+ * FreeRTOS is not accessible to application code.  However, if the application
+ * writer wants to statically allocate the memory required to create a task then
+ * the size of the task object needs to be know.  The StaticTask_t structure
+ * below is provided for this purpose.  Its sizes and alignment requirements are
+ * guaranteed to match those of the genuine structure, no matter which
+ * architecture is being used, and no matter how the values in FreeRTOSConfig.h
+ * are set.  Its contents are somewhat obfuscated in the hope users will
+ * recognise that it would be unwise to make direct use of the structure members.
+ */
+typedef struct xSTATIC_TCB
+{
+	void				*pxDummy1;
+	#if ( portUSING_MPU_WRAPPERS == 1 )
+		xMPU_SETTINGS	xDummy2;
+	#endif
+	StaticListItem_t	xDummy3[ 2 ];
+	UBaseType_t			uxDummy5;
+	void				*pxDummy6;
+	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
+	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
+		void			*pxDummy8;
+	#endif
+	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
+		UBaseType_t		uxDummy9;
+	#endif
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t		uxDummy10[ 2 ];
+	#endif
+	#if ( configUSE_MUTEXES == 1 )
+		UBaseType_t		uxDummy12[ 2 ];
+	#endif
+	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
+		void			*pxDummy14;
+	#endif
+	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
+		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
+	#endif
+	#if ( configGENERATE_RUN_TIME_STATS == 1 )
+		uint32_t		ulDummy16;
+	#endif
+	#if ( configUSE_NEWLIB_REENTRANT == 1 )
+		struct	_reent	xDummy17;
+	#endif
+	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
+		uint32_t 		ulDummy18;
+		uint8_t 		ucDummy19;
+	#endif
+	#if( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
+		uint8_t			uxDummy20;
+	#endif
+
+	#if( INCLUDE_xTaskAbortDelay == 1 )
+		uint8_t ucDummy21;
+	#endif
+
+} StaticTask_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the Queue structure used internally by
+ * FreeRTOS is not accessible to application code.  However, if the application
+ * writer wants to statically allocate the memory required to create a queue
+ * then the size of the queue object needs to be know.  The StaticQueue_t
+ * structure below is provided for this purpose.  Its sizes and alignment
+ * requirements are guaranteed to match those of the genuine structure, no
+ * matter which architecture is being used, and no matter how the values in
+ * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
+ * users will recognise that it would be unwise to make direct use of the
+ * structure members.
+ */
+typedef struct xSTATIC_QUEUE
+{
+	void *pvDummy1[ 3 ];
+
+	union
+	{
+		void *pvDummy2;
+		UBaseType_t uxDummy2;
+	} u;
+
+	StaticList_t xDummy3[ 2 ];
+	UBaseType_t uxDummy4[ 3 ];
+	uint8_t ucDummy5[ 2 ];
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t ucDummy6;
+	#endif
+
+	#if ( configUSE_QUEUE_SETS == 1 )
+		void *pvDummy7;
+	#endif
+
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy8;
+		uint8_t ucDummy9;
+	#endif
+
+} StaticQueue_t;
+typedef StaticQueue_t StaticSemaphore_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the event group structure used
+ * internally by FreeRTOS is not accessible to application code.  However, if
+ * the application writer wants to statically allocate the memory required to
+ * create an event group then the size of the event group object needs to be
+ * know.  The StaticEventGroup_t structure below is provided for this purpose.
+ * Its sizes and alignment requirements are guaranteed to match those of the
+ * genuine structure, no matter which architecture is being used, and no matter
+ * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
+ * obfuscated in the hope users will recognise that it would be unwise to make
+ * direct use of the structure members.
+ */
+typedef struct xSTATIC_EVENT_GROUP
+{
+	TickType_t xDummy1;
+	StaticList_t xDummy2;
+
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy3;
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+			uint8_t ucDummy4;
+	#endif
+
+} StaticEventGroup_t;
+
+/*
+ * In line with software engineering best practice, especially when supplying a
+ * library that is likely to change in future versions, FreeRTOS implements a
+ * strict data hiding policy.  This means the software timer structure used
+ * internally by FreeRTOS is not accessible to application code.  However, if
+ * the application writer wants to statically allocate the memory required to
+ * create a software timer then the size of the queue object needs to be know.
+ * The StaticTimer_t structure below is provided for this purpose.  Its sizes
+ * and alignment requirements are guaranteed to match those of the genuine
+ * structure, no matter which architecture is being used, and no matter how the
+ * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
+ * the hope users will recognise that it would be unwise to make direct use of
+ * the structure members.
+ */
+typedef struct xSTATIC_TIMER
+{
+	void				*pvDummy1;
+	StaticListItem_t	xDummy2;
+	TickType_t			xDummy3;
+	UBaseType_t			uxDummy4;
+	void 				*pvDummy5[ 2 ];
+	#if( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t		uxDummy6;
+	#endif
+
+	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
+		uint8_t 		ucDummy7;
+	#endif
+
+} StaticTimer_t;
+
+/*
+* In line with software engineering best practice, especially when supplying a
+* library that is likely to change in future versions, FreeRTOS implements a
+* strict data hiding policy.  This means the stream buffer structure used
+* internally by FreeRTOS is not accessible to application code.  However, if
+* the application writer wants to statically allocate the memory required to
+* create a stream buffer then the size of the stream buffer object needs to be
+* know.  The StaticStreamBuffer_t structure below is provided for this purpose.
+* Its size and alignment requirements are guaranteed to match those of the
+* genuine structure, no matter which architecture is being used, and no matter
+* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
+* obfuscated in the hope users will recognise that it would be unwise to make
+* direct use of the structure members.
+*/
+typedef struct xSTATIC_STREAM_BUFFER
+{
+	size_t uxDummy1[ 4 ];
+	void * pvDummy2[ 3 ];
+	uint8_t ucDummy3;
+	#if ( configUSE_TRACE_FACILITY == 1 )
+		UBaseType_t uxDummy4;
+	#endif
+} StaticStreamBuffer_t;
+
+/* Message buffers are built on stream buffers. */
+typedef StaticStreamBuffer_t StaticMessageBuffer_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INC_FREERTOS_H */
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOSConfig.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOSConfig.h
index 8b8abd9..95cb7e6 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOSConfig.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/FreeRTOSConfig.h	
@@ -1,203 +1,203 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://aws.amazon.com/freertos
- * http://www.FreeRTOS.org
- */
-
-
-#ifndef FREERTOS_CONFIG_H
-#define FREERTOS_CONFIG_H
-
-/*-----------------------------------------------------------
-* Application specific definitions.
-*
-* These definitions should be adjusted for your particular hardware and
-* application requirements.
-*
-* THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
-* FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
-*
-* See http://www.freertos.org/a00110.html.
-*----------------------------------------------------------*/
-
-/* Ensure stdint is only used by the compiler, and not the assembler. */
-#if defined( __ICCARM__ ) || defined( __ARMCC_VERSION ) 
-    #include <stdint.h>
-    extern uint32_t SystemCoreClock;
-	extern int DbgConsole_Printf( const char *fmt_s, ... );
-#endif
-
-
-#define configSUPPORT_STATIC_ALLOCATION              1
-
-#define configUSE_PREEMPTION                         1
-#define configUSE_IDLE_HOOK                          0
-#define configUSE_TICK_HOOK                          0
-#define configUSE_TICKLESS_IDLE                      0
-#define configUSE_DAEMON_TASK_STARTUP_HOOK           1
-#define configCPU_CLOCK_HZ                           ( SystemCoreClock )
-#define configTICK_RATE_HZ                           ( ( TickType_t ) 1000 )
-#define configMAX_PRIORITIES                         ( 7 )
-#define configMINIMAL_STACK_SIZE                     ( ( uint16_t ) 90 )
-#define configTOTAL_HEAP_SIZE                        ( ( size_t ) ( 85 * 1024 ) )    /* 85 Kbytes. */
-#define configMAX_TASK_NAME_LEN                      ( 16 )
-#define configUSE_TRACE_FACILITY                     1
-#define configUSE_16_BIT_TICKS                       0
-#define configIDLE_SHOULD_YIELD                      1
-#define configUSE_MUTEXES                            1
-#define configQUEUE_REGISTRY_SIZE                    8
-#define configCHECK_FOR_STACK_OVERFLOW               2
-#define configUSE_RECURSIVE_MUTEXES                  1
-#define configUSE_MALLOC_FAILED_HOOK                 1
-#define configUSE_APPLICATION_TASK_TAG               0
-#define configUSE_COUNTING_SEMAPHORES                1
-#define configGENERATE_RUN_TIME_STATS                0
-#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION    1
-#define configRECORD_STACK_HIGH_ADDRESS              1
-
-/* Co-routine definitions. */
-#define configUSE_CO_ROUTINES                        0
-#define configMAX_CO_ROUTINE_PRIORITIES              ( 2 )
-
-/* Software timer definitions. */
-#define configUSE_TIMERS                             1
-#define configTIMER_TASK_PRIORITY                    ( configMAX_PRIORITIES - 3 )
-#define configTIMER_QUEUE_LENGTH                     10
-#define configTIMER_TASK_STACK_DEPTH                 ( configMINIMAL_STACK_SIZE * 4 )
-
-/* Set the following definitions to 1 to include the API function, or zero
- * to exclude the API function. */
-#define INCLUDE_vTaskPrioritySet                     1
-#define INCLUDE_uxTaskPriorityGet                    1
-#define INCLUDE_vTaskDelete                          1
-#define INCLUDE_vTaskCleanUpResources                0
-#define INCLUDE_vTaskSuspend                         1
-#define INCLUDE_vTaskDelayUntil                      1
-#define INCLUDE_vTaskDelay                           1
-#define INCLUDE_xTaskGetSchedulerState               1
-#define INCLUDE_xTimerPendFunctionCall               1
-#define INCLUDE_xSemaphoreGetMutexHolder             1
-
-/* Cortex-M specific definitions. */
-#ifdef __NVIC_PRIO_BITS
-    /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
-    #define configPRIO_BITS    __NVIC_PRIO_BITS
-#else
-    #define configPRIO_BITS    3                                 /* 8 priority levels. */
-#endif
-
-/* The lowest interrupt priority that can be used in a call to a "set priority"
- * function. */
-#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY         0x7
-
-/* The highest interrupt priority that can be used by any interrupt service
- * routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
- * INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
- * PRIORITY THAN THIS! (higher priorities are lower numeric values. */
-#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5
-
-/* Interrupt priorities used by the kernel port layer itself.  These are generic
-* to all Cortex-M ports, and do not rely on any particular library functions. */
-#define configKERNEL_INTERRUPT_PRIORITY \
-    ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << ( 8 - configPRIO_BITS ) )
-
-/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
- * See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
-#define configMAX_SYSCALL_INTERRUPT_PRIORITY \
-    ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << ( 8 - configPRIO_BITS ) )
-
-/* Normal assert() semantics without relying on the provision of an assert.h
- * header file. */
-#define configASSERT( x )                                       \
-    if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ) {; } \
-    }
-
-/* Map the FreeRTOS printf() to the logging task printf. */
-#define configPRINTF( x )          vLoggingPrintf x
-
-/* Map the logging task's printf to the board specific output function. */
-#define configPRINT_STRING    DbgConsole_Printf
-
-/* Sets the length of the buffers into which logging messages are written - so
- * also defines the maximum length of each log message. */
-#define configLOGGING_MAX_MESSAGE_LENGTH            100
-
-/* Set to 1 to prepend each log message with a message number, the task name,
- * and a time stamp. */
-#define configLOGGING_INCLUDE_TIME_AND_TASK_NAME    1
-
-/* Demo specific macros that allow the application writer to insert code to be
- * executed immediately before the MCU's STOP low power mode is entered and exited
- * respectively.  These macros are in addition to the standard
- * configPRE_SLEEP_PROCESSING() and configPOST_SLEEP_PROCESSING() macros, which are
- * called pre and post the low power SLEEP mode being entered and exited.  These
- * macros can be used to turn turn off and on IO, clocks, the Flash etc. to obtain
- * the lowest power possible while the tick is off. */
-#if defined( __ICCARM__ ) || defined( __CC_ARM ) || defined( __GNUC__ )
-    void vMainPreStopProcessing( void );
-    void vMainPostStopProcessing( void );
-#endif /* defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__) */
-
-#define configPRE_STOP_PROCESSING     vMainPreStopProcessing
-#define configPOST_STOP_PROCESSING    vMainPostStopProcessing
-
-/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
- * standard names. */
-#define vPortSVCHandler               SVC_Handler
-#define xPortPendSVHandler            PendSV_Handler
-#define xPortSysTickHandler           SysTick_Handler
-#define vHardFault_Handler            HardFault_Handler
-
-/* IMPORTANT: This define MUST be commented when used with STM32Cube firmware,
- *            to prevent overwriting SysTick_Handler defined within STM32Cube HAL. */
-/* #define xPortSysTickHandler SysTick_Handler */
-
-/*********************************************
- * FreeRTOS specific demos
- ********************************************/
-
-/* The address of an echo server that will be used by the two demo echo client
- * tasks.
- * http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP_Echo_Clients.html
- * http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/UDP_Echo_Clients.html */
-#define configECHO_SERVER_ADDR0       192
-#define configECHO_SERVER_ADDR1       168
-#define configECHO_SERVER_ADDR2       2
-#define configECHO_SERVER_ADDR3       6
-#define configTCP_ECHO_CLIENT_PORT    7
-
-/* Prevent the assembler seeing code it doesn't understand. */
-#ifdef __ICCARM__
-	/* Logging task definitions. */
-	extern void vMainUARTPrintString( char * pcString );
-	void vLoggingPrintf( const char * pcFormat,
-						 ... );
-
-	extern int iMainRand32( void );
-
-	/* Pseudo random number generator, just used by demos so does not have to be
-	 * secure.  Do not use the standard C library rand() function as it can cause
-	 * unexpected behaviour, such as calls to malloc(). */
-	#define configRAND32()    iMainRand32()
-#endif
-
-#endif /* FREERTOS_CONFIG_H */
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://aws.amazon.com/freertos
+ * http://www.FreeRTOS.org
+ */
+
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+* Application specific definitions.
+*
+* These definitions should be adjusted for your particular hardware and
+* application requirements.
+*
+* THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+* FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
+*
+* See http://www.freertos.org/a00110.html.
+*----------------------------------------------------------*/
+
+/* Ensure stdint is only used by the compiler, and not the assembler. */
+#if defined( __ICCARM__ ) || defined( __ARMCC_VERSION ) 
+    #include <stdint.h>
+    extern uint32_t SystemCoreClock;
+	extern int DbgConsole_Printf( const char *fmt_s, ... );
+#endif
+
+
+#define configSUPPORT_STATIC_ALLOCATION              1
+
+#define configUSE_PREEMPTION                         1
+#define configUSE_IDLE_HOOK                          0
+#define configUSE_TICK_HOOK                          0
+#define configUSE_TICKLESS_IDLE                      0
+#define configUSE_DAEMON_TASK_STARTUP_HOOK           1
+#define configCPU_CLOCK_HZ                           ( SystemCoreClock )
+#define configTICK_RATE_HZ                           ( ( TickType_t ) 1000 )
+#define configMAX_PRIORITIES                         ( 7 )
+#define configMINIMAL_STACK_SIZE                     ( ( uint16_t ) 90 )
+#define configTOTAL_HEAP_SIZE                        ( ( size_t ) ( 85 * 1024 ) )    /* 85 Kbytes. */
+#define configMAX_TASK_NAME_LEN                      ( 16 )
+#define configUSE_TRACE_FACILITY                     1
+#define configUSE_16_BIT_TICKS                       0
+#define configIDLE_SHOULD_YIELD                      1
+#define configUSE_MUTEXES                            1
+#define configQUEUE_REGISTRY_SIZE                    8
+#define configCHECK_FOR_STACK_OVERFLOW               2
+#define configUSE_RECURSIVE_MUTEXES                  1
+#define configUSE_MALLOC_FAILED_HOOK                 1
+#define configUSE_APPLICATION_TASK_TAG               0
+#define configUSE_COUNTING_SEMAPHORES                1
+#define configGENERATE_RUN_TIME_STATS                0
+#define configOVERRIDE_DEFAULT_TICK_CONFIGURATION    1
+#define configRECORD_STACK_HIGH_ADDRESS              1
+
+/* Co-routine definitions. */
+#define configUSE_CO_ROUTINES                        0
+#define configMAX_CO_ROUTINE_PRIORITIES              ( 2 )
+
+/* Software timer definitions. */
+#define configUSE_TIMERS                             1
+#define configTIMER_TASK_PRIORITY                    ( configMAX_PRIORITIES - 3 )
+#define configTIMER_QUEUE_LENGTH                     10
+#define configTIMER_TASK_STACK_DEPTH                 ( configMINIMAL_STACK_SIZE * 4 )
+
+/* Set the following definitions to 1 to include the API function, or zero
+ * to exclude the API function. */
+#define INCLUDE_vTaskPrioritySet                     1
+#define INCLUDE_uxTaskPriorityGet                    1
+#define INCLUDE_vTaskDelete                          1
+#define INCLUDE_vTaskCleanUpResources                0
+#define INCLUDE_vTaskSuspend                         1
+#define INCLUDE_vTaskDelayUntil                      1
+#define INCLUDE_vTaskDelay                           1
+#define INCLUDE_xTaskGetSchedulerState               1
+#define INCLUDE_xTimerPendFunctionCall               1
+#define INCLUDE_xSemaphoreGetMutexHolder             1
+
+/* Cortex-M specific definitions. */
+#ifdef __NVIC_PRIO_BITS
+    /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
+    #define configPRIO_BITS    __NVIC_PRIO_BITS
+#else
+    #define configPRIO_BITS    3                                 /* 8 priority levels. */
+#endif
+
+/* The lowest interrupt priority that can be used in a call to a "set priority"
+ * function. */
+#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY         0x7
+
+/* The highest interrupt priority that can be used by any interrupt service
+ * routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
+ * INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
+ * PRIORITY THAN THIS! (higher priorities are lower numeric values. */
+#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5
+
+/* Interrupt priorities used by the kernel port layer itself.  These are generic
+* to all Cortex-M ports, and do not rely on any particular library functions. */
+#define configKERNEL_INTERRUPT_PRIORITY \
+    ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << ( 8 - configPRIO_BITS ) )
+
+/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
+ * See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
+#define configMAX_SYSCALL_INTERRUPT_PRIORITY \
+    ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << ( 8 - configPRIO_BITS ) )
+
+/* Normal assert() semantics without relying on the provision of an assert.h
+ * header file. */
+#define configASSERT( x )                                       \
+    if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ) {; } \
+    }
+
+/* Map the FreeRTOS printf() to the logging task printf. */
+#define configPRINTF( x )          vLoggingPrintf x
+
+/* Map the logging task's printf to the board specific output function. */
+#define configPRINT_STRING    DbgConsole_Printf
+
+/* Sets the length of the buffers into which logging messages are written - so
+ * also defines the maximum length of each log message. */
+#define configLOGGING_MAX_MESSAGE_LENGTH            100
+
+/* Set to 1 to prepend each log message with a message number, the task name,
+ * and a time stamp. */
+#define configLOGGING_INCLUDE_TIME_AND_TASK_NAME    1
+
+/* Demo specific macros that allow the application writer to insert code to be
+ * executed immediately before the MCU's STOP low power mode is entered and exited
+ * respectively.  These macros are in addition to the standard
+ * configPRE_SLEEP_PROCESSING() and configPOST_SLEEP_PROCESSING() macros, which are
+ * called pre and post the low power SLEEP mode being entered and exited.  These
+ * macros can be used to turn turn off and on IO, clocks, the Flash etc. to obtain
+ * the lowest power possible while the tick is off. */
+#if defined( __ICCARM__ ) || defined( __CC_ARM ) || defined( __GNUC__ )
+    void vMainPreStopProcessing( void );
+    void vMainPostStopProcessing( void );
+#endif /* defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__) */
+
+#define configPRE_STOP_PROCESSING     vMainPreStopProcessing
+#define configPOST_STOP_PROCESSING    vMainPostStopProcessing
+
+/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
+ * standard names. */
+#define vPortSVCHandler               SVC_Handler
+#define xPortPendSVHandler            PendSV_Handler
+#define xPortSysTickHandler           SysTick_Handler
+#define vHardFault_Handler            HardFault_Handler
+
+/* IMPORTANT: This define MUST be commented when used with STM32Cube firmware,
+ *            to prevent overwriting SysTick_Handler defined within STM32Cube HAL. */
+/* #define xPortSysTickHandler SysTick_Handler */
+
+/*********************************************
+ * FreeRTOS specific demos
+ ********************************************/
+
+/* The address of an echo server that will be used by the two demo echo client
+ * tasks.
+ * http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP_Echo_Clients.html
+ * http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/UDP_Echo_Clients.html */
+#define configECHO_SERVER_ADDR0       192
+#define configECHO_SERVER_ADDR1       168
+#define configECHO_SERVER_ADDR2       2
+#define configECHO_SERVER_ADDR3       6
+#define configTCP_ECHO_CLIENT_PORT    7
+
+/* Prevent the assembler seeing code it doesn't understand. */
+#ifdef __ICCARM__
+	/* Logging task definitions. */
+	extern void vMainUARTPrintString( char * pcString );
+	void vLoggingPrintf( const char * pcFormat,
+						 ... );
+
+	extern int iMainRand32( void );
+
+	/* Pseudo random number generator, just used by demos so does not have to be
+	 * secure.  Do not use the standard C library rand() function as it can cause
+	 * unexpected behaviour, such as calls to malloc(). */
+	#define configRAND32()    iMainRand32()
+#endif
+
+#endif /* FREERTOS_CONFIG_H */
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/deprecated_definitions.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/deprecated_definitions.h
index 1125673..9dfdf21 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/deprecated_definitions.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/deprecated_definitions.h	
@@ -1,279 +1,279 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef DEPRECATED_DEFINITIONS_H
-#define DEPRECATED_DEFINITIONS_H
-
-
-/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
-pre-processor definition was used to ensure the pre-processor found the correct
-portmacro.h file for the port being used.  That scheme was deprecated in favour
-of setting the compiler's include path such that it found the correct
-portmacro.h file - removing the need for the constant and allowing the
-portmacro.h file to be located anywhere in relation to the port being used.  The
-definitions below remain in the code for backward compatibility only.  New
-projects should not use them. */
-
-#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
-	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
-	typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
-	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
-	typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef GCC_MEGA_AVR
-	#include "../portable/GCC/ATMega323/portmacro.h"
-#endif
-
-#ifdef IAR_MEGA_AVR
-	#include "../portable/IAR/ATMega323/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC24_PORT
-	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
-#endif
-
-#ifdef MPLAB_DSPIC_PORT
-	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC18F_PORT
-	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
-#endif
-
-#ifdef MPLAB_PIC32MX_PORT
-	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
-#endif
-
-#ifdef _FEDPICC
-	#include "libFreeRTOS/Include/portmacro.h"
-#endif
-
-#ifdef SDCC_CYGNAL
-	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
-#endif
-
-#ifdef GCC_ARM7
-	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
-#endif
-
-#ifdef GCC_ARM7_ECLIPSE
-	#include "portmacro.h"
-#endif
-
-#ifdef ROWLEY_LPC23xx
-	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
-#endif
-
-#ifdef IAR_MSP430
-	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
-#endif
-
-#ifdef GCC_MSP430
-	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
-#endif
-
-#ifdef ROWLEY_MSP430
-	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
-#endif
-
-#ifdef ARM7_LPC21xx_KEIL_RVDS
-	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
-#endif
-
-#ifdef SAM7_GCC
-	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
-#endif
-
-#ifdef SAM7_IAR
-	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
-#endif
-
-#ifdef SAM9XE_IAR
-	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
-#endif
-
-#ifdef LPC2000_IAR
-	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
-#endif
-
-#ifdef STR71X_IAR
-	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
-#endif
-
-#ifdef STR75X_IAR
-	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
-#endif
-
-#ifdef STR75X_GCC
-	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
-#endif
-
-#ifdef STR91X_IAR
-	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
-#endif
-
-#ifdef GCC_H8S
-	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
-#endif
-
-#ifdef GCC_AT91FR40008
-	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
-#endif
-
-#ifdef RVDS_ARMCM3_LM3S102
-	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef GCC_ARMCM3_LM3S102
-	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef GCC_ARMCM3
-	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef IAR_ARM_CM3
-	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef IAR_ARMCM3_LM
-	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
-#endif
-
-#ifdef HCS12_CODE_WARRIOR
-	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
-#endif
-
-#ifdef MICROBLAZE_GCC
-	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
-#endif
-
-#ifdef TERN_EE
-	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
-#endif
-
-#ifdef GCC_HCS12
-	#include "../../Source/portable/GCC/HCS12/portmacro.h"
-#endif
-
-#ifdef GCC_MCF5235
-    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
-#endif
-
-#ifdef COLDFIRE_V2_GCC
-	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
-#endif
-
-#ifdef COLDFIRE_V2_CODEWARRIOR
-	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
-#endif
-
-#ifdef GCC_PPC405
-	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
-#endif
-
-#ifdef GCC_PPC440
-	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
-#endif
-
-#ifdef _16FX_SOFTUNE
-	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
-#endif
-
-#ifdef BCC_INDUSTRIAL_PC_PORT
-	/* A short file name has to be used in place of the normal
-	FreeRTOSConfig.h when using the Borland compiler. */
-	#include "frconfig.h"
-	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
-    typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef BCC_FLASH_LITE_186_PORT
-	/* A short file name has to be used in place of the normal
-	FreeRTOSConfig.h when using the Borland compiler. */
-	#include "frconfig.h"
-	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
-    typedef void ( __interrupt __far *pxISR )();
-#endif
-
-#ifdef __GNUC__
-   #ifdef __AVR32_AVR32A__
-	   #include "portmacro.h"
-   #endif
-#endif
-
-#ifdef __ICCAVR32__
-   #ifdef __CORE__
-      #if __CORE__ == __AVR32A__
-	      #include "portmacro.h"
-      #endif
-   #endif
-#endif
-
-#ifdef __91467D
-	#include "portmacro.h"
-#endif
-
-#ifdef __96340
-	#include "portmacro.h"
-#endif
-
-
-#ifdef __IAR_V850ES_Fx3__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx3__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx3_L__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Jx2__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_V850ES_Hx2__
-	#include "../../Source/portable/IAR/V850ES/portmacro.h"
-#endif
-
-#ifdef __IAR_78K0R_Kx3__
-	#include "../../Source/portable/IAR/78K0R/portmacro.h"
-#endif
-
-#ifdef __IAR_78K0R_Kx3L__
-	#include "../../Source/portable/IAR/78K0R/portmacro.h"
-#endif
-
-#endif /* DEPRECATED_DEFINITIONS_H */
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef DEPRECATED_DEFINITIONS_H
+#define DEPRECATED_DEFINITIONS_H
+
+
+/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
+pre-processor definition was used to ensure the pre-processor found the correct
+portmacro.h file for the port being used.  That scheme was deprecated in favour
+of setting the compiler's include path such that it found the correct
+portmacro.h file - removing the need for the constant and allowing the
+portmacro.h file to be located anywhere in relation to the port being used.  The
+definitions below remain in the code for backward compatibility only.  New
+projects should not use them. */
+
+#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
+	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
+	typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
+	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
+	typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef GCC_MEGA_AVR
+	#include "../portable/GCC/ATMega323/portmacro.h"
+#endif
+
+#ifdef IAR_MEGA_AVR
+	#include "../portable/IAR/ATMega323/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC24_PORT
+	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
+#endif
+
+#ifdef MPLAB_DSPIC_PORT
+	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC18F_PORT
+	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
+#endif
+
+#ifdef MPLAB_PIC32MX_PORT
+	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
+#endif
+
+#ifdef _FEDPICC
+	#include "libFreeRTOS/Include/portmacro.h"
+#endif
+
+#ifdef SDCC_CYGNAL
+	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
+#endif
+
+#ifdef GCC_ARM7
+	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
+#endif
+
+#ifdef GCC_ARM7_ECLIPSE
+	#include "portmacro.h"
+#endif
+
+#ifdef ROWLEY_LPC23xx
+	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
+#endif
+
+#ifdef IAR_MSP430
+	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
+#endif
+
+#ifdef GCC_MSP430
+	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
+#endif
+
+#ifdef ROWLEY_MSP430
+	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
+#endif
+
+#ifdef ARM7_LPC21xx_KEIL_RVDS
+	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
+#endif
+
+#ifdef SAM7_GCC
+	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
+#endif
+
+#ifdef SAM7_IAR
+	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
+#endif
+
+#ifdef SAM9XE_IAR
+	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
+#endif
+
+#ifdef LPC2000_IAR
+	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
+#endif
+
+#ifdef STR71X_IAR
+	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
+#endif
+
+#ifdef STR75X_IAR
+	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
+#endif
+
+#ifdef STR75X_GCC
+	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
+#endif
+
+#ifdef STR91X_IAR
+	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
+#endif
+
+#ifdef GCC_H8S
+	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
+#endif
+
+#ifdef GCC_AT91FR40008
+	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
+#endif
+
+#ifdef RVDS_ARMCM3_LM3S102
+	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef GCC_ARMCM3_LM3S102
+	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef GCC_ARMCM3
+	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef IAR_ARM_CM3
+	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef IAR_ARMCM3_LM
+	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
+#endif
+
+#ifdef HCS12_CODE_WARRIOR
+	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
+#endif
+
+#ifdef MICROBLAZE_GCC
+	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
+#endif
+
+#ifdef TERN_EE
+	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
+#endif
+
+#ifdef GCC_HCS12
+	#include "../../Source/portable/GCC/HCS12/portmacro.h"
+#endif
+
+#ifdef GCC_MCF5235
+    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
+#endif
+
+#ifdef COLDFIRE_V2_GCC
+	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
+#endif
+
+#ifdef COLDFIRE_V2_CODEWARRIOR
+	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
+#endif
+
+#ifdef GCC_PPC405
+	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
+#endif
+
+#ifdef GCC_PPC440
+	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
+#endif
+
+#ifdef _16FX_SOFTUNE
+	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
+#endif
+
+#ifdef BCC_INDUSTRIAL_PC_PORT
+	/* A short file name has to be used in place of the normal
+	FreeRTOSConfig.h when using the Borland compiler. */
+	#include "frconfig.h"
+	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
+    typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef BCC_FLASH_LITE_186_PORT
+	/* A short file name has to be used in place of the normal
+	FreeRTOSConfig.h when using the Borland compiler. */
+	#include "frconfig.h"
+	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
+    typedef void ( __interrupt __far *pxISR )();
+#endif
+
+#ifdef __GNUC__
+   #ifdef __AVR32_AVR32A__
+	   #include "portmacro.h"
+   #endif
+#endif
+
+#ifdef __ICCAVR32__
+   #ifdef __CORE__
+      #if __CORE__ == __AVR32A__
+	      #include "portmacro.h"
+      #endif
+   #endif
+#endif
+
+#ifdef __91467D
+	#include "portmacro.h"
+#endif
+
+#ifdef __96340
+	#include "portmacro.h"
+#endif
+
+
+#ifdef __IAR_V850ES_Fx3__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx3__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx3_L__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Jx2__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_V850ES_Hx2__
+	#include "../../Source/portable/IAR/V850ES/portmacro.h"
+#endif
+
+#ifdef __IAR_78K0R_Kx3__
+	#include "../../Source/portable/IAR/78K0R/portmacro.h"
+#endif
+
+#ifdef __IAR_78K0R_Kx3L__
+	#include "../../Source/portable/IAR/78K0R/portmacro.h"
+#endif
+
+#endif /* DEPRECATED_DEFINITIONS_H */
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/list.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/list.h
index 4a3afa1..431443f 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/list.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/list.h	
@@ -1,411 +1,411 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*
- * This is the list implementation used by the scheduler.  While it is tailored
- * heavily for the schedulers needs, it is also available for use by
- * application code.
- *
- * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
- * numeric value (xItemValue).  Most of the time the lists are sorted in
- * descending item value order.
- *
- * Lists are created already containing one list item.  The value of this
- * item is the maximum possible that can be stored, it is therefore always at
- * the end of the list and acts as a marker.  The list member pxHead always
- * points to this marker - even though it is at the tail of the list.  This
- * is because the tail contains a wrap back pointer to the true head of
- * the list.
- *
- * In addition to it's value, each list item contains a pointer to the next
- * item in the list (pxNext), a pointer to the list it is in (pxContainer)
- * and a pointer to back to the object that contains it.  These later two
- * pointers are included for efficiency of list manipulation.  There is
- * effectively a two way link between the object containing the list item and
- * the list item itself.
- *
- *
- * \page ListIntroduction List Implementation
- * \ingroup FreeRTOSIntro
- */
-
-#ifndef INC_FREERTOS_H
-	#error FreeRTOS.h must be included before list.h
-#endif
-
-#ifndef LIST_H
-#define LIST_H
-
-/*
- * The list structure members are modified from within interrupts, and therefore
- * by rights should be declared volatile.  However, they are only modified in a
- * functionally atomic way (within critical sections of with the scheduler
- * suspended) and are either passed by reference into a function or indexed via
- * a volatile variable.  Therefore, in all use cases tested so far, the volatile
- * qualifier can be omitted in order to provide a moderate performance
- * improvement without adversely affecting functional behaviour.  The assembly
- * instructions generated by the IAR, ARM and GCC compilers when the respective
- * compiler's options were set for maximum optimisation has been inspected and
- * deemed to be as intended.  That said, as compiler technology advances, and
- * especially if aggressive cross module optimisation is used (a use case that
- * has not been exercised to any great extend) then it is feasible that the
- * volatile qualifier will be needed for correct optimisation.  It is expected
- * that a compiler removing essential code because, without the volatile
- * qualifier on the list structure members and with aggressive cross module
- * optimisation, the compiler deemed the code unnecessary will result in
- * complete and obvious failure of the scheduler.  If this is ever experienced
- * then the volatile qualifier can be inserted in the relevant places within the
- * list structures by simply defining configLIST_VOLATILE to volatile in
- * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
- * If configLIST_VOLATILE is not defined then the preprocessor directives below
- * will simply #define configLIST_VOLATILE away completely.
- *
- * To use volatile list structure members then add the following line to
- * FreeRTOSConfig.h (without the quotes):
- * "#define configLIST_VOLATILE volatile"
- */
-#ifndef configLIST_VOLATILE
-	#define configLIST_VOLATILE
-#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Macros that can be used to place known values within the list structures,
-then check that the known values do not get corrupted during the execution of
-the application.   These may catch the list data structures being overwritten in
-memory.  They will not catch data errors caused by incorrect configuration or
-use of FreeRTOS.*/
-#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
-	/* Define the macros to do nothing. */
-	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
-	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
-	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
-	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
-	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
-	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
-	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
-	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
-	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
-	#define listTEST_LIST_INTEGRITY( pxList )
-#else
-	/* Define macros that add new members into the list structures. */
-	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
-	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
-	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
-	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
-
-	/* Define macros that set the new structure members to known values. */
-	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
-	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
-
-	/* Define macros that will assert if one of the structure members does not
-	contain its expected value. */
-	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
-	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
-#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
-
-
-/*
- * Definition of the only type of object that a list can contain.
- */
-struct xLIST_ITEM
-{
-	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
-	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
-	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
-	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
-	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
-	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-};
-typedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
-
-struct xMINI_LIST_ITEM
-{
-	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	configLIST_VOLATILE TickType_t xItemValue;
-	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
-	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
-};
-typedef struct xMINI_LIST_ITEM MiniListItem_t;
-
-/*
- * Definition of the type of queue used by the scheduler.
- */
-typedef struct xLIST
-{
-	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-	volatile UBaseType_t uxNumberOfItems;
-	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
-	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
-	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
-} List_t;
-
-/*
- * Access macro to set the owner of a list item.  The owner of a list item
- * is the object (usually a TCB) that contains the list item.
- *
- * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
- * \ingroup LinkedList
- */
-#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
-
-/*
- * Access macro to get the owner of a list item.  The owner of a list item
- * is the object (usually a TCB) that contains the list item.
- *
- * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
- * \ingroup LinkedList
- */
-#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
-
-/*
- * Access macro to set the value of the list item.  In most cases the value is
- * used to sort the list in descending order.
- *
- * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
-
-/*
- * Access macro to retrieve the value of the list item.  The value can
- * represent anything - for example the priority of a task, or the time at
- * which a task should be unblocked.
- *
- * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
-
-/*
- * Access macro to retrieve the value of the list item at the head of a given
- * list.
- *
- * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
- * \ingroup LinkedList
- */
-#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
-
-/*
- * Return the list item at the head of the list.
- *
- * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
-
-/*
- * Return the list item at the head of the list.
- *
- * \page listGET_NEXT listGET_NEXT
- * \ingroup LinkedList
- */
-#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
-
-/*
- * Return the list item that marks the end of the list
- *
- * \page listGET_END_MARKER listGET_END_MARKER
- * \ingroup LinkedList
- */
-#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
-
-/*
- * Access macro to determine if a list contains any items.  The macro will
- * only have the value true if the list is empty.
- *
- * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
- * \ingroup LinkedList
- */
-#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
-
-/*
- * Access macro to return the number of items in the list.
- */
-#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
-
-/*
- * Access function to obtain the owner of the next entry in a list.
- *
- * The list member pxIndex is used to walk through a list.  Calling
- * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
- * and returns that entry's pxOwner parameter.  Using multiple calls to this
- * function it is therefore possible to move through every item contained in
- * a list.
- *
- * The pxOwner parameter of a list item is a pointer to the object that owns
- * the list item.  In the scheduler this is normally a task control block.
- * The pxOwner parameter effectively creates a two way link between the list
- * item and its owner.
- *
- * @param pxTCB pxTCB is set to the address of the owner of the next list item.
- * @param pxList The list from which the next item owner is to be returned.
- *
- * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
-{																							\
-List_t * const pxConstList = ( pxList );													\
-	/* Increment the index to the next item and return the item, ensuring */				\
-	/* we don't return the marker used at the end of the list.  */							\
-	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
-	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
-	{																						\
-		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
-	}																						\
-	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
-}
-
-
-/*
- * Access function to obtain the owner of the first entry in a list.  Lists
- * are normally sorted in ascending item value order.
- *
- * This function returns the pxOwner member of the first item in the list.
- * The pxOwner parameter of a list item is a pointer to the object that owns
- * the list item.  In the scheduler this is normally a task control block.
- * The pxOwner parameter effectively creates a two way link between the list
- * item and its owner.
- *
- * @param pxList The list from which the owner of the head item is to be
- * returned.
- *
- * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
- * \ingroup LinkedList
- */
-#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
-
-/*
- * Check to see if a list item is within a list.  The list item maintains a
- * "container" pointer that points to the list it is in.  All this macro does
- * is check to see if the container and the list match.
- *
- * @param pxList The list we want to know if the list item is within.
- * @param pxListItem The list item we want to know if is in the list.
- * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
- */
-#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
-
-/*
- * Return the list a list item is contained within (referenced from).
- *
- * @param pxListItem The list item being queried.
- * @return A pointer to the List_t object that references the pxListItem
- */
-#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
-
-/*
- * This provides a crude means of knowing if a list has been initialised, as
- * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
- * function.
- */
-#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
-
-/*
- * Must be called before a list is used!  This initialises all the members
- * of the list structure and inserts the xListEnd item into the list as a
- * marker to the back of the list.
- *
- * @param pxList Pointer to the list being initialised.
- *
- * \page vListInitialise vListInitialise
- * \ingroup LinkedList
- */
-void vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
-
-/*
- * Must be called before a list item is used.  This sets the list container to
- * null so the item does not think that it is already contained in a list.
- *
- * @param pxItem Pointer to the list item being initialised.
- *
- * \page vListInitialiseItem vListInitialiseItem
- * \ingroup LinkedList
- */
-void vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Insert a list item into a list.  The item will be inserted into the list in
- * a position determined by its item value (descending item value order).
- *
- * @param pxList The list into which the item is to be inserted.
- *
- * @param pxNewListItem The item that is to be placed in the list.
- *
- * \page vListInsert vListInsert
- * \ingroup LinkedList
- */
-void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Insert a list item into a list.  The item will be inserted in a position
- * such that it will be the last item within the list returned by multiple
- * calls to listGET_OWNER_OF_NEXT_ENTRY.
- *
- * The list member pxIndex is used to walk through a list.  Calling
- * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
- * Placing an item in a list using vListInsertEnd effectively places the item
- * in the list position pointed to by pxIndex.  This means that every other
- * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
- * the pxIndex parameter again points to the item being inserted.
- *
- * @param pxList The list into which the item is to be inserted.
- *
- * @param pxNewListItem The list item to be inserted into the list.
- *
- * \page vListInsertEnd vListInsertEnd
- * \ingroup LinkedList
- */
-void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
-
-/*
- * Remove an item from a list.  The list item has a pointer to the list that
- * it is in, so only the list item need be passed into the function.
- *
- * @param uxListRemove The item to be removed.  The item will remove itself from
- * the list pointed to by it's pxContainer parameter.
- *
- * @return The number of items that remain in the list after the list item has
- * been removed.
- *
- * \page uxListRemove uxListRemove
- * \ingroup LinkedList
- */
-UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*
+ * This is the list implementation used by the scheduler.  While it is tailored
+ * heavily for the schedulers needs, it is also available for use by
+ * application code.
+ *
+ * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
+ * numeric value (xItemValue).  Most of the time the lists are sorted in
+ * descending item value order.
+ *
+ * Lists are created already containing one list item.  The value of this
+ * item is the maximum possible that can be stored, it is therefore always at
+ * the end of the list and acts as a marker.  The list member pxHead always
+ * points to this marker - even though it is at the tail of the list.  This
+ * is because the tail contains a wrap back pointer to the true head of
+ * the list.
+ *
+ * In addition to it's value, each list item contains a pointer to the next
+ * item in the list (pxNext), a pointer to the list it is in (pxContainer)
+ * and a pointer to back to the object that contains it.  These later two
+ * pointers are included for efficiency of list manipulation.  There is
+ * effectively a two way link between the object containing the list item and
+ * the list item itself.
+ *
+ *
+ * \page ListIntroduction List Implementation
+ * \ingroup FreeRTOSIntro
+ */
+
+#ifndef INC_FREERTOS_H
+	#error FreeRTOS.h must be included before list.h
+#endif
+
+#ifndef LIST_H
+#define LIST_H
+
+/*
+ * The list structure members are modified from within interrupts, and therefore
+ * by rights should be declared volatile.  However, they are only modified in a
+ * functionally atomic way (within critical sections of with the scheduler
+ * suspended) and are either passed by reference into a function or indexed via
+ * a volatile variable.  Therefore, in all use cases tested so far, the volatile
+ * qualifier can be omitted in order to provide a moderate performance
+ * improvement without adversely affecting functional behaviour.  The assembly
+ * instructions generated by the IAR, ARM and GCC compilers when the respective
+ * compiler's options were set for maximum optimisation has been inspected and
+ * deemed to be as intended.  That said, as compiler technology advances, and
+ * especially if aggressive cross module optimisation is used (a use case that
+ * has not been exercised to any great extend) then it is feasible that the
+ * volatile qualifier will be needed for correct optimisation.  It is expected
+ * that a compiler removing essential code because, without the volatile
+ * qualifier on the list structure members and with aggressive cross module
+ * optimisation, the compiler deemed the code unnecessary will result in
+ * complete and obvious failure of the scheduler.  If this is ever experienced
+ * then the volatile qualifier can be inserted in the relevant places within the
+ * list structures by simply defining configLIST_VOLATILE to volatile in
+ * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
+ * If configLIST_VOLATILE is not defined then the preprocessor directives below
+ * will simply #define configLIST_VOLATILE away completely.
+ *
+ * To use volatile list structure members then add the following line to
+ * FreeRTOSConfig.h (without the quotes):
+ * "#define configLIST_VOLATILE volatile"
+ */
+#ifndef configLIST_VOLATILE
+	#define configLIST_VOLATILE
+#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Macros that can be used to place known values within the list structures,
+then check that the known values do not get corrupted during the execution of
+the application.   These may catch the list data structures being overwritten in
+memory.  They will not catch data errors caused by incorrect configuration or
+use of FreeRTOS.*/
+#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
+	/* Define the macros to do nothing. */
+	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
+	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
+	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
+	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
+	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
+	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
+	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
+	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
+	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
+	#define listTEST_LIST_INTEGRITY( pxList )
+#else
+	/* Define macros that add new members into the list structures. */
+	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
+	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
+	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
+	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
+
+	/* Define macros that set the new structure members to known values. */
+	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
+	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
+
+	/* Define macros that will assert if one of the structure members does not
+	contain its expected value. */
+	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
+	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
+#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
+
+
+/*
+ * Definition of the only type of object that a list can contain.
+ */
+struct xLIST_ITEM
+{
+	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
+	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
+	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
+	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
+	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
+	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+};
+typedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
+
+struct xMINI_LIST_ITEM
+{
+	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	configLIST_VOLATILE TickType_t xItemValue;
+	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
+	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
+};
+typedef struct xMINI_LIST_ITEM MiniListItem_t;
+
+/*
+ * Definition of the type of queue used by the scheduler.
+ */
+typedef struct xLIST
+{
+	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+	volatile UBaseType_t uxNumberOfItems;
+	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
+	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
+	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
+} List_t;
+
+/*
+ * Access macro to set the owner of a list item.  The owner of a list item
+ * is the object (usually a TCB) that contains the list item.
+ *
+ * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
+ * \ingroup LinkedList
+ */
+#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
+
+/*
+ * Access macro to get the owner of a list item.  The owner of a list item
+ * is the object (usually a TCB) that contains the list item.
+ *
+ * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
+ * \ingroup LinkedList
+ */
+#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
+
+/*
+ * Access macro to set the value of the list item.  In most cases the value is
+ * used to sort the list in descending order.
+ *
+ * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
+
+/*
+ * Access macro to retrieve the value of the list item.  The value can
+ * represent anything - for example the priority of a task, or the time at
+ * which a task should be unblocked.
+ *
+ * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
+
+/*
+ * Access macro to retrieve the value of the list item at the head of a given
+ * list.
+ *
+ * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
+ * \ingroup LinkedList
+ */
+#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
+
+/*
+ * Return the list item at the head of the list.
+ *
+ * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
+
+/*
+ * Return the list item at the head of the list.
+ *
+ * \page listGET_NEXT listGET_NEXT
+ * \ingroup LinkedList
+ */
+#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
+
+/*
+ * Return the list item that marks the end of the list
+ *
+ * \page listGET_END_MARKER listGET_END_MARKER
+ * \ingroup LinkedList
+ */
+#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
+
+/*
+ * Access macro to determine if a list contains any items.  The macro will
+ * only have the value true if the list is empty.
+ *
+ * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
+ * \ingroup LinkedList
+ */
+#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
+
+/*
+ * Access macro to return the number of items in the list.
+ */
+#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
+
+/*
+ * Access function to obtain the owner of the next entry in a list.
+ *
+ * The list member pxIndex is used to walk through a list.  Calling
+ * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
+ * and returns that entry's pxOwner parameter.  Using multiple calls to this
+ * function it is therefore possible to move through every item contained in
+ * a list.
+ *
+ * The pxOwner parameter of a list item is a pointer to the object that owns
+ * the list item.  In the scheduler this is normally a task control block.
+ * The pxOwner parameter effectively creates a two way link between the list
+ * item and its owner.
+ *
+ * @param pxTCB pxTCB is set to the address of the owner of the next list item.
+ * @param pxList The list from which the next item owner is to be returned.
+ *
+ * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
+{																							\
+List_t * const pxConstList = ( pxList );													\
+	/* Increment the index to the next item and return the item, ensuring */				\
+	/* we don't return the marker used at the end of the list.  */							\
+	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
+	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
+	{																						\
+		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
+	}																						\
+	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
+}
+
+
+/*
+ * Access function to obtain the owner of the first entry in a list.  Lists
+ * are normally sorted in ascending item value order.
+ *
+ * This function returns the pxOwner member of the first item in the list.
+ * The pxOwner parameter of a list item is a pointer to the object that owns
+ * the list item.  In the scheduler this is normally a task control block.
+ * The pxOwner parameter effectively creates a two way link between the list
+ * item and its owner.
+ *
+ * @param pxList The list from which the owner of the head item is to be
+ * returned.
+ *
+ * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
+ * \ingroup LinkedList
+ */
+#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
+
+/*
+ * Check to see if a list item is within a list.  The list item maintains a
+ * "container" pointer that points to the list it is in.  All this macro does
+ * is check to see if the container and the list match.
+ *
+ * @param pxList The list we want to know if the list item is within.
+ * @param pxListItem The list item we want to know if is in the list.
+ * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
+ */
+#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
+
+/*
+ * Return the list a list item is contained within (referenced from).
+ *
+ * @param pxListItem The list item being queried.
+ * @return A pointer to the List_t object that references the pxListItem
+ */
+#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
+
+/*
+ * This provides a crude means of knowing if a list has been initialised, as
+ * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
+ * function.
+ */
+#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
+
+/*
+ * Must be called before a list is used!  This initialises all the members
+ * of the list structure and inserts the xListEnd item into the list as a
+ * marker to the back of the list.
+ *
+ * @param pxList Pointer to the list being initialised.
+ *
+ * \page vListInitialise vListInitialise
+ * \ingroup LinkedList
+ */
+void vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
+
+/*
+ * Must be called before a list item is used.  This sets the list container to
+ * null so the item does not think that it is already contained in a list.
+ *
+ * @param pxItem Pointer to the list item being initialised.
+ *
+ * \page vListInitialiseItem vListInitialiseItem
+ * \ingroup LinkedList
+ */
+void vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Insert a list item into a list.  The item will be inserted into the list in
+ * a position determined by its item value (descending item value order).
+ *
+ * @param pxList The list into which the item is to be inserted.
+ *
+ * @param pxNewListItem The item that is to be placed in the list.
+ *
+ * \page vListInsert vListInsert
+ * \ingroup LinkedList
+ */
+void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Insert a list item into a list.  The item will be inserted in a position
+ * such that it will be the last item within the list returned by multiple
+ * calls to listGET_OWNER_OF_NEXT_ENTRY.
+ *
+ * The list member pxIndex is used to walk through a list.  Calling
+ * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
+ * Placing an item in a list using vListInsertEnd effectively places the item
+ * in the list position pointed to by pxIndex.  This means that every other
+ * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
+ * the pxIndex parameter again points to the item being inserted.
+ *
+ * @param pxList The list into which the item is to be inserted.
+ *
+ * @param pxNewListItem The list item to be inserted into the list.
+ *
+ * \page vListInsertEnd vListInsertEnd
+ * \ingroup LinkedList
+ */
+void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
+
+/*
+ * Remove an item from a list.  The list item has a pointer to the list that
+ * it is in, so only the list item need be passed into the function.
+ *
+ * @param uxListRemove The item to be removed.  The item will remove itself from
+ * the list pointed to by it's pxContainer parameter.
+ *
+ * @return The number of items that remain in the list after the list item has
+ * been removed.
+ *
+ * \page uxListRemove uxListRemove
+ * \ingroup LinkedList
+ */
+UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/mpu_wrappers.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/mpu_wrappers.h
index eb326e7..1e97ae4 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/mpu_wrappers.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/mpu_wrappers.h	
@@ -1,181 +1,181 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef MPU_WRAPPERS_H
-#define MPU_WRAPPERS_H
-
-/* This file redefines API functions to be called through a wrapper macro, but
-only for ports that are using the MPU. */
-#ifdef portUSING_MPU_WRAPPERS
-
-	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
-	included from queue.c or task.c to prevent it from having an effect within
-	those files. */
-	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
-
-		/*
-		 * Map standard (non MPU) API functions to equivalents that start
-		 * "MPU_".  This will cause the application code to call the MPU_
-		 * version, which wraps the non-MPU version with privilege promoting
-		 * then demoting code, so the kernel code always runs will full
-		 * privileges.
-		 */
-
-		/* Map standard tasks.h API functions to the MPU equivalents. */
-		#define xTaskCreate								MPU_xTaskCreate
-		#define xTaskCreateStatic						MPU_xTaskCreateStatic
-		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
-		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
-		#define vTaskDelete								MPU_vTaskDelete
-		#define vTaskDelay								MPU_vTaskDelay
-		#define vTaskDelayUntil							MPU_vTaskDelayUntil
-		#define xTaskAbortDelay							MPU_xTaskAbortDelay
-		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
-		#define eTaskGetState							MPU_eTaskGetState
-		#define vTaskGetInfo							MPU_vTaskGetInfo
-		#define vTaskPrioritySet						MPU_vTaskPrioritySet
-		#define vTaskSuspend							MPU_vTaskSuspend
-		#define vTaskResume								MPU_vTaskResume
-		#define vTaskSuspendAll							MPU_vTaskSuspendAll
-		#define xTaskResumeAll							MPU_xTaskResumeAll
-		#define xTaskGetTickCount						MPU_xTaskGetTickCount
-		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
-		#define pcTaskGetName							MPU_pcTaskGetName
-		#define xTaskGetHandle							MPU_xTaskGetHandle
-		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
-		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
-		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
-		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
-		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
-		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
-		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
-		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
-		#define vTaskList								MPU_vTaskList
-		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
-		#define xTaskGenericNotify						MPU_xTaskGenericNotify
-		#define xTaskNotifyWait							MPU_xTaskNotifyWait
-		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
-		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
-
-		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
-		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
-		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
-		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
-
-		/* Map standard queue.h API functions to the MPU equivalents. */
-		#define xQueueGenericSend						MPU_xQueueGenericSend
-		#define xQueueReceive							MPU_xQueueReceive
-		#define xQueuePeek								MPU_xQueuePeek
-		#define xQueueSemaphoreTake						MPU_xQueueSemaphoreTake
-		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
-		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
-		#define vQueueDelete							MPU_vQueueDelete
-		#define xQueueCreateMutex						MPU_xQueueCreateMutex
-		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
-		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
-		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
-		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
-		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
-		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
-		#define xQueueGenericCreate						MPU_xQueueGenericCreate
-		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
-		#define xQueueCreateSet							MPU_xQueueCreateSet
-		#define xQueueAddToSet							MPU_xQueueAddToSet
-		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
-		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
-		#define xQueueGenericReset						MPU_xQueueGenericReset
-
-		#if( configQUEUE_REGISTRY_SIZE > 0 )
-			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
-			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
-			#define pcQueueGetName							MPU_pcQueueGetName
-		#endif
-
-		/* Map standard timer.h API functions to the MPU equivalents. */
-		#define xTimerCreate							MPU_xTimerCreate
-		#define xTimerCreateStatic						MPU_xTimerCreateStatic
-		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
-		#define vTimerSetTimerID						MPU_vTimerSetTimerID
-		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
-		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
-		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
-		#define pcTimerGetName							MPU_pcTimerGetName
-		#define xTimerGetPeriod							MPU_xTimerGetPeriod
-		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
-		#define xTimerGenericCommand					MPU_xTimerGenericCommand
-
-		/* Map standard event_group.h API functions to the MPU equivalents. */
-		#define xEventGroupCreate						MPU_xEventGroupCreate
-		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
-		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
-		#define xEventGroupClearBits					MPU_xEventGroupClearBits
-		#define xEventGroupSetBits						MPU_xEventGroupSetBits
-		#define xEventGroupSync							MPU_xEventGroupSync
-		#define vEventGroupDelete						MPU_vEventGroupDelete
-
-		/* Map standard message/stream_buffer.h API functions to the MPU
-		equivalents. */
-		#define xStreamBufferSend						MPU_xStreamBufferSend
-		#define xStreamBufferSendFromISR				MPU_xStreamBufferSendFromISR
-		#define xStreamBufferReceive					MPU_xStreamBufferReceive
-		#define xStreamBufferReceiveFromISR				MPU_xStreamBufferReceiveFromISR
-		#define vStreamBufferDelete						MPU_vStreamBufferDelete
-		#define xStreamBufferIsFull						MPU_xStreamBufferIsFull
-		#define xStreamBufferIsEmpty					MPU_xStreamBufferIsEmpty
-		#define xStreamBufferReset						MPU_xStreamBufferReset
-		#define xStreamBufferSpacesAvailable			MPU_xStreamBufferSpacesAvailable
-		#define xStreamBufferBytesAvailable				MPU_xStreamBufferBytesAvailable
-		#define xStreamBufferSetTriggerLevel			MPU_xStreamBufferSetTriggerLevel
-		#define xStreamBufferGenericCreate				MPU_xStreamBufferGenericCreate
-		#define xStreamBufferGenericCreateStatic		MPU_xStreamBufferGenericCreateStatic
-
-
-		/* Remove the privileged function macro, but keep the PRIVILEGED_DATA
-		macro so applications can place data in privileged access sections
-		(useful when using statically allocated objects). */
-		#define PRIVILEGED_FUNCTION
-		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
-
-	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
-
-		/* Ensure API functions go in the privileged execution section. */
-		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
-		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
-
-	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
-
-#else /* portUSING_MPU_WRAPPERS */
-
-	#define PRIVILEGED_FUNCTION
-	#define PRIVILEGED_DATA
-	#define portUSING_MPU_WRAPPERS 0
-
-#endif /* portUSING_MPU_WRAPPERS */
-
-
-#endif /* MPU_WRAPPERS_H */
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef MPU_WRAPPERS_H
+#define MPU_WRAPPERS_H
+
+/* This file redefines API functions to be called through a wrapper macro, but
+only for ports that are using the MPU. */
+#ifdef portUSING_MPU_WRAPPERS
+
+	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
+	included from queue.c or task.c to prevent it from having an effect within
+	those files. */
+	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
+
+		/*
+		 * Map standard (non MPU) API functions to equivalents that start
+		 * "MPU_".  This will cause the application code to call the MPU_
+		 * version, which wraps the non-MPU version with privilege promoting
+		 * then demoting code, so the kernel code always runs will full
+		 * privileges.
+		 */
+
+		/* Map standard tasks.h API functions to the MPU equivalents. */
+		#define xTaskCreate								MPU_xTaskCreate
+		#define xTaskCreateStatic						MPU_xTaskCreateStatic
+		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
+		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
+		#define vTaskDelete								MPU_vTaskDelete
+		#define vTaskDelay								MPU_vTaskDelay
+		#define vTaskDelayUntil							MPU_vTaskDelayUntil
+		#define xTaskAbortDelay							MPU_xTaskAbortDelay
+		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
+		#define eTaskGetState							MPU_eTaskGetState
+		#define vTaskGetInfo							MPU_vTaskGetInfo
+		#define vTaskPrioritySet						MPU_vTaskPrioritySet
+		#define vTaskSuspend							MPU_vTaskSuspend
+		#define vTaskResume								MPU_vTaskResume
+		#define vTaskSuspendAll							MPU_vTaskSuspendAll
+		#define xTaskResumeAll							MPU_xTaskResumeAll
+		#define xTaskGetTickCount						MPU_xTaskGetTickCount
+		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
+		#define pcTaskGetName							MPU_pcTaskGetName
+		#define xTaskGetHandle							MPU_xTaskGetHandle
+		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
+		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
+		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
+		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
+		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
+		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
+		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
+		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
+		#define vTaskList								MPU_vTaskList
+		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
+		#define xTaskGenericNotify						MPU_xTaskGenericNotify
+		#define xTaskNotifyWait							MPU_xTaskNotifyWait
+		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
+		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
+
+		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
+		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
+		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
+		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
+
+		/* Map standard queue.h API functions to the MPU equivalents. */
+		#define xQueueGenericSend						MPU_xQueueGenericSend
+		#define xQueueReceive							MPU_xQueueReceive
+		#define xQueuePeek								MPU_xQueuePeek
+		#define xQueueSemaphoreTake						MPU_xQueueSemaphoreTake
+		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
+		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
+		#define vQueueDelete							MPU_vQueueDelete
+		#define xQueueCreateMutex						MPU_xQueueCreateMutex
+		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
+		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
+		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
+		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
+		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
+		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
+		#define xQueueGenericCreate						MPU_xQueueGenericCreate
+		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
+		#define xQueueCreateSet							MPU_xQueueCreateSet
+		#define xQueueAddToSet							MPU_xQueueAddToSet
+		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
+		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
+		#define xQueueGenericReset						MPU_xQueueGenericReset
+
+		#if( configQUEUE_REGISTRY_SIZE > 0 )
+			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
+			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
+			#define pcQueueGetName							MPU_pcQueueGetName
+		#endif
+
+		/* Map standard timer.h API functions to the MPU equivalents. */
+		#define xTimerCreate							MPU_xTimerCreate
+		#define xTimerCreateStatic						MPU_xTimerCreateStatic
+		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
+		#define vTimerSetTimerID						MPU_vTimerSetTimerID
+		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
+		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
+		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
+		#define pcTimerGetName							MPU_pcTimerGetName
+		#define xTimerGetPeriod							MPU_xTimerGetPeriod
+		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
+		#define xTimerGenericCommand					MPU_xTimerGenericCommand
+
+		/* Map standard event_group.h API functions to the MPU equivalents. */
+		#define xEventGroupCreate						MPU_xEventGroupCreate
+		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
+		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
+		#define xEventGroupClearBits					MPU_xEventGroupClearBits
+		#define xEventGroupSetBits						MPU_xEventGroupSetBits
+		#define xEventGroupSync							MPU_xEventGroupSync
+		#define vEventGroupDelete						MPU_vEventGroupDelete
+
+		/* Map standard message/stream_buffer.h API functions to the MPU
+		equivalents. */
+		#define xStreamBufferSend						MPU_xStreamBufferSend
+		#define xStreamBufferSendFromISR				MPU_xStreamBufferSendFromISR
+		#define xStreamBufferReceive					MPU_xStreamBufferReceive
+		#define xStreamBufferReceiveFromISR				MPU_xStreamBufferReceiveFromISR
+		#define vStreamBufferDelete						MPU_vStreamBufferDelete
+		#define xStreamBufferIsFull						MPU_xStreamBufferIsFull
+		#define xStreamBufferIsEmpty					MPU_xStreamBufferIsEmpty
+		#define xStreamBufferReset						MPU_xStreamBufferReset
+		#define xStreamBufferSpacesAvailable			MPU_xStreamBufferSpacesAvailable
+		#define xStreamBufferBytesAvailable				MPU_xStreamBufferBytesAvailable
+		#define xStreamBufferSetTriggerLevel			MPU_xStreamBufferSetTriggerLevel
+		#define xStreamBufferGenericCreate				MPU_xStreamBufferGenericCreate
+		#define xStreamBufferGenericCreateStatic		MPU_xStreamBufferGenericCreateStatic
+
+
+		/* Remove the privileged function macro, but keep the PRIVILEGED_DATA
+		macro so applications can place data in privileged access sections
+		(useful when using statically allocated objects). */
+		#define PRIVILEGED_FUNCTION
+		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
+
+	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
+
+		/* Ensure API functions go in the privileged execution section. */
+		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
+		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
+
+	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
+
+#else /* portUSING_MPU_WRAPPERS */
+
+	#define PRIVILEGED_FUNCTION
+	#define PRIVILEGED_DATA
+	#define portUSING_MPU_WRAPPERS 0
+
+#endif /* portUSING_MPU_WRAPPERS */
+
+
+#endif /* MPU_WRAPPERS_H */
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portable.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portable.h
index 3d0ef0a..8aac353 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portable.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portable.h	
@@ -1,165 +1,165 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-/*-----------------------------------------------------------
- * Portable layer API.  Each function must be defined for each port.
- *----------------------------------------------------------*/
-
-#ifndef PORTABLE_H
-#define PORTABLE_H
-
-/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
-pre-processor definition was used to ensure the pre-processor found the correct
-portmacro.h file for the port being used.  That scheme was deprecated in favour
-of setting the compiler's include path such that it found the correct
-portmacro.h file - removing the need for the constant and allowing the
-portmacro.h file to be located anywhere in relation to the port being used.
-Purely for reasons of backward compatibility the old method is still valid, but
-to make it clear that new projects should not use it, support for the port
-specific constants has been moved into the deprecated_definitions.h header
-file. */
-#include "deprecated_definitions.h"
-
-/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
-did not result in a portmacro.h header file being included - and it should be
-included here.  In this case the path to the correct portmacro.h header file
-must be set in the compiler's include path. */
-#ifndef portENTER_CRITICAL
-	#include "portmacro.h"
-#endif
-
-#if portBYTE_ALIGNMENT == 32
-	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
-#endif
-
-#if portBYTE_ALIGNMENT == 16
-	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
-#endif
-
-#if portBYTE_ALIGNMENT == 8
-	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
-#endif
-
-#if portBYTE_ALIGNMENT == 4
-	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
-#endif
-
-#if portBYTE_ALIGNMENT == 2
-	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
-#endif
-
-#if portBYTE_ALIGNMENT == 1
-	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
-#endif
-
-#ifndef portBYTE_ALIGNMENT_MASK
-	#error "Invalid portBYTE_ALIGNMENT definition"
-#endif
-
-#ifndef portNUM_CONFIGURABLE_REGIONS
-	#define portNUM_CONFIGURABLE_REGIONS 1
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "mpu_wrappers.h"
-
-/*
- * Setup the stack of a new task so it is ready to be placed under the
- * scheduler control.  The registers have to be placed on the stack in
- * the order that the port expects to find them.
- *
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
-#else
-	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
-#endif
-
-/* Used by heap_5.c. */
-typedef struct HeapRegion
-{
-	uint8_t *pucStartAddress;
-	size_t xSizeInBytes;
-} HeapRegion_t;
-
-/*
- * Used to define multiple heap regions for use by heap_5.c.  This function
- * must be called before any calls to pvPortMalloc() - not creating a task,
- * queue, semaphore, mutex, software timer, event group, etc. will result in
- * pvPortMalloc being called.
- *
- * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
- * defines a region of memory that can be used as the heap.  The array is
- * terminated by a HeapRegions_t structure that has a size of 0.  The region
- * with the lowest start address must appear first in the array.
- */
-void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
-
-
-/*
- * Map to the memory management routines required for the port.
- */
-void *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
-void vPortFree( void *pv ) PRIVILEGED_FUNCTION;
-void vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
-size_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
-size_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Setup the hardware ready for the scheduler to take control.  This generally
- * sets up a tick interrupt and sets timers for the correct tick frequency.
- */
-BaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
- * the hardware is left in its original condition after the scheduler stops
- * executing.
- */
-void vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
-
-/*
- * The structures and methods of manipulating the MPU are contained within the
- * port layer.
- *
- * Fills the xMPUSettings structure with the memory region information
- * contained in xRegions.
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	struct xMEMORY_REGION;
-	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PORTABLE_H */
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+/*-----------------------------------------------------------
+ * Portable layer API.  Each function must be defined for each port.
+ *----------------------------------------------------------*/
+
+#ifndef PORTABLE_H
+#define PORTABLE_H
+
+/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
+pre-processor definition was used to ensure the pre-processor found the correct
+portmacro.h file for the port being used.  That scheme was deprecated in favour
+of setting the compiler's include path such that it found the correct
+portmacro.h file - removing the need for the constant and allowing the
+portmacro.h file to be located anywhere in relation to the port being used.
+Purely for reasons of backward compatibility the old method is still valid, but
+to make it clear that new projects should not use it, support for the port
+specific constants has been moved into the deprecated_definitions.h header
+file. */
+#include "deprecated_definitions.h"
+
+/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
+did not result in a portmacro.h header file being included - and it should be
+included here.  In this case the path to the correct portmacro.h header file
+must be set in the compiler's include path. */
+#ifndef portENTER_CRITICAL
+	#include "portmacro.h"
+#endif
+
+#if portBYTE_ALIGNMENT == 32
+	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
+#endif
+
+#if portBYTE_ALIGNMENT == 16
+	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
+#endif
+
+#if portBYTE_ALIGNMENT == 8
+	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
+#endif
+
+#if portBYTE_ALIGNMENT == 4
+	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
+#endif
+
+#if portBYTE_ALIGNMENT == 2
+	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
+#endif
+
+#if portBYTE_ALIGNMENT == 1
+	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
+#endif
+
+#ifndef portBYTE_ALIGNMENT_MASK
+	#error "Invalid portBYTE_ALIGNMENT definition"
+#endif
+
+#ifndef portNUM_CONFIGURABLE_REGIONS
+	#define portNUM_CONFIGURABLE_REGIONS 1
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mpu_wrappers.h"
+
+/*
+ * Setup the stack of a new task so it is ready to be placed under the
+ * scheduler control.  The registers have to be placed on the stack in
+ * the order that the port expects to find them.
+ *
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
+#else
+	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
+#endif
+
+/* Used by heap_5.c. */
+typedef struct HeapRegion
+{
+	uint8_t *pucStartAddress;
+	size_t xSizeInBytes;
+} HeapRegion_t;
+
+/*
+ * Used to define multiple heap regions for use by heap_5.c.  This function
+ * must be called before any calls to pvPortMalloc() - not creating a task,
+ * queue, semaphore, mutex, software timer, event group, etc. will result in
+ * pvPortMalloc being called.
+ *
+ * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
+ * defines a region of memory that can be used as the heap.  The array is
+ * terminated by a HeapRegions_t structure that has a size of 0.  The region
+ * with the lowest start address must appear first in the array.
+ */
+void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
+
+
+/*
+ * Map to the memory management routines required for the port.
+ */
+void *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
+void vPortFree( void *pv ) PRIVILEGED_FUNCTION;
+void vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
+size_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
+size_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Setup the hardware ready for the scheduler to take control.  This generally
+ * sets up a tick interrupt and sets timers for the correct tick frequency.
+ */
+BaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
+ * the hardware is left in its original condition after the scheduler stops
+ * executing.
+ */
+void vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * The structures and methods of manipulating the MPU are contained within the
+ * port layer.
+ *
+ * Fills the xMPUSettings structure with the memory region information
+ * contained in xRegions.
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	struct xMEMORY_REGION;
+	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PORTABLE_H */
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portmacro.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portmacro.h
index 763a40b..26652a1 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portmacro.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/portmacro.h	
@@ -1,117 +1,117 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef __PORTMACRO_H__
-#define __PORTMACRO_H__
-
-/*-----------------------------------------------------------
- * Port specific definitions.
- *
- * The settings in this file configure FreeRTOS correctly for the
- * given hardware and compiler.
- *
- * These settings should not be altered.
- *-----------------------------------------------------------
- */
-
-/* Type definitions. */
-#define portCHAR        char
-#define portFLOAT       float
-#define portDOUBLE      double
-#define portLONG        long
-#define portSHORT       short
-#define portSTACK_TYPE  uint32_t
-#define portBASE_TYPE   long
-
-typedef portSTACK_TYPE StackType_t;
-typedef long BaseType_t;
-typedef unsigned long UBaseType_t;
-
-#if (configUSE_16_BIT_TICKS == 1)
-    typedef uint16_t TickType_t;
-    #define portMAX_DELAY (TickType_t) 0xFFFF
-#else
-    typedef uint32_t TickType_t;
-    #define portMAX_DELAY (TickType_t) 0xFFFFFFFFF
-
-	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
-	not need to be guarded with a critical section. */
-	#define portTICK_TYPE_IS_ATOMIC 1
-#endif
-
-
-/* Architecture specifics. */
-#define portSTACK_GROWTH    (-1)
-#define portTICK_PERIOD_MS    ((TickType_t) 1000 / configTICK_RATE_HZ)
-#define portBYTE_ALIGNMENT  8
-
-/* Critical section handling. */
-extern void vPortEnterCritical(void);
-extern void vPortExitCritical(void);
-#define portENTER_CRITICAL()		vPortEnterCritical()
-#define portEXIT_CRITICAL()			vPortExitCritical()
-#define portDISABLE_INTERRUPTS()	asm( " CPSID I" )
-#define portENABLE_INTERRUPTS()		asm( " CPSIE I" )
-
-/* Scheduler utilities. */
-#pragma SWI_ALIAS( vPortYield, 0 )
-extern void vPortYield( void );
-#define portYIELD()             	vPortYield()
-#define portSYS_SSIR1_REG			( * ( ( volatile uint32_t * ) 0xFFFFFFB0 ) )
-#define portSYS_SSIR1_SSKEY			( 0x7500UL )
-#define portYIELD_WITHIN_API()		{ portSYS_SSIR1_REG = portSYS_SSIR1_SSKEY;  asm( " DSB " ); asm( " ISB " ); }
-#define portYIELD_FROM_ISR( x )		if( x != pdFALSE ){ portSYS_SSIR1_REG = portSYS_SSIR1_SSKEY;  ( void ) portSYS_SSIR1_REG; }
-
-#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
-	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
-#endif
-
-/* Architecture specific optimisations. */
-#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
-
-	/* Check the configuration. */
-	#if( configMAX_PRIORITIES > 32 )
-		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
-	#endif
-
-	/* Store/clear the ready priorities in a bit map. */
-	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
-	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
-
-	/*-----------------------------------------------------------*/
-
-	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
-
-#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
-
-
-/* Task function macros as described on the FreeRTOS.org WEB site. */
-#define portTASK_FUNCTION(vFunction, pvParameters)       void vFunction(void *pvParameters)
-#define portTASK_FUNCTION_PROTO(vFunction, pvParameters) void vFunction(void *pvParameters)
-
-#endif /* __PORTMACRO_H__ */
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef __PORTMACRO_H__
+#define __PORTMACRO_H__
+
+/*-----------------------------------------------------------
+ * Port specific definitions.
+ *
+ * The settings in this file configure FreeRTOS correctly for the
+ * given hardware and compiler.
+ *
+ * These settings should not be altered.
+ *-----------------------------------------------------------
+ */
+
+/* Type definitions. */
+#define portCHAR        char
+#define portFLOAT       float
+#define portDOUBLE      double
+#define portLONG        long
+#define portSHORT       short
+#define portSTACK_TYPE  uint32_t
+#define portBASE_TYPE   long
+
+typedef portSTACK_TYPE StackType_t;
+typedef long BaseType_t;
+typedef unsigned long UBaseType_t;
+
+#if (configUSE_16_BIT_TICKS == 1)
+    typedef uint16_t TickType_t;
+    #define portMAX_DELAY (TickType_t) 0xFFFF
+#else
+    typedef uint32_t TickType_t;
+    #define portMAX_DELAY (TickType_t) 0xFFFFFFFFF
+
+	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
+	not need to be guarded with a critical section. */
+	#define portTICK_TYPE_IS_ATOMIC 1
+#endif
+
+
+/* Architecture specifics. */
+#define portSTACK_GROWTH    (-1)
+#define portTICK_PERIOD_MS    ((TickType_t) 1000 / configTICK_RATE_HZ)
+#define portBYTE_ALIGNMENT  8
+
+/* Critical section handling. */
+extern void vPortEnterCritical(void);
+extern void vPortExitCritical(void);
+#define portENTER_CRITICAL()		vPortEnterCritical()
+#define portEXIT_CRITICAL()			vPortExitCritical()
+#define portDISABLE_INTERRUPTS()	asm( " CPSID I" )
+#define portENABLE_INTERRUPTS()		asm( " CPSIE I" )
+
+/* Scheduler utilities. */
+#pragma SWI_ALIAS( vPortYield, 0 )
+extern void vPortYield( void );
+#define portYIELD()             	vPortYield()
+#define portSYS_SSIR1_REG			( * ( ( volatile uint32_t * ) 0xFFFFFFB0 ) )
+#define portSYS_SSIR1_SSKEY			( 0x7500UL )
+#define portYIELD_WITHIN_API()		{ portSYS_SSIR1_REG = portSYS_SSIR1_SSKEY;  asm( " DSB " ); asm( " ISB " ); }
+#define portYIELD_FROM_ISR( x )		if( x != pdFALSE ){ portSYS_SSIR1_REG = portSYS_SSIR1_SSKEY;  ( void ) portSYS_SSIR1_REG; }
+
+#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
+	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
+#endif
+
+/* Architecture specific optimisations. */
+#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
+
+	/* Check the configuration. */
+	#if( configMAX_PRIORITIES > 32 )
+		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
+	#endif
+
+	/* Store/clear the ready priorities in a bit map. */
+	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
+	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
+
+	/*-----------------------------------------------------------*/
+
+	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
+
+#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
+
+
+/* Task function macros as described on the FreeRTOS.org WEB site. */
+#define portTASK_FUNCTION(vFunction, pvParameters)       void vFunction(void *pvParameters)
+#define portTASK_FUNCTION_PROTO(vFunction, pvParameters) void vFunction(void *pvParameters)
+
+#endif /* __PORTMACRO_H__ */
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/projdefs.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/projdefs.h
index 27337a8..d4aa198 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/projdefs.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/projdefs.h	
@@ -1,124 +1,124 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-#ifndef PROJDEFS_H
-#define PROJDEFS_H
-
-/*
- * Defines the prototype to which task functions must conform.  Defined in this
- * file to ensure the type is known before portable.h is included.
- */
-typedef void (*TaskFunction_t)( void * );
-
-/* Converts a time in milliseconds to a time in ticks.  This macro can be
-overridden by a macro of the same name defined in FreeRTOSConfig.h in case the
-definition here is not suitable for your application. */
-#ifndef pdMS_TO_TICKS
-	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
-#endif
-
-#define pdFALSE			( ( BaseType_t ) 0 )
-#define pdTRUE			( ( BaseType_t ) 1 )
-
-#define pdPASS			( pdTRUE )
-#define pdFAIL			( pdFALSE )
-#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
-#define errQUEUE_FULL	( ( BaseType_t ) 0 )
-
-/* FreeRTOS error definitions. */
-#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
-#define errQUEUE_BLOCKED						( -4 )
-#define errQUEUE_YIELD							( -5 )
-
-/* Macros used for basic data corruption checks. */
-#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
-	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
-#endif
-
-#if( configUSE_16_BIT_TICKS == 1 )
-	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
-#else
-	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
-#endif
-
-/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
-itself. */
-#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
-#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
-#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
-#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
-#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
-#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
-#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
-#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
-#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
-#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
-#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
-#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
-#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
-#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
-#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
-#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
-#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
-#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
-#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
-#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
-#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
-#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
-#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
-#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
-#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
-#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
-#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
-#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
-#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
-#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
-#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
-#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
-#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
-#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
-#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
-#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
-#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
-#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
-#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
-#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
-
-/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
-itself. */
-#define pdFREERTOS_LITTLE_ENDIAN		0
-#define pdFREERTOS_BIG_ENDIAN			1
-
-/* Re-defining endian values for generic naming. */
-#define pdLITTLE_ENDIAN					pdFREERTOS_LITTLE_ENDIAN
-#define pdBIG_ENDIAN					pdFREERTOS_BIG_ENDIAN
-
-
-#endif /* PROJDEFS_H */
-
-
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+#ifndef PROJDEFS_H
+#define PROJDEFS_H
+
+/*
+ * Defines the prototype to which task functions must conform.  Defined in this
+ * file to ensure the type is known before portable.h is included.
+ */
+typedef void (*TaskFunction_t)( void * );
+
+/* Converts a time in milliseconds to a time in ticks.  This macro can be
+overridden by a macro of the same name defined in FreeRTOSConfig.h in case the
+definition here is not suitable for your application. */
+#ifndef pdMS_TO_TICKS
+	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
+#endif
+
+#define pdFALSE			( ( BaseType_t ) 0 )
+#define pdTRUE			( ( BaseType_t ) 1 )
+
+#define pdPASS			( pdTRUE )
+#define pdFAIL			( pdFALSE )
+#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
+#define errQUEUE_FULL	( ( BaseType_t ) 0 )
+
+/* FreeRTOS error definitions. */
+#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
+#define errQUEUE_BLOCKED						( -4 )
+#define errQUEUE_YIELD							( -5 )
+
+/* Macros used for basic data corruption checks. */
+#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
+	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
+#endif
+
+#if( configUSE_16_BIT_TICKS == 1 )
+	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
+#else
+	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
+#endif
+
+/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
+itself. */
+#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
+#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
+#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
+#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
+#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
+#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
+#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
+#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
+#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
+#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
+#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
+#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
+#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
+#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
+#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
+#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
+#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
+#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
+#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
+#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
+#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
+#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
+#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
+#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
+#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
+#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
+#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
+#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
+#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
+#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
+#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
+#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
+#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
+#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
+#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
+#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
+#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
+#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
+#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
+#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
+
+/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
+itself. */
+#define pdFREERTOS_LITTLE_ENDIAN		0
+#define pdFREERTOS_BIG_ENDIAN			1
+
+/* Re-defining endian values for generic naming. */
+#define pdLITTLE_ENDIAN					pdFREERTOS_LITTLE_ENDIAN
+#define pdBIG_ENDIAN					pdFREERTOS_BIG_ENDIAN
+
+
+#endif /* PROJDEFS_H */
+
+
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/task.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/task.h
index d0ee068..df7ce95 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/task.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/freertos/task.h	
@@ -1,2338 +1,2338 @@
-/*
- * FreeRTOS Kernel V10.0.1
- * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * http://www.FreeRTOS.org
- * http://aws.amazon.com/freertos
- *
- * 1 tab == 4 spaces!
- */
-
-
-#ifndef INC_TASK_H
-#define INC_TASK_H
-
-#ifndef INC_FREERTOS_H
-	#error "include FreeRTOS.h must appear in source files before include task.h"
-#endif
-
-#include "list.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------
- * MACROS AND DEFINITIONS
- *----------------------------------------------------------*/
-
-#define tskKERNEL_VERSION_NUMBER "V10.0.1"
-#define tskKERNEL_VERSION_MAJOR 10
-#define tskKERNEL_VERSION_MINOR 0
-#define tskKERNEL_VERSION_BUILD 1
-
-/**
- * task. h
- *
- * Type by which tasks are referenced.  For example, a call to xTaskCreate
- * returns (via a pointer parameter) an TaskHandle_t variable that can then
- * be used as a parameter to vTaskDelete to delete the task.
- *
- * \defgroup TaskHandle_t TaskHandle_t
- * \ingroup Tasks
- */
-typedef void * TaskHandle_t;
-
-/*
- * Defines the prototype to which the application task hook function must
- * conform.
- */
-typedef BaseType_t (*TaskHookFunction_t)( void * );
-
-/* Task states returned by eTaskGetState. */
-typedef enum
-{
-	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
-	eReady,			/* The task being queried is in a read or pending ready list. */
-	eBlocked,		/* The task being queried is in the Blocked state. */
-	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
-	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
-	eInvalid			/* Used as an 'invalid state' value. */
-} eTaskState;
-
-/* Actions that can be performed when vTaskNotify() is called. */
-typedef enum
-{
-	eNoAction = 0,				/* Notify the task without updating its notify value. */
-	eSetBits,					/* Set bits in the task's notification value. */
-	eIncrement,					/* Increment the task's notification value. */
-	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
-	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
-} eNotifyAction;
-
-/*
- * Used internally only.
- */
-typedef struct xTIME_OUT
-{
-	BaseType_t xOverflowCount;
-	TickType_t xTimeOnEntering;
-} TimeOut_t;
-
-/*
- * Defines the memory ranges allocated to the task when an MPU is used.
- */
-typedef struct xMEMORY_REGION
-{
-	void *pvBaseAddress;
-	uint32_t ulLengthInBytes;
-	uint32_t ulParameters;
-} MemoryRegion_t;
-
-/*
- * Parameters required to create an MPU protected task.
- */
-typedef struct xTASK_PARAMETERS
-{
-	TaskFunction_t pvTaskCode;
-	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	uint16_t usStackDepth;
-	void *pvParameters;
-	UBaseType_t uxPriority;
-	StackType_t *puxStackBuffer;
-	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
-	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-		StaticTask_t * const pxTaskBuffer;
-	#endif
-} TaskParameters_t;
-
-/* Used with the uxTaskGetSystemState() function to return the state of each task
-in the system. */
-typedef struct xTASK_STATUS
-{
-	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
-	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-	UBaseType_t xTaskNumber;		/* A number unique to the task. */
-	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
-	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
-	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
-	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
-	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
-	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
-} TaskStatus_t;
-
-/* Possible return values for eTaskConfirmSleepModeStatus(). */
-typedef enum
-{
-	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
-	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
-	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
-} eSleepModeStatus;
-
-/**
- * Defines the priority used by the idle task.  This must not be modified.
- *
- * \ingroup TaskUtils
- */
-#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
-
-/**
- * task. h
- *
- * Macro for forcing a context switch.
- *
- * \defgroup taskYIELD taskYIELD
- * \ingroup SchedulerControl
- */
-#define taskYIELD()					portYIELD()
-
-/**
- * task. h
- *
- * Macro to mark the start of a critical code region.  Preemptive context
- * switches cannot occur when in a critical region.
- *
- * NOTE: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- *
- * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
- * \ingroup SchedulerControl
- */
-#define taskENTER_CRITICAL()		portENTER_CRITICAL()
-#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
-
-/**
- * task. h
- *
- * Macro to mark the end of a critical code region.  Preemptive context
- * switches cannot occur when in a critical region.
- *
- * NOTE: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- *
- * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
- * \ingroup SchedulerControl
- */
-#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
-#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
-/**
- * task. h
- *
- * Macro to disable all maskable interrupts.
- *
- * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
- * \ingroup SchedulerControl
- */
-#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
-
-/**
- * task. h
- *
- * Macro to enable microcontroller interrupts.
- *
- * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
- * \ingroup SchedulerControl
- */
-#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
-
-/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
-0 to generate more optimal code when configASSERT() is defined as the constant
-is used in assert() statements. */
-#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
-#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
-#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
-
-
-/*-----------------------------------------------------------
- * TASK CREATION API
- *----------------------------------------------------------*/
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreate(
-							  TaskFunction_t pvTaskCode,
-							  const char * const pcName,
-							  configSTACK_DEPTH_TYPE usStackDepth,
-							  void *pvParameters,
-							  UBaseType_t uxPriority,
-							  TaskHandle_t *pvCreatedTask
-						  );</pre>
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreate() then both blocks of memory are automatically dynamically
- * allocated inside the xTaskCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a task is created using
- * xTaskCreateStatic() then the application writer must provide the required
- * memory.  xTaskCreateStatic() therefore allows a task to be created without
- * using any dynamic memory allocation.
- *
- * See xTaskCreateStatic() for a version that does not use any dynamic memory
- * allocation.
- *
- * xTaskCreate() can only be used to create a task that has unrestricted
- * access to the entire microcontroller memory map.  Systems that include MPU
- * support can alternatively create an MPU constrained task using
- * xTaskCreateRestricted().
- *
- * @param pvTaskCode Pointer to the task entry function.  Tasks
- * must be implemented to never return (i.e. continuous loop).
- *
- * @param pcName A descriptive name for the task.  This is mainly used to
- * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
- * is 16.
- *
- * @param usStackDepth The size of the task stack specified as the number of
- * variables the stack can hold - not the number of bytes.  For example, if
- * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
- * will be allocated for stack storage.
- *
- * @param pvParameters Pointer that will be used as the parameter for the task
- * being created.
- *
- * @param uxPriority The priority at which the task should run.  Systems that
- * include MPU support can optionally create tasks in a privileged (system)
- * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
- * example, to create a privileged task at priority 2 the uxPriority parameter
- * should be set to ( 2 | portPRIVILEGE_BIT ).
- *
- * @param pvCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
- // Task to be created.
- void vTaskCode( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-	 }
- }
-
- // Function that creates a task.
- void vOtherFunction( void )
- {
- static uint8_t ucParameterToPass;
- TaskHandle_t xHandle = NULL;
-
-	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
-	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
-	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
-	 // the new task attempts to access it.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
-     configASSERT( xHandle );
-
-	 // Use the handle to delete the task.
-     if( xHandle != NULL )
-     {
-	     vTaskDelete( xHandle );
-     }
- }
-   </pre>
- * \defgroup xTaskCreate xTaskCreate
- * \ingroup Tasks
- */
-#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
-	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
-							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-							const configSTACK_DEPTH_TYPE usStackDepth,
-							void * const pvParameters,
-							UBaseType_t uxPriority,
-							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
-								 const char * const pcName,
-								 uint32_t ulStackDepth,
-								 void *pvParameters,
-								 UBaseType_t uxPriority,
-								 StackType_t *pxStackBuffer,
-								 StaticTask_t *pxTaskBuffer );</pre>
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreate() then both blocks of memory are automatically dynamically
- * allocated inside the xTaskCreate() function.  (see
- * http://www.freertos.org/a00111.html).  If a task is created using
- * xTaskCreateStatic() then the application writer must provide the required
- * memory.  xTaskCreateStatic() therefore allows a task to be created without
- * using any dynamic memory allocation.
- *
- * @param pvTaskCode Pointer to the task entry function.  Tasks
- * must be implemented to never return (i.e. continuous loop).
- *
- * @param pcName A descriptive name for the task.  This is mainly used to
- * facilitate debugging.  The maximum length of the string is defined by
- * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
- *
- * @param ulStackDepth The size of the task stack specified as the number of
- * variables the stack can hold - not the number of bytes.  For example, if
- * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
- * will be allocated for stack storage.
- *
- * @param pvParameters Pointer that will be used as the parameter for the task
- * being created.
- *
- * @param uxPriority The priority at which the task will run.
- *
- * @param pxStackBuffer Must point to a StackType_t array that has at least
- * ulStackDepth indexes - the array will then be used as the task's stack,
- * removing the need for the stack to be allocated dynamically.
- *
- * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
- * then be used to hold the task's data structures, removing the need for the
- * memory to be allocated dynamically.
- *
- * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
- * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
- * are NULL then the task will not be created and
- * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
- *
- * Example usage:
-   <pre>
-
-    // Dimensions the buffer that the task being created will use as its stack.
-    // NOTE:  This is the number of words the stack will hold, not the number of
-    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
-    // then 400 bytes (100 * 32-bits) will be allocated.
-    #define STACK_SIZE 200
-
-    // Structure that will hold the TCB of the task being created.
-    StaticTask_t xTaskBuffer;
-
-    // Buffer that the task being created will use as its stack.  Note this is
-    // an array of StackType_t variables.  The size of StackType_t is dependent on
-    // the RTOS port.
-    StackType_t xStack[ STACK_SIZE ];
-
-    // Function that implements the task being created.
-    void vTaskCode( void * pvParameters )
-    {
-        // The parameter value is expected to be 1 as 1 is passed in the
-        // pvParameters value in the call to xTaskCreateStatic().
-        configASSERT( ( uint32_t ) pvParameters == 1UL );
-
-        for( ;; )
-        {
-            // Task code goes here.
-        }
-    }
-
-    // Function that creates a task.
-    void vOtherFunction( void )
-    {
-        TaskHandle_t xHandle = NULL;
-
-        // Create the task without using any dynamic memory allocation.
-        xHandle = xTaskCreateStatic(
-                      vTaskCode,       // Function that implements the task.
-                      "NAME",          // Text name for the task.
-                      STACK_SIZE,      // Stack size in words, not bytes.
-                      ( void * ) 1,    // Parameter passed into the task.
-                      tskIDLE_PRIORITY,// Priority at which the task is created.
-                      xStack,          // Array to use as the task's stack.
-                      &xTaskBuffer );  // Variable to hold the task's data structure.
-
-        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
-        // been created, and xHandle will be the task's handle.  Use the handle
-        // to suspend the task.
-        vTaskSuspend( xHandle );
-    }
-   </pre>
- * \defgroup xTaskCreateStatic xTaskCreateStatic
- * \ingroup Tasks
- */
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
-									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-									const uint32_t ulStackDepth,
-									void * const pvParameters,
-									UBaseType_t uxPriority,
-									StackType_t * const puxStackBuffer,
-									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
-#endif /* configSUPPORT_STATIC_ALLOCATION */
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
- *
- * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
- *
- * xTaskCreateRestricted() should only be used in systems that include an MPU
- * implementation.
- *
- * Create a new task and add it to the list of tasks that are ready to run.
- * The function parameters define the memory regions and associated access
- * permissions allocated to the task.
- *
- * See xTaskCreateRestrictedStatic() for a version that does not use any
- * dynamic memory allocation.
- *
- * @param pxTaskDefinition Pointer to a structure that contains a member
- * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
- * documentation) plus an optional stack buffer and the memory region
- * definitions.
- *
- * @param pxCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
-// Create an TaskParameters_t structure that defines the task to be created.
-static const TaskParameters_t xCheckTaskParameters =
-{
-	vATask,		// pvTaskCode - the function that implements the task.
-	"ATask",	// pcName - just a text name for the task to assist debugging.
-	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
-	NULL,		// pvParameters - passed into the task function as the function parameters.
-	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
-	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
-
-	// xRegions - Allocate up to three separate memory regions for access by
-	// the task, with appropriate access permissions.  Different processors have
-	// different memory alignment requirements - refer to the FreeRTOS documentation
-	// for full information.
-	{
-		// Base address					Length	Parameters
-        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
-        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
-        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
-	}
-};
-
-int main( void )
-{
-TaskHandle_t xHandle;
-
-	// Create a task from the const structure defined above.  The task handle
-	// is requested (the second parameter is not NULL) but in this case just for
-	// demonstration purposes as its not actually used.
-	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
-
-	// Start the scheduler.
-	vTaskStartScheduler();
-
-	// Will only get here if there was insufficient memory to create the idle
-	// and/or timer task.
-	for( ;; );
-}
-   </pre>
- * \defgroup xTaskCreateRestricted xTaskCreateRestricted
- * \ingroup Tasks
- */
-#if( portUSING_MPU_WRAPPERS == 1 )
-	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
- *
- * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
- *
- * xTaskCreateRestrictedStatic() should only be used in systems that include an
- * MPU implementation.
- *
- * Internally, within the FreeRTOS implementation, tasks use two blocks of
- * memory.  The first block is used to hold the task's data structures.  The
- * second block is used by the task as its stack.  If a task is created using
- * xTaskCreateRestricted() then the stack is provided by the application writer,
- * and the memory used to hold the task's data structure is automatically
- * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
- * is created using xTaskCreateRestrictedStatic() then the application writer
- * must provide the memory used to hold the task's data structures too.
- * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
- * created without using any dynamic memory allocation.
- *
- * @param pxTaskDefinition Pointer to a structure that contains a member
- * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
- * documentation) plus an optional stack buffer and the memory region
- * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
- * contains an additional member, which is used to point to a variable of type
- * StaticTask_t - which is then used to hold the task's data structure.
- *
- * @param pxCreatedTask Used to pass back a handle by which the created task
- * can be referenced.
- *
- * @return pdPASS if the task was successfully created and added to a ready
- * list, otherwise an error code defined in the file projdefs.h
- *
- * Example usage:
-   <pre>
-// Create an TaskParameters_t structure that defines the task to be created.
-// The StaticTask_t variable is only included in the structure when
-// configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
-// be used to force the variable into the RTOS kernel's privileged data area.
-static PRIVILEGED_DATA StaticTask_t xTaskBuffer;
-static const TaskParameters_t xCheckTaskParameters =
-{
-	vATask,		// pvTaskCode - the function that implements the task.
-	"ATask",	// pcName - just a text name for the task to assist debugging.
-	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
-	NULL,		// pvParameters - passed into the task function as the function parameters.
-	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
-	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
-
-	// xRegions - Allocate up to three separate memory regions for access by
-	// the task, with appropriate access permissions.  Different processors have
-	// different memory alignment requirements - refer to the FreeRTOS documentation
-	// for full information.
-	{
-		// Base address					Length	Parameters
-        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
-        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
-        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
-	}
-
-	&xTaskBuffer; // Holds the task's data structure.
-};
-
-int main( void )
-{
-TaskHandle_t xHandle;
-
-	// Create a task from the const structure defined above.  The task handle
-	// is requested (the second parameter is not NULL) but in this case just for
-	// demonstration purposes as its not actually used.
-	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
-
-	// Start the scheduler.
-	vTaskStartScheduler();
-
-	// Will only get here if there was insufficient memory to create the idle
-	// and/or timer task.
-	for( ;; );
-}
-   </pre>
- * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
- * \ingroup Tasks
- */
-#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
-	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
-#endif
-
-/**
- * task. h
- *<pre>
- void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
- *
- * Memory regions are assigned to a restricted task when the task is created by
- * a call to xTaskCreateRestricted().  These regions can be redefined using
- * vTaskAllocateMPURegions().
- *
- * @param xTask The handle of the task being updated.
- *
- * @param xRegions A pointer to an MemoryRegion_t structure that contains the
- * new memory region definitions.
- *
- * Example usage:
-   <pre>
-// Define an array of MemoryRegion_t structures that configures an MPU region
-// allowing read/write access for 1024 bytes starting at the beginning of the
-// ucOneKByte array.  The other two of the maximum 3 definable regions are
-// unused so set to zero.
-static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
-{
-	// Base address		Length		Parameters
-	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
-	{ 0,				0,			0 },
-	{ 0,				0,			0 }
-};
-
-void vATask( void *pvParameters )
-{
-	// This task was created such that it has access to certain regions of
-	// memory as defined by the MPU configuration.  At some point it is
-	// desired that these MPU regions are replaced with that defined in the
-	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
-	// for this purpose.  NULL is used as the task handle to indicate that this
-	// function should modify the MPU regions of the calling task.
-	vTaskAllocateMPURegions( NULL, xAltRegions );
-
-	// Now the task can continue its function, but from this point on can only
-	// access its stack and the ucOneKByte array (unless any other statically
-	// defined or shared regions have been declared elsewhere).
-}
-   </pre>
- * \defgroup xTaskCreateRestricted xTaskCreateRestricted
- * \ingroup Tasks
- */
-void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Remove a task from the RTOS real time kernel's management.  The task being
- * deleted will be removed from all ready, blocked, suspended and event lists.
- *
- * NOTE:  The idle task is responsible for freeing the kernel allocated
- * memory from tasks that have been deleted.  It is therefore important that
- * the idle task is not starved of microcontroller processing time if your
- * application makes any calls to vTaskDelete ().  Memory allocated by the
- * task code is not automatically freed, and should be freed before the task
- * is deleted.
- *
- * See the demo application file death.c for sample code that utilises
- * vTaskDelete ().
- *
- * @param xTask The handle of the task to be deleted.  Passing NULL will
- * cause the calling task to be deleted.
- *
- * Example usage:
-   <pre>
- void vOtherFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create the task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // Use the handle to delete the task.
-	 vTaskDelete( xHandle );
- }
-   </pre>
- * \defgroup vTaskDelete vTaskDelete
- * \ingroup Tasks
- */
-void vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * TASK CONTROL API
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
- *
- * Delay a task for a given number of ticks.  The actual time that the
- * task remains blocked depends on the tick rate.  The constant
- * portTICK_PERIOD_MS can be used to calculate real time from the tick
- * rate - with the resolution of one tick period.
- *
- * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- *
- * vTaskDelay() specifies a time at which the task wishes to unblock relative to
- * the time at which vTaskDelay() is called.  For example, specifying a block
- * period of 100 ticks will cause the task to unblock 100 ticks after
- * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
- * of controlling the frequency of a periodic task as the path taken through the
- * code, as well as other task and interrupt activity, will effect the frequency
- * at which vTaskDelay() gets called and therefore the time at which the task
- * next executes.  See vTaskDelayUntil() for an alternative API function designed
- * to facilitate fixed frequency execution.  It does this by specifying an
- * absolute time (rather than a relative time) at which the calling task should
- * unblock.
- *
- * @param xTicksToDelay The amount of time, in tick periods, that
- * the calling task should block.
- *
- * Example usage:
-
- void vTaskFunction( void * pvParameters )
- {
- // Block for 500ms.
- const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
-
-	 for( ;; )
-	 {
-		 // Simply toggle the LED every 500ms, blocking between each toggle.
-		 vToggleLED();
-		 vTaskDelay( xDelay );
-	 }
- }
-
- * \defgroup vTaskDelay vTaskDelay
- * \ingroup TaskCtrl
- */
-void vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
- *
- * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Delay a task until a specified time.  This function can be used by periodic
- * tasks to ensure a constant execution frequency.
- *
- * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
- * cause a task to block for the specified number of ticks from the time vTaskDelay () is
- * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
- * execution frequency as the time between a task starting to execute and that task
- * calling vTaskDelay () may not be fixed [the task may take a different path though the
- * code between calls, or may get interrupted or preempted a different number of times
- * each time it executes].
- *
- * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
- * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
- * unblock.
- *
- * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
- * rate - with the resolution of one tick period.
- *
- * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
- * task was last unblocked.  The variable must be initialised with the current time
- * prior to its first use (see the example below).  Following this the variable is
- * automatically updated within vTaskDelayUntil ().
- *
- * @param xTimeIncrement The cycle time period.  The task will be unblocked at
- * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
- * same xTimeIncrement parameter value will cause the task to execute with
- * a fixed interface period.
- *
- * Example usage:
-   <pre>
- // Perform an action every 10 ticks.
- void vTaskFunction( void * pvParameters )
- {
- TickType_t xLastWakeTime;
- const TickType_t xFrequency = 10;
-
-	 // Initialise the xLastWakeTime variable with the current time.
-	 xLastWakeTime = xTaskGetTickCount ();
-	 for( ;; )
-	 {
-		 // Wait for the next cycle.
-		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
-
-		 // Perform action here.
-	 }
- }
-   </pre>
- * \defgroup vTaskDelayUntil vTaskDelayUntil
- * \ingroup TaskCtrl
- */
-void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
- * function to be available.
- *
- * A task will enter the Blocked state when it is waiting for an event.  The
- * event it is waiting for can be a temporal event (waiting for a time), such
- * as when vTaskDelay() is called, or an event on an object, such as when
- * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
- * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
- * task will leave the Blocked state, and return from whichever function call
- * placed the task into the Blocked state.
- *
- * @param xTask The handle of the task to remove from the Blocked state.
- *
- * @return If the task referenced by xTask was not in the Blocked state then
- * pdFAIL is returned.  Otherwise pdPASS is returned.
- *
- * \defgroup xTaskAbortDelay xTaskAbortDelay
- * \ingroup TaskCtrl
- */
-BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Obtain the priority of any task.
- *
- * @param xTask Handle of the task to be queried.  Passing a NULL
- * handle results in the priority of the calling task being returned.
- *
- * @return The priority of xTask.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to obtain the priority of the created task.
-	 // It was created with tskIDLE_PRIORITY, but may have changed
-	 // it itself.
-	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
-	 {
-		 // The task has changed it's priority.
-	 }
-
-	 // ...
-
-	 // Is our priority higher than the created task?
-	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
-	 {
-		 // Our priority (obtained using NULL handle) is higher.
-	 }
- }
-   </pre>
- * \defgroup uxTaskPriorityGet uxTaskPriorityGet
- * \ingroup TaskCtrl
- */
-UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
- *
- * A version of uxTaskPriorityGet() that can be used from an ISR.
- */
-UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
- *
- * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Obtain the state of any task.  States are encoded by the eTaskState
- * enumerated type.
- *
- * @param xTask Handle of the task to be queried.
- *
- * @return The state of xTask at the time the function was called.  Note the
- * state of the task might change between the function being called, and the
- * functions return value being tested by the calling task.
- */
-eTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
- *
- * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
- * available.  See the configuration section for more information.
- *
- * Populates a TaskStatus_t structure with information about a task.
- *
- * @param xTask Handle of the task being queried.  If xTask is NULL then
- * information will be returned about the calling task.
- *
- * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
- * filled with information about the task referenced by the handle passed using
- * the xTask parameter.
- *
- * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
- * the stack high water mark of the task being queried.  Calculating the stack
- * high water mark takes a relatively long time, and can make the system
- * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
- * allow the high water mark checking to be skipped.  The high watermark value
- * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
- * not set to pdFALSE;
- *
- * @param eState The TaskStatus_t structure contains a member to report the
- * state of the task being queried.  Obtaining the task state is not as fast as
- * a simple assignment - so the eState parameter is provided to allow the state
- * information to be omitted from the TaskStatus_t structure.  To obtain state
- * information then set eState to eInvalid - otherwise the value passed in
- * eState will be reported as the task state in the TaskStatus_t structure.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
- TaskStatus_t xTaskDetails;
-
-    // Obtain the handle of a task from its name.
-    xHandle = xTaskGetHandle( "Task_Name" );
-
-    // Check the handle is not NULL.
-    configASSERT( xHandle );
-
-    // Use the handle to obtain further information about the task.
-    vTaskGetInfo( xHandle,
-                  &xTaskDetails,
-                  pdTRUE, // Include the high water mark in xTaskDetails.
-                  eInvalid ); // Include the task state in xTaskDetails.
- }
-   </pre>
- * \defgroup vTaskGetInfo vTaskGetInfo
- * \ingroup TaskCtrl
- */
-void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
- *
- * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Set the priority of any task.
- *
- * A context switch will occur before the function returns if the priority
- * being set is higher than the currently executing task.
- *
- * @param xTask Handle to the task for which the priority is being set.
- * Passing a NULL handle results in the priority of the calling task being set.
- *
- * @param uxNewPriority The priority to which the task will be set.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to raise the priority of the created task.
-	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
-
-	 // ...
-
-	 // Use a NULL handle to raise our priority to the same value.
-	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
- }
-   </pre>
- * \defgroup vTaskPrioritySet vTaskPrioritySet
- * \ingroup TaskCtrl
- */
-void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
- *
- * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Suspend any task.  When suspended a task will never get any microcontroller
- * processing time, no matter what its priority.
- *
- * Calls to vTaskSuspend are not accumulative -
- * i.e. calling vTaskSuspend () twice on the same task still only requires one
- * call to vTaskResume () to ready the suspended task.
- *
- * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
- * handle will cause the calling task to be suspended.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to suspend the created task.
-	 vTaskSuspend( xHandle );
-
-	 // ...
-
-	 // The created task will not run during this period, unless
-	 // another task calls vTaskResume( xHandle ).
-
-	 //...
-
-
-	 // Suspend ourselves.
-	 vTaskSuspend( NULL );
-
-	 // We cannot get here unless another task calls vTaskResume
-	 // with our handle as the parameter.
- }
-   </pre>
- * \defgroup vTaskSuspend vTaskSuspend
- * \ingroup TaskCtrl
- */
-void vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
- *
- * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
- * See the configuration section for more information.
- *
- * Resumes a suspended task.
- *
- * A task that has been suspended by one or more calls to vTaskSuspend ()
- * will be made available for running again by a single call to
- * vTaskResume ().
- *
- * @param xTaskToResume Handle to the task being readied.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
- TaskHandle_t xHandle;
-
-	 // Create a task, storing the handle.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
-
-	 // ...
-
-	 // Use the handle to suspend the created task.
-	 vTaskSuspend( xHandle );
-
-	 // ...
-
-	 // The created task will not run during this period, unless
-	 // another task calls vTaskResume( xHandle ).
-
-	 //...
-
-
-	 // Resume the suspended task ourselves.
-	 vTaskResume( xHandle );
-
-	 // The created task will once again get microcontroller processing
-	 // time in accordance with its priority within the system.
- }
-   </pre>
- * \defgroup vTaskResume vTaskResume
- * \ingroup TaskCtrl
- */
-void vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
- *
- * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
- * available.  See the configuration section for more information.
- *
- * An implementation of vTaskResume() that can be called from within an ISR.
- *
- * A task that has been suspended by one or more calls to vTaskSuspend ()
- * will be made available for running again by a single call to
- * xTaskResumeFromISR ().
- *
- * xTaskResumeFromISR() should not be used to synchronise a task with an
- * interrupt if there is a chance that the interrupt could arrive prior to the
- * task being suspended - as this can lead to interrupts being missed. Use of a
- * semaphore as a synchronisation mechanism would avoid this eventuality.
- *
- * @param xTaskToResume Handle to the task being readied.
- *
- * @return pdTRUE if resuming the task should result in a context switch,
- * otherwise pdFALSE. This is used by the ISR to determine if a context switch
- * may be required following the ISR.
- *
- * \defgroup vTaskResumeFromISR vTaskResumeFromISR
- * \ingroup TaskCtrl
- */
-BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * SCHEDULER CONTROL
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <pre>void vTaskStartScheduler( void );</pre>
- *
- * Starts the real time kernel tick processing.  After calling the kernel
- * has control over which tasks are executed and when.
- *
- * See the demo application file main.c for an example of creating
- * tasks and starting the kernel.
- *
- * Example usage:
-   <pre>
- void vAFunction( void )
- {
-	 // Create at least one task before starting the kernel.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
-
-	 // Start the real time kernel with preemption.
-	 vTaskStartScheduler ();
-
-	 // Will not get here unless a task calls vTaskEndScheduler ()
- }
-   </pre>
- *
- * \defgroup vTaskStartScheduler vTaskStartScheduler
- * \ingroup SchedulerControl
- */
-void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskEndScheduler( void );</pre>
- *
- * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
- * in place of DOS, implements this function.
- *
- * Stops the real time kernel tick.  All created tasks will be automatically
- * deleted and multitasking (either preemptive or cooperative) will
- * stop.  Execution then resumes from the point where vTaskStartScheduler ()
- * was called, as if vTaskStartScheduler () had just returned.
- *
- * See the demo application file main. c in the demo/PC directory for an
- * example that uses vTaskEndScheduler ().
- *
- * vTaskEndScheduler () requires an exit function to be defined within the
- * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
- * performs hardware specific operations such as stopping the kernel tick.
- *
- * vTaskEndScheduler () will cause all of the resources allocated by the
- * kernel to be freed - but will not free resources allocated by application
- * tasks.
- *
- * Example usage:
-   <pre>
- void vTaskCode( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // At some point we want to end the real time kernel processing
-		 // so call ...
-		 vTaskEndScheduler ();
-	 }
- }
-
- void vAFunction( void )
- {
-	 // Create at least one task before starting the kernel.
-	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
-
-	 // Start the real time kernel with preemption.
-	 vTaskStartScheduler ();
-
-	 // Will only get here when the vTaskCode () task has called
-	 // vTaskEndScheduler ().  When we get here we are back to single task
-	 // execution.
- }
-   </pre>
- *
- * \defgroup vTaskEndScheduler vTaskEndScheduler
- * \ingroup SchedulerControl
- */
-void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>void vTaskSuspendAll( void );</pre>
- *
- * Suspends the scheduler without disabling interrupts.  Context switches will
- * not occur while the scheduler is suspended.
- *
- * After calling vTaskSuspendAll () the calling task will continue to execute
- * without risk of being swapped out until a call to xTaskResumeAll () has been
- * made.
- *
- * API functions that have the potential to cause a context switch (for example,
- * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
- * is suspended.
- *
- * Example usage:
-   <pre>
- void vTask1( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // ...
-
-		 // At some point the task wants to perform a long operation during
-		 // which it does not want to get swapped out.  It cannot use
-		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
-		 // operation may cause interrupts to be missed - including the
-		 // ticks.
-
-		 // Prevent the real time kernel swapping out the task.
-		 vTaskSuspendAll ();
-
-		 // Perform the operation here.  There is no need to use critical
-		 // sections as we have all the microcontroller processing time.
-		 // During this time interrupts will still operate and the kernel
-		 // tick count will be maintained.
-
-		 // ...
-
-		 // The operation is complete.  Restart the kernel.
-		 xTaskResumeAll ();
-	 }
- }
-   </pre>
- * \defgroup vTaskSuspendAll vTaskSuspendAll
- * \ingroup SchedulerControl
- */
-void vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <pre>BaseType_t xTaskResumeAll( void );</pre>
- *
- * Resumes scheduler activity after it was suspended by a call to
- * vTaskSuspendAll().
- *
- * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
- * that were previously suspended by a call to vTaskSuspend().
- *
- * @return If resuming the scheduler caused a context switch then pdTRUE is
- *		  returned, otherwise pdFALSE is returned.
- *
- * Example usage:
-   <pre>
- void vTask1( void * pvParameters )
- {
-	 for( ;; )
-	 {
-		 // Task code goes here.
-
-		 // ...
-
-		 // At some point the task wants to perform a long operation during
-		 // which it does not want to get swapped out.  It cannot use
-		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
-		 // operation may cause interrupts to be missed - including the
-		 // ticks.
-
-		 // Prevent the real time kernel swapping out the task.
-		 vTaskSuspendAll ();
-
-		 // Perform the operation here.  There is no need to use critical
-		 // sections as we have all the microcontroller processing time.
-		 // During this time interrupts will still operate and the real
-		 // time kernel tick count will be maintained.
-
-		 // ...
-
-		 // The operation is complete.  Restart the kernel.  We want to force
-		 // a context switch - but there is no point if resuming the scheduler
-		 // caused a context switch already.
-		 if( !xTaskResumeAll () )
-		 {
-			  taskYIELD ();
-		 }
-	 }
- }
-   </pre>
- * \defgroup xTaskResumeAll xTaskResumeAll
- * \ingroup SchedulerControl
- */
-BaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
-
-/*-----------------------------------------------------------
- * TASK UTILITIES
- *----------------------------------------------------------*/
-
-/**
- * task. h
- * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
- *
- * @return The count of ticks since vTaskStartScheduler was called.
- *
- * \defgroup xTaskGetTickCount xTaskGetTickCount
- * \ingroup TaskUtils
- */
-TickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
- *
- * @return The count of ticks since vTaskStartScheduler was called.
- *
- * This is a version of xTaskGetTickCount() that is safe to be called from an
- * ISR - provided that TickType_t is the natural word size of the
- * microcontroller being used or interrupt nesting is either not supported or
- * not being used.
- *
- * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
- * \ingroup TaskUtils
- */
-TickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
- *
- * @return The number of tasks that the real time kernel is currently managing.
- * This includes all ready, blocked and suspended tasks.  A task that
- * has been deleted but not yet freed by the idle task will also be
- * included in the count.
- *
- * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
- * \ingroup TaskUtils
- */
-UBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
- *
- * @return The text (human readable) name of the task referenced by the handle
- * xTaskToQuery.  A task can query its own name by either passing in its own
- * handle, or by setting xTaskToQuery to NULL.
- *
- * \defgroup pcTaskGetName pcTaskGetName
- * \ingroup TaskUtils
- */
-char *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task. h
- * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
- *
- * NOTE:  This function takes a relatively long time to complete and should be
- * used sparingly.
- *
- * @return The handle of the task that has the human readable name pcNameToQuery.
- * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
- * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
- *
- * \defgroup pcTaskGetHandle pcTaskGetHandle
- * \ingroup TaskUtils
- */
-TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task.h
- * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
- *
- * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
- * this function to be available.
- *
- * Returns the high water mark of the stack associated with xTask.  That is,
- * the minimum free stack space there has been (in words, so on a 32 bit machine
- * a value of 1 means 4 bytes) since the task started.  The smaller the returned
- * number the closer the task has come to overflowing its stack.
- *
- * @param xTask Handle of the task associated with the stack to be checked.
- * Set xTask to NULL to check the stack of the calling task.
- *
- * @return The smallest amount of free stack space there has been (in words, so
- * actual spaces on the stack rather than bytes) since the task referenced by
- * xTask was created.
- */
-UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/* When using trace macros it is sometimes necessary to include task.h before
-FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
-so the following two prototypes will cause a compilation error.  This can be
-fixed by simply guarding against the inclusion of these two prototypes unless
-they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
-constant. */
-#ifdef configUSE_APPLICATION_TASK_TAG
-	#if configUSE_APPLICATION_TASK_TAG == 1
-		/**
-		 * task.h
-		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
-		 *
-		 * Sets pxHookFunction to be the task hook function used by the task xTask.
-		 * Passing xTask as NULL has the effect of setting the calling tasks hook
-		 * function.
-		 */
-		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
-
-		/**
-		 * task.h
-		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
-		 *
-		 * Returns the pxHookFunction value assigned to the task xTask.
-		 */
-		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
-#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
-
-#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
-
-	/* Each task contains an array of pointers that is dimensioned by the
-	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
-	kernel does not use the pointers itself, so the application writer can use
-	the pointers for any purpose they wish.  The following two functions are
-	used to set and query a pointer respectively. */
-	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
-	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
-
-#endif
-
-/**
- * task.h
- * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
- *
- * Calls the hook function associated with xTask.  Passing xTask as NULL has
- * the effect of calling the Running tasks (the calling task) hook function.
- *
- * pvParameter is passed to the hook function for the task to interpret as it
- * wants.  The return value is the value returned by the task hook function
- * registered by the user.
- */
-BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
-
-/**
- * xTaskGetIdleTaskHandle() is only available if
- * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
- *
- * Simply returns the handle of the idle task.  It is not valid to call
- * xTaskGetIdleTaskHandle() before the scheduler has been started.
- */
-TaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
-
-/**
- * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
- * uxTaskGetSystemState() to be available.
- *
- * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
- * the system.  TaskStatus_t structures contain, among other things, members
- * for the task handle, task name, task priority, task state, and total amount
- * of run time consumed by the task.  See the TaskStatus_t structure
- * definition in this file for the full member list.
- *
- * NOTE:  This function is intended for debugging use only as its use results in
- * the scheduler remaining suspended for an extended period.
- *
- * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
- * The array must contain at least one TaskStatus_t structure for each task
- * that is under the control of the RTOS.  The number of tasks under the control
- * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
- *
- * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
- * parameter.  The size is specified as the number of indexes in the array, or
- * the number of TaskStatus_t structures contained in the array, not by the
- * number of bytes in the array.
- *
- * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
- * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
- * total run time (as defined by the run time stats clock, see
- * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
- * pulTotalRunTime can be set to NULL to omit the total run time information.
- *
- * @return The number of TaskStatus_t structures that were populated by
- * uxTaskGetSystemState().  This should equal the number returned by the
- * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
- * in the uxArraySize parameter was too small.
- *
- * Example usage:
-   <pre>
-    // This example demonstrates how a human readable table of run time stats
-	// information is generated from raw data provided by uxTaskGetSystemState().
-	// The human readable table is written to pcWriteBuffer
-	void vTaskGetRunTimeStats( char *pcWriteBuffer )
-	{
-	TaskStatus_t *pxTaskStatusArray;
-	volatile UBaseType_t uxArraySize, x;
-	uint32_t ulTotalRunTime, ulStatsAsPercentage;
-
-		// Make sure the write buffer does not contain a string.
-		*pcWriteBuffer = 0x00;
-
-		// Take a snapshot of the number of tasks in case it changes while this
-		// function is executing.
-		uxArraySize = uxTaskGetNumberOfTasks();
-
-		// Allocate a TaskStatus_t structure for each task.  An array could be
-		// allocated statically at compile time.
-		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
-
-		if( pxTaskStatusArray != NULL )
-		{
-			// Generate raw status information about each task.
-			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
-
-			// For percentage calculations.
-			ulTotalRunTime /= 100UL;
-
-			// Avoid divide by zero errors.
-			if( ulTotalRunTime > 0 )
-			{
-				// For each populated position in the pxTaskStatusArray array,
-				// format the raw data as human readable ASCII data
-				for( x = 0; x < uxArraySize; x++ )
-				{
-					// What percentage of the total run time has the task used?
-					// This will always be rounded down to the nearest integer.
-					// ulTotalRunTimeDiv100 has already been divided by 100.
-					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
-
-					if( ulStatsAsPercentage > 0UL )
-					{
-						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
-					}
-					else
-					{
-						// If the percentage is zero here then the task has
-						// consumed less than 1% of the total run time.
-						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
-					}
-
-					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
-				}
-			}
-
-			// The array is no longer needed, free the memory it consumes.
-			vPortFree( pxTaskStatusArray );
-		}
-	}
-	</pre>
- */
-UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
- *
- * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
- * both be defined as 1 for this function to be available.  See the
- * configuration section of the FreeRTOS.org website for more information.
- *
- * NOTE 1: This function will disable interrupts for its duration.  It is
- * not intended for normal application runtime use but as a debug aid.
- *
- * Lists all the current tasks, along with their current state and stack
- * usage high water mark.
- *
- * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
- * suspended ('S').
- *
- * PLEASE NOTE:
- *
- * This function is provided for convenience only, and is used by many of the
- * demo applications.  Do not consider it to be part of the scheduler.
- *
- * vTaskList() calls uxTaskGetSystemState(), then formats part of the
- * uxTaskGetSystemState() output into a human readable table that displays task
- * names, states and stack usage.
- *
- * vTaskList() has a dependency on the sprintf() C library function that might
- * bloat the code size, use a lot of stack, and provide different results on
- * different platforms.  An alternative, tiny, third party, and limited
- * functionality implementation of sprintf() is provided in many of the
- * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
- * printf-stdarg.c does not provide a full snprintf() implementation!).
- *
- * It is recommended that production systems call uxTaskGetSystemState()
- * directly to get access to raw stats data, rather than indirectly through a
- * call to vTaskList().
- *
- * @param pcWriteBuffer A buffer into which the above mentioned details
- * will be written, in ASCII form.  This buffer is assumed to be large
- * enough to contain the generated report.  Approximately 40 bytes per
- * task should be sufficient.
- *
- * \defgroup vTaskList vTaskList
- * \ingroup TaskUtils
- */
-void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task. h
- * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
- *
- * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
- * must both be defined as 1 for this function to be available.  The application
- * must also then provide definitions for
- * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
- * to configure a peripheral timer/counter and return the timers current count
- * value respectively.  The counter should be at least 10 times the frequency of
- * the tick count.
- *
- * NOTE 1: This function will disable interrupts for its duration.  It is
- * not intended for normal application runtime use but as a debug aid.
- *
- * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
- * accumulated execution time being stored for each task.  The resolution
- * of the accumulated time value depends on the frequency of the timer
- * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
- * Calling vTaskGetRunTimeStats() writes the total execution time of each
- * task into a buffer, both as an absolute count value and as a percentage
- * of the total system execution time.
- *
- * NOTE 2:
- *
- * This function is provided for convenience only, and is used by many of the
- * demo applications.  Do not consider it to be part of the scheduler.
- *
- * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
- * uxTaskGetSystemState() output into a human readable table that displays the
- * amount of time each task has spent in the Running state in both absolute and
- * percentage terms.
- *
- * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
- * that might bloat the code size, use a lot of stack, and provide different
- * results on different platforms.  An alternative, tiny, third party, and
- * limited functionality implementation of sprintf() is provided in many of the
- * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
- * printf-stdarg.c does not provide a full snprintf() implementation!).
- *
- * It is recommended that production systems call uxTaskGetSystemState() directly
- * to get access to raw stats data, rather than indirectly through a call to
- * vTaskGetRunTimeStats().
- *
- * @param pcWriteBuffer A buffer into which the execution times will be
- * written, in ASCII form.  This buffer is assumed to be large enough to
- * contain the generated report.  Approximately 40 bytes per task should
- * be sufficient.
- *
- * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
- * \ingroup TaskUtils
- */
-void vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param ulValue Data that can be sent with the notification.  How the data is
- * used depends on the value of the eAction parameter.
- *
- * @param eAction Specifies how the notification updates the task's notification
- * value, if at all.  Valid values for eAction are as follows:
- *
- * eSetBits -
- * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
- * always returns pdPASS in this case.
- *
- * eIncrement -
- * The task's notification value is incremented.  ulValue is not used and
- * xTaskNotify() always returns pdPASS in this case.
- *
- * eSetValueWithOverwrite -
- * The task's notification value is set to the value of ulValue, even if the
- * task being notified had not yet processed the previous notification (the
- * task already had a notification pending).  xTaskNotify() always returns
- * pdPASS in this case.
- *
- * eSetValueWithoutOverwrite -
- * If the task being notified did not already have a notification pending then
- * the task's notification value is set to ulValue and xTaskNotify() will
- * return pdPASS.  If the task being notified already had a notification
- * pending then no action is performed and pdFAIL is returned.
- *
- * eNoAction -
- * The task receives a notification without its notification value being
- * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
- * this case.
- *
- *  pulPreviousNotificationValue -
- *  Can be used to pass out the subject task's notification value before any
- *  bits are modified by the notify function.
- *
- * @return Dependent on the value of eAction.  See the description of the
- * eAction parameter.
- *
- * \defgroup xTaskNotify xTaskNotify
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
-#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
-#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * A version of xTaskNotify() that can be used from an interrupt service routine
- * (ISR).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param ulValue Data that can be sent with the notification.  How the data is
- * used depends on the value of the eAction parameter.
- *
- * @param eAction Specifies how the notification updates the task's notification
- * value, if at all.  Valid values for eAction are as follows:
- *
- * eSetBits -
- * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
- * always returns pdPASS in this case.
- *
- * eIncrement -
- * The task's notification value is incremented.  ulValue is not used and
- * xTaskNotify() always returns pdPASS in this case.
- *
- * eSetValueWithOverwrite -
- * The task's notification value is set to the value of ulValue, even if the
- * task being notified had not yet processed the previous notification (the
- * task already had a notification pending).  xTaskNotify() always returns
- * pdPASS in this case.
- *
- * eSetValueWithoutOverwrite -
- * If the task being notified did not already have a notification pending then
- * the task's notification value is set to ulValue and xTaskNotify() will
- * return pdPASS.  If the task being notified already had a notification
- * pending then no action is performed and pdFAIL is returned.
- *
- * eNoAction -
- * The task receives a notification without its notification value being
- * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
- * this case.
- *
- * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
- * task to which the notification was sent to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently running task.  If
- * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
- * be requested before the interrupt is exited.  How a context switch is
- * requested from an ISR is dependent on the port - see the documentation page
- * for the port in use.
- *
- * @return Dependent on the value of eAction.  See the description of the
- * eAction parameter.
- *
- * \defgroup xTaskNotify xTaskNotify
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
-#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * A notification sent to a task will remain pending until it is cleared by the
- * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
- * already in the Blocked state to wait for a notification when the notification
- * arrives then the task will automatically be removed from the Blocked state
- * (unblocked) and the notification cleared.
- *
- * A task can use xTaskNotifyWait() to [optionally] block to wait for a
- * notification to be pending, or ulTaskNotifyTake() to [optionally] block
- * to wait for its notification value to have a non-zero value.  The task does
- * not consume any CPU time while it is in the Blocked state.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
- * will be cleared in the calling task's notification value before the task
- * checks to see if any notifications are pending, and optionally blocks if no
- * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
- * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
- * the effect of resetting the task's notification value to 0.  Setting
- * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
- *
- * @param ulBitsToClearOnExit If a notification is pending or received before
- * the calling task exits the xTaskNotifyWait() function then the task's
- * notification value (see the xTaskNotify() API function) is passed out using
- * the pulNotificationValue parameter.  Then any bits that are set in
- * ulBitsToClearOnExit will be cleared in the task's notification value (note
- * *pulNotificationValue is set before any bits are cleared).  Setting
- * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
- * (if limits.h is not included) will have the effect of resetting the task's
- * notification value to 0 before the function exits.  Setting
- * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
- * when the function exits (in which case the value passed out in
- * pulNotificationValue will match the task's notification value).
- *
- * @param pulNotificationValue Used to pass the task's notification value out
- * of the function.  Note the value passed out will not be effected by the
- * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait in
- * the Blocked state for a notification to be received, should a notification
- * not already be pending when xTaskNotifyWait() was called.  The task
- * will not consume any processing time while it is in the Blocked state.  This
- * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
- * used to convert a time specified in milliseconds to a time specified in
- * ticks.
- *
- * @return If a notification was received (including notifications that were
- * already pending when xTaskNotifyWait was called) then pdPASS is
- * returned.  Otherwise pdFAIL is returned.
- *
- * \defgroup xTaskNotifyWait xTaskNotifyWait
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
- * to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * xTaskNotifyGive() is a helper macro intended for use when task notifications
- * are used as light weight and faster binary or counting semaphore equivalents.
- * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
- * the equivalent action that instead uses a task notification is
- * xTaskNotifyGive().
- *
- * When task notifications are being used as a binary or counting semaphore
- * equivalent then the task being notified should wait for the notification
- * using the ulTaskNotificationTake() API function rather than the
- * xTaskNotifyWait() API function.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
- * eAction parameter set to eIncrement - so pdPASS is always returned.
- *
- * \defgroup xTaskNotifyGive xTaskNotifyGive
- * \ingroup TaskNotifications
- */
-#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
-
-/**
- * task. h
- * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
- * to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * A version of xTaskNotifyGive() that can be called from an interrupt service
- * routine (ISR).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * vTaskNotifyGiveFromISR() is intended for use when task notifications are
- * used as light weight and faster binary or counting semaphore equivalents.
- * Actual FreeRTOS semaphores are given from an ISR using the
- * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
- * a task notification is vTaskNotifyGiveFromISR().
- *
- * When task notifications are being used as a binary or counting semaphore
- * equivalent then the task being notified should wait for the notification
- * using the ulTaskNotificationTake() API function rather than the
- * xTaskNotifyWait() API function.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
- *
- * @param xTaskToNotify The handle of the task being notified.  The handle to a
- * task can be returned from the xTaskCreate() API function used to create the
- * task, and the handle of the currently running task can be obtained by calling
- * xTaskGetCurrentTaskHandle().
- *
- * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
- * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
- * task to which the notification was sent to leave the Blocked state, and the
- * unblocked task has a priority higher than the currently running task.  If
- * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
- * should be requested before the interrupt is exited.  How a context switch is
- * requested from an ISR is dependent on the port - see the documentation page
- * for the port in use.
- *
- * \defgroup xTaskNotifyWait xTaskNotifyWait
- * \ingroup TaskNotifications
- */
-void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
- *
- * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
- * function to be available.
- *
- * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
- * "notification value", which is a 32-bit unsigned integer (uint32_t).
- *
- * Events can be sent to a task using an intermediary object.  Examples of such
- * objects are queues, semaphores, mutexes and event groups.  Task notifications
- * are a method of sending an event directly to a task without the need for such
- * an intermediary object.
- *
- * A notification sent to a task can optionally perform an action, such as
- * update, overwrite or increment the task's notification value.  In that way
- * task notifications can be used to send data to a task, or be used as light
- * weight and fast binary or counting semaphores.
- *
- * ulTaskNotifyTake() is intended for use when a task notification is used as a
- * faster and lighter weight binary or counting semaphore alternative.  Actual
- * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
- * equivalent action that instead uses a task notification is
- * ulTaskNotifyTake().
- *
- * When a task is using its notification value as a binary or counting semaphore
- * other tasks should send notifications to it using the xTaskNotifyGive()
- * macro, or xTaskNotify() function with the eAction parameter set to
- * eIncrement.
- *
- * ulTaskNotifyTake() can either clear the task's notification value to
- * zero on exit, in which case the notification value acts like a binary
- * semaphore, or decrement the task's notification value on exit, in which case
- * the notification value acts like a counting semaphore.
- *
- * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
- * the task's notification value to be non-zero.  The task does not consume any
- * CPU time while it is in the Blocked state.
- *
- * Where as xTaskNotifyWait() will return when a notification is pending,
- * ulTaskNotifyTake() will return when the task's notification value is
- * not zero.
- *
- * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
- *
- * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
- * notification value is decremented when the function exits.  In this way the
- * notification value acts like a counting semaphore.  If xClearCountOnExit is
- * not pdFALSE then the task's notification value is cleared to zero when the
- * function exits.  In this way the notification value acts like a binary
- * semaphore.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait in
- * the Blocked state for the task's notification value to be greater than zero,
- * should the count not already be greater than zero when
- * ulTaskNotifyTake() was called.  The task will not consume any processing
- * time while it is in the Blocked state.  This is specified in kernel ticks,
- * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
- * specified in milliseconds to a time specified in ticks.
- *
- * @return The task's notification count before it is either cleared to zero or
- * decremented (see the xClearCountOnExit parameter).
- *
- * \defgroup ulTaskNotifyTake ulTaskNotifyTake
- * \ingroup TaskNotifications
- */
-uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/**
- * task. h
- * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
- *
- * If the notification state of the task referenced by the handle xTask is
- * eNotified, then set the task's notification state to eNotWaitingNotification.
- * The task's notification value is not altered.  Set xTask to NULL to clear the
- * notification state of the calling task.
- *
- * @return pdTRUE if the task's notification state was set to
- * eNotWaitingNotification, otherwise pdFALSE.
- * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
- * \ingroup TaskNotifications
- */
-BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
-
-/*-----------------------------------------------------------
- * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
- *----------------------------------------------------------*/
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
- * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
- * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * Called from the real time kernel tick (either preemptive or cooperative),
- * this increments the tick count and checks if any tasks that are blocked
- * for a finite period required removing from a blocked list and placing on
- * a ready list.  If a non-zero value is returned then a context switch is
- * required because either:
- *   + A task was removed from a blocked list because its timeout had expired,
- *     or
- *   + Time slicing is in use and there is a task of equal priority to the
- *     currently running task.
- */
-BaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * Removes the calling task from the ready list and places it both
- * on the list of tasks waiting for a particular event, and the
- * list of delayed tasks.  The task will be removed from both lists
- * and replaced on the ready list should either the event occur (and
- * there be no higher priority tasks waiting on the same event) or
- * the delay period expires.
- *
- * The 'unordered' version replaces the event list item value with the
- * xItemValue value, and inserts the list item at the end of the list.
- *
- * The 'ordered' version uses the existing event list item value (which is the
- * owning tasks priority) to insert the list item into the event list is task
- * priority order.
- *
- * @param pxEventList The list containing tasks that are blocked waiting
- * for the event to occur.
- *
- * @param xItemValue The item value to use for the event list item when the
- * event list is not ordered by task priority.
- *
- * @param xTicksToWait The maximum amount of time that the task should wait
- * for the event to occur.  This is specified in kernel ticks,the constant
- * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
- * period.
- */
-void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * This function performs nearly the same function as vTaskPlaceOnEventList().
- * The difference being that this function does not permit tasks to block
- * indefinitely, whereas vTaskPlaceOnEventList() does.
- *
- */
-void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
- * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
- *
- * Removes a task from both the specified event list and the list of blocked
- * tasks, and places it on a ready queue.
- *
- * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
- * if either an event occurs to unblock a task, or the block timeout period
- * expires.
- *
- * xTaskRemoveFromEventList() is used when the event list is in task priority
- * order.  It removes the list item from the head of the event list as that will
- * have the highest priority owning task of all the tasks on the event list.
- * vTaskRemoveFromUnorderedEventList() is used when the event list is not
- * ordered and the event list items hold something other than the owning tasks
- * priority.  In this case the event list item value is updated to the value
- * passed in the xItemValue parameter.
- *
- * @return pdTRUE if the task being removed has a higher priority than the task
- * making the call, otherwise pdFALSE.
- */
-BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
-void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
-
-/*
- * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
- * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
- * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
- *
- * Sets the pointer to the current TCB to the TCB of the highest priority task
- * that is ready to run.
- */
-void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
-
-/*
- * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
- * THE EVENT BITS MODULE.
- */
-TickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Return the handle of the calling task.
- */
-TaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Capture the current time status for future reference.
- */
-void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
-
-/*
- * Compare the time status now with that previously captured to see if the
- * timeout has expired.
- */
-BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
-
-/*
- * Shortcut used by the queue implementation to prevent unnecessary call to
- * taskYIELD();
- */
-void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Returns the scheduler state as taskSCHEDULER_RUNNING,
- * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
- */
-BaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
-
-/*
- * Raises the priority of the mutex holder to that of the calling task should
- * the mutex holder have a priority less than the calling task.
- */
-BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
-
-/*
- * Set the priority of a task back to its proper priority in the case that it
- * inherited a higher priority while it was holding a semaphore.
- */
-BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
-
-/*
- * If a higher priority task attempting to obtain a mutex caused a lower
- * priority task to inherit the higher priority task's priority - but the higher
- * priority task then timed out without obtaining the mutex, then the lower
- * priority task will disinherit the priority again - but only down as far as
- * the highest priority task that is still waiting for the mutex (if there were
- * more than one task waiting for the mutex).
- */
-void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
-
-/*
- * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
- */
-UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
-
-/*
- * Set the uxTaskNumber of the task referenced by the xTask parameter to
- * uxHandle.
- */
-void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
-
-/*
- * Only available when configUSE_TICKLESS_IDLE is set to 1.
- * If tickless mode is being used, or a low power mode is implemented, then
- * the tick interrupt will not execute during idle periods.  When this is the
- * case, the tick count value maintained by the scheduler needs to be kept up
- * to date with the actual execution time by being skipped forward by a time
- * equal to the idle period.
- */
-void vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
-
-/*
- * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
- * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
- * specific sleep function to determine if it is ok to proceed with the sleep,
- * and if it is ok to proceed, if it is ok to sleep indefinitely.
- *
- * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
- * called with the scheduler suspended, not from within a critical section.  It
- * is therefore possible for an interrupt to request a context switch between
- * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
- * entered.  eTaskConfirmSleepModeStatus() should be called from a short
- * critical section between the timer being stopped and the sleep mode being
- * entered to ensure it is ok to proceed into the sleep mode.
- */
-eSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
-
-/*
- * For internal use only.  Increment the mutex held count when a mutex is
- * taken and return the handle of the task that has taken the mutex.
- */
-void *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
-
-/*
- * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial
- * section.
- */
-void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* INC_TASK_H */
-
-
-
+/*
+ * FreeRTOS Kernel V10.0.1
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * http://www.FreeRTOS.org
+ * http://aws.amazon.com/freertos
+ *
+ * 1 tab == 4 spaces!
+ */
+
+
+#ifndef INC_TASK_H
+#define INC_TASK_H
+
+#ifndef INC_FREERTOS_H
+	#error "include FreeRTOS.h must appear in source files before include task.h"
+#endif
+
+#include "list.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-----------------------------------------------------------
+ * MACROS AND DEFINITIONS
+ *----------------------------------------------------------*/
+
+#define tskKERNEL_VERSION_NUMBER "V10.0.1"
+#define tskKERNEL_VERSION_MAJOR 10
+#define tskKERNEL_VERSION_MINOR 0
+#define tskKERNEL_VERSION_BUILD 1
+
+/**
+ * task. h
+ *
+ * Type by which tasks are referenced.  For example, a call to xTaskCreate
+ * returns (via a pointer parameter) an TaskHandle_t variable that can then
+ * be used as a parameter to vTaskDelete to delete the task.
+ *
+ * \defgroup TaskHandle_t TaskHandle_t
+ * \ingroup Tasks
+ */
+typedef void * TaskHandle_t;
+
+/*
+ * Defines the prototype to which the application task hook function must
+ * conform.
+ */
+typedef BaseType_t (*TaskHookFunction_t)( void * );
+
+/* Task states returned by eTaskGetState. */
+typedef enum
+{
+	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
+	eReady,			/* The task being queried is in a read or pending ready list. */
+	eBlocked,		/* The task being queried is in the Blocked state. */
+	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
+	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
+	eInvalid			/* Used as an 'invalid state' value. */
+} eTaskState;
+
+/* Actions that can be performed when vTaskNotify() is called. */
+typedef enum
+{
+	eNoAction = 0,				/* Notify the task without updating its notify value. */
+	eSetBits,					/* Set bits in the task's notification value. */
+	eIncrement,					/* Increment the task's notification value. */
+	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
+	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
+} eNotifyAction;
+
+/*
+ * Used internally only.
+ */
+typedef struct xTIME_OUT
+{
+	BaseType_t xOverflowCount;
+	TickType_t xTimeOnEntering;
+} TimeOut_t;
+
+/*
+ * Defines the memory ranges allocated to the task when an MPU is used.
+ */
+typedef struct xMEMORY_REGION
+{
+	void *pvBaseAddress;
+	uint32_t ulLengthInBytes;
+	uint32_t ulParameters;
+} MemoryRegion_t;
+
+/*
+ * Parameters required to create an MPU protected task.
+ */
+typedef struct xTASK_PARAMETERS
+{
+	TaskFunction_t pvTaskCode;
+	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	uint16_t usStackDepth;
+	void *pvParameters;
+	UBaseType_t uxPriority;
+	StackType_t *puxStackBuffer;
+	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
+	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+		StaticTask_t * const pxTaskBuffer;
+	#endif
+} TaskParameters_t;
+
+/* Used with the uxTaskGetSystemState() function to return the state of each task
+in the system. */
+typedef struct xTASK_STATUS
+{
+	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
+	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+	UBaseType_t xTaskNumber;		/* A number unique to the task. */
+	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
+	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
+	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
+	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
+	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
+	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
+} TaskStatus_t;
+
+/* Possible return values for eTaskConfirmSleepModeStatus(). */
+typedef enum
+{
+	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
+	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
+	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
+} eSleepModeStatus;
+
+/**
+ * Defines the priority used by the idle task.  This must not be modified.
+ *
+ * \ingroup TaskUtils
+ */
+#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
+
+/**
+ * task. h
+ *
+ * Macro for forcing a context switch.
+ *
+ * \defgroup taskYIELD taskYIELD
+ * \ingroup SchedulerControl
+ */
+#define taskYIELD()					portYIELD()
+
+/**
+ * task. h
+ *
+ * Macro to mark the start of a critical code region.  Preemptive context
+ * switches cannot occur when in a critical region.
+ *
+ * NOTE: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ *
+ * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
+ * \ingroup SchedulerControl
+ */
+#define taskENTER_CRITICAL()		portENTER_CRITICAL()
+#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
+
+/**
+ * task. h
+ *
+ * Macro to mark the end of a critical code region.  Preemptive context
+ * switches cannot occur when in a critical region.
+ *
+ * NOTE: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ *
+ * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
+ * \ingroup SchedulerControl
+ */
+#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
+#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
+/**
+ * task. h
+ *
+ * Macro to disable all maskable interrupts.
+ *
+ * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
+ * \ingroup SchedulerControl
+ */
+#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
+
+/**
+ * task. h
+ *
+ * Macro to enable microcontroller interrupts.
+ *
+ * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
+ * \ingroup SchedulerControl
+ */
+#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
+
+/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
+0 to generate more optimal code when configASSERT() is defined as the constant
+is used in assert() statements. */
+#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
+#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
+#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
+
+
+/*-----------------------------------------------------------
+ * TASK CREATION API
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreate(
+							  TaskFunction_t pvTaskCode,
+							  const char * const pcName,
+							  configSTACK_DEPTH_TYPE usStackDepth,
+							  void *pvParameters,
+							  UBaseType_t uxPriority,
+							  TaskHandle_t *pvCreatedTask
+						  );</pre>
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreate() then both blocks of memory are automatically dynamically
+ * allocated inside the xTaskCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a task is created using
+ * xTaskCreateStatic() then the application writer must provide the required
+ * memory.  xTaskCreateStatic() therefore allows a task to be created without
+ * using any dynamic memory allocation.
+ *
+ * See xTaskCreateStatic() for a version that does not use any dynamic memory
+ * allocation.
+ *
+ * xTaskCreate() can only be used to create a task that has unrestricted
+ * access to the entire microcontroller memory map.  Systems that include MPU
+ * support can alternatively create an MPU constrained task using
+ * xTaskCreateRestricted().
+ *
+ * @param pvTaskCode Pointer to the task entry function.  Tasks
+ * must be implemented to never return (i.e. continuous loop).
+ *
+ * @param pcName A descriptive name for the task.  This is mainly used to
+ * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
+ * is 16.
+ *
+ * @param usStackDepth The size of the task stack specified as the number of
+ * variables the stack can hold - not the number of bytes.  For example, if
+ * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
+ * will be allocated for stack storage.
+ *
+ * @param pvParameters Pointer that will be used as the parameter for the task
+ * being created.
+ *
+ * @param uxPriority The priority at which the task should run.  Systems that
+ * include MPU support can optionally create tasks in a privileged (system)
+ * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
+ * example, to create a privileged task at priority 2 the uxPriority parameter
+ * should be set to ( 2 | portPRIVILEGE_BIT ).
+ *
+ * @param pvCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+ // Task to be created.
+ void vTaskCode( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+	 }
+ }
+
+ // Function that creates a task.
+ void vOtherFunction( void )
+ {
+ static uint8_t ucParameterToPass;
+ TaskHandle_t xHandle = NULL;
+
+	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
+	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
+	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
+	 // the new task attempts to access it.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
+     configASSERT( xHandle );
+
+	 // Use the handle to delete the task.
+     if( xHandle != NULL )
+     {
+	     vTaskDelete( xHandle );
+     }
+ }
+   </pre>
+ * \defgroup xTaskCreate xTaskCreate
+ * \ingroup Tasks
+ */
+#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
+	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
+							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+							const configSTACK_DEPTH_TYPE usStackDepth,
+							void * const pvParameters,
+							UBaseType_t uxPriority,
+							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
+								 const char * const pcName,
+								 uint32_t ulStackDepth,
+								 void *pvParameters,
+								 UBaseType_t uxPriority,
+								 StackType_t *pxStackBuffer,
+								 StaticTask_t *pxTaskBuffer );</pre>
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreate() then both blocks of memory are automatically dynamically
+ * allocated inside the xTaskCreate() function.  (see
+ * http://www.freertos.org/a00111.html).  If a task is created using
+ * xTaskCreateStatic() then the application writer must provide the required
+ * memory.  xTaskCreateStatic() therefore allows a task to be created without
+ * using any dynamic memory allocation.
+ *
+ * @param pvTaskCode Pointer to the task entry function.  Tasks
+ * must be implemented to never return (i.e. continuous loop).
+ *
+ * @param pcName A descriptive name for the task.  This is mainly used to
+ * facilitate debugging.  The maximum length of the string is defined by
+ * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
+ *
+ * @param ulStackDepth The size of the task stack specified as the number of
+ * variables the stack can hold - not the number of bytes.  For example, if
+ * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
+ * will be allocated for stack storage.
+ *
+ * @param pvParameters Pointer that will be used as the parameter for the task
+ * being created.
+ *
+ * @param uxPriority The priority at which the task will run.
+ *
+ * @param pxStackBuffer Must point to a StackType_t array that has at least
+ * ulStackDepth indexes - the array will then be used as the task's stack,
+ * removing the need for the stack to be allocated dynamically.
+ *
+ * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
+ * then be used to hold the task's data structures, removing the need for the
+ * memory to be allocated dynamically.
+ *
+ * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
+ * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
+ * are NULL then the task will not be created and
+ * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
+ *
+ * Example usage:
+   <pre>
+
+    // Dimensions the buffer that the task being created will use as its stack.
+    // NOTE:  This is the number of words the stack will hold, not the number of
+    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
+    // then 400 bytes (100 * 32-bits) will be allocated.
+    #define STACK_SIZE 200
+
+    // Structure that will hold the TCB of the task being created.
+    StaticTask_t xTaskBuffer;
+
+    // Buffer that the task being created will use as its stack.  Note this is
+    // an array of StackType_t variables.  The size of StackType_t is dependent on
+    // the RTOS port.
+    StackType_t xStack[ STACK_SIZE ];
+
+    // Function that implements the task being created.
+    void vTaskCode( void * pvParameters )
+    {
+        // The parameter value is expected to be 1 as 1 is passed in the
+        // pvParameters value in the call to xTaskCreateStatic().
+        configASSERT( ( uint32_t ) pvParameters == 1UL );
+
+        for( ;; )
+        {
+            // Task code goes here.
+        }
+    }
+
+    // Function that creates a task.
+    void vOtherFunction( void )
+    {
+        TaskHandle_t xHandle = NULL;
+
+        // Create the task without using any dynamic memory allocation.
+        xHandle = xTaskCreateStatic(
+                      vTaskCode,       // Function that implements the task.
+                      "NAME",          // Text name for the task.
+                      STACK_SIZE,      // Stack size in words, not bytes.
+                      ( void * ) 1,    // Parameter passed into the task.
+                      tskIDLE_PRIORITY,// Priority at which the task is created.
+                      xStack,          // Array to use as the task's stack.
+                      &xTaskBuffer );  // Variable to hold the task's data structure.
+
+        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
+        // been created, and xHandle will be the task's handle.  Use the handle
+        // to suspend the task.
+        vTaskSuspend( xHandle );
+    }
+   </pre>
+ * \defgroup xTaskCreateStatic xTaskCreateStatic
+ * \ingroup Tasks
+ */
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
+									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+									const uint32_t ulStackDepth,
+									void * const pvParameters,
+									UBaseType_t uxPriority,
+									StackType_t * const puxStackBuffer,
+									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
+#endif /* configSUPPORT_STATIC_ALLOCATION */
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
+ *
+ * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
+ *
+ * xTaskCreateRestricted() should only be used in systems that include an MPU
+ * implementation.
+ *
+ * Create a new task and add it to the list of tasks that are ready to run.
+ * The function parameters define the memory regions and associated access
+ * permissions allocated to the task.
+ *
+ * See xTaskCreateRestrictedStatic() for a version that does not use any
+ * dynamic memory allocation.
+ *
+ * @param pxTaskDefinition Pointer to a structure that contains a member
+ * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
+ * documentation) plus an optional stack buffer and the memory region
+ * definitions.
+ *
+ * @param pxCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+// Create an TaskParameters_t structure that defines the task to be created.
+static const TaskParameters_t xCheckTaskParameters =
+{
+	vATask,		// pvTaskCode - the function that implements the task.
+	"ATask",	// pcName - just a text name for the task to assist debugging.
+	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
+	NULL,		// pvParameters - passed into the task function as the function parameters.
+	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
+	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
+
+	// xRegions - Allocate up to three separate memory regions for access by
+	// the task, with appropriate access permissions.  Different processors have
+	// different memory alignment requirements - refer to the FreeRTOS documentation
+	// for full information.
+	{
+		// Base address					Length	Parameters
+        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
+        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
+        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
+	}
+};
+
+int main( void )
+{
+TaskHandle_t xHandle;
+
+	// Create a task from the const structure defined above.  The task handle
+	// is requested (the second parameter is not NULL) but in this case just for
+	// demonstration purposes as its not actually used.
+	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
+
+	// Start the scheduler.
+	vTaskStartScheduler();
+
+	// Will only get here if there was insufficient memory to create the idle
+	// and/or timer task.
+	for( ;; );
+}
+   </pre>
+ * \defgroup xTaskCreateRestricted xTaskCreateRestricted
+ * \ingroup Tasks
+ */
+#if( portUSING_MPU_WRAPPERS == 1 )
+	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
+ *
+ * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
+ *
+ * xTaskCreateRestrictedStatic() should only be used in systems that include an
+ * MPU implementation.
+ *
+ * Internally, within the FreeRTOS implementation, tasks use two blocks of
+ * memory.  The first block is used to hold the task's data structures.  The
+ * second block is used by the task as its stack.  If a task is created using
+ * xTaskCreateRestricted() then the stack is provided by the application writer,
+ * and the memory used to hold the task's data structure is automatically
+ * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
+ * is created using xTaskCreateRestrictedStatic() then the application writer
+ * must provide the memory used to hold the task's data structures too.
+ * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
+ * created without using any dynamic memory allocation.
+ *
+ * @param pxTaskDefinition Pointer to a structure that contains a member
+ * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
+ * documentation) plus an optional stack buffer and the memory region
+ * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
+ * contains an additional member, which is used to point to a variable of type
+ * StaticTask_t - which is then used to hold the task's data structure.
+ *
+ * @param pxCreatedTask Used to pass back a handle by which the created task
+ * can be referenced.
+ *
+ * @return pdPASS if the task was successfully created and added to a ready
+ * list, otherwise an error code defined in the file projdefs.h
+ *
+ * Example usage:
+   <pre>
+// Create an TaskParameters_t structure that defines the task to be created.
+// The StaticTask_t variable is only included in the structure when
+// configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
+// be used to force the variable into the RTOS kernel's privileged data area.
+static PRIVILEGED_DATA StaticTask_t xTaskBuffer;
+static const TaskParameters_t xCheckTaskParameters =
+{
+	vATask,		// pvTaskCode - the function that implements the task.
+	"ATask",	// pcName - just a text name for the task to assist debugging.
+	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
+	NULL,		// pvParameters - passed into the task function as the function parameters.
+	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
+	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
+
+	// xRegions - Allocate up to three separate memory regions for access by
+	// the task, with appropriate access permissions.  Different processors have
+	// different memory alignment requirements - refer to the FreeRTOS documentation
+	// for full information.
+	{
+		// Base address					Length	Parameters
+        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
+        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
+        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
+	}
+
+	&xTaskBuffer; // Holds the task's data structure.
+};
+
+int main( void )
+{
+TaskHandle_t xHandle;
+
+	// Create a task from the const structure defined above.  The task handle
+	// is requested (the second parameter is not NULL) but in this case just for
+	// demonstration purposes as its not actually used.
+	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
+
+	// Start the scheduler.
+	vTaskStartScheduler();
+
+	// Will only get here if there was insufficient memory to create the idle
+	// and/or timer task.
+	for( ;; );
+}
+   </pre>
+ * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
+ * \ingroup Tasks
+ */
+#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
+	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
+#endif
+
+/**
+ * task. h
+ *<pre>
+ void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
+ *
+ * Memory regions are assigned to a restricted task when the task is created by
+ * a call to xTaskCreateRestricted().  These regions can be redefined using
+ * vTaskAllocateMPURegions().
+ *
+ * @param xTask The handle of the task being updated.
+ *
+ * @param xRegions A pointer to an MemoryRegion_t structure that contains the
+ * new memory region definitions.
+ *
+ * Example usage:
+   <pre>
+// Define an array of MemoryRegion_t structures that configures an MPU region
+// allowing read/write access for 1024 bytes starting at the beginning of the
+// ucOneKByte array.  The other two of the maximum 3 definable regions are
+// unused so set to zero.
+static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
+{
+	// Base address		Length		Parameters
+	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
+	{ 0,				0,			0 },
+	{ 0,				0,			0 }
+};
+
+void vATask( void *pvParameters )
+{
+	// This task was created such that it has access to certain regions of
+	// memory as defined by the MPU configuration.  At some point it is
+	// desired that these MPU regions are replaced with that defined in the
+	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
+	// for this purpose.  NULL is used as the task handle to indicate that this
+	// function should modify the MPU regions of the calling task.
+	vTaskAllocateMPURegions( NULL, xAltRegions );
+
+	// Now the task can continue its function, but from this point on can only
+	// access its stack and the ucOneKByte array (unless any other statically
+	// defined or shared regions have been declared elsewhere).
+}
+   </pre>
+ * \defgroup xTaskCreateRestricted xTaskCreateRestricted
+ * \ingroup Tasks
+ */
+void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Remove a task from the RTOS real time kernel's management.  The task being
+ * deleted will be removed from all ready, blocked, suspended and event lists.
+ *
+ * NOTE:  The idle task is responsible for freeing the kernel allocated
+ * memory from tasks that have been deleted.  It is therefore important that
+ * the idle task is not starved of microcontroller processing time if your
+ * application makes any calls to vTaskDelete ().  Memory allocated by the
+ * task code is not automatically freed, and should be freed before the task
+ * is deleted.
+ *
+ * See the demo application file death.c for sample code that utilises
+ * vTaskDelete ().
+ *
+ * @param xTask The handle of the task to be deleted.  Passing NULL will
+ * cause the calling task to be deleted.
+ *
+ * Example usage:
+   <pre>
+ void vOtherFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create the task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // Use the handle to delete the task.
+	 vTaskDelete( xHandle );
+ }
+   </pre>
+ * \defgroup vTaskDelete vTaskDelete
+ * \ingroup Tasks
+ */
+void vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * TASK CONTROL API
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
+ *
+ * Delay a task for a given number of ticks.  The actual time that the
+ * task remains blocked depends on the tick rate.  The constant
+ * portTICK_PERIOD_MS can be used to calculate real time from the tick
+ * rate - with the resolution of one tick period.
+ *
+ * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ *
+ * vTaskDelay() specifies a time at which the task wishes to unblock relative to
+ * the time at which vTaskDelay() is called.  For example, specifying a block
+ * period of 100 ticks will cause the task to unblock 100 ticks after
+ * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
+ * of controlling the frequency of a periodic task as the path taken through the
+ * code, as well as other task and interrupt activity, will effect the frequency
+ * at which vTaskDelay() gets called and therefore the time at which the task
+ * next executes.  See vTaskDelayUntil() for an alternative API function designed
+ * to facilitate fixed frequency execution.  It does this by specifying an
+ * absolute time (rather than a relative time) at which the calling task should
+ * unblock.
+ *
+ * @param xTicksToDelay The amount of time, in tick periods, that
+ * the calling task should block.
+ *
+ * Example usage:
+
+ void vTaskFunction( void * pvParameters )
+ {
+ // Block for 500ms.
+ const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
+
+	 for( ;; )
+	 {
+		 // Simply toggle the LED every 500ms, blocking between each toggle.
+		 vToggleLED();
+		 vTaskDelay( xDelay );
+	 }
+ }
+
+ * \defgroup vTaskDelay vTaskDelay
+ * \ingroup TaskCtrl
+ */
+void vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
+ *
+ * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Delay a task until a specified time.  This function can be used by periodic
+ * tasks to ensure a constant execution frequency.
+ *
+ * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
+ * cause a task to block for the specified number of ticks from the time vTaskDelay () is
+ * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
+ * execution frequency as the time between a task starting to execute and that task
+ * calling vTaskDelay () may not be fixed [the task may take a different path though the
+ * code between calls, or may get interrupted or preempted a different number of times
+ * each time it executes].
+ *
+ * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
+ * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
+ * unblock.
+ *
+ * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
+ * rate - with the resolution of one tick period.
+ *
+ * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
+ * task was last unblocked.  The variable must be initialised with the current time
+ * prior to its first use (see the example below).  Following this the variable is
+ * automatically updated within vTaskDelayUntil ().
+ *
+ * @param xTimeIncrement The cycle time period.  The task will be unblocked at
+ * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
+ * same xTimeIncrement parameter value will cause the task to execute with
+ * a fixed interface period.
+ *
+ * Example usage:
+   <pre>
+ // Perform an action every 10 ticks.
+ void vTaskFunction( void * pvParameters )
+ {
+ TickType_t xLastWakeTime;
+ const TickType_t xFrequency = 10;
+
+	 // Initialise the xLastWakeTime variable with the current time.
+	 xLastWakeTime = xTaskGetTickCount ();
+	 for( ;; )
+	 {
+		 // Wait for the next cycle.
+		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
+
+		 // Perform action here.
+	 }
+ }
+   </pre>
+ * \defgroup vTaskDelayUntil vTaskDelayUntil
+ * \ingroup TaskCtrl
+ */
+void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
+ * function to be available.
+ *
+ * A task will enter the Blocked state when it is waiting for an event.  The
+ * event it is waiting for can be a temporal event (waiting for a time), such
+ * as when vTaskDelay() is called, or an event on an object, such as when
+ * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
+ * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
+ * task will leave the Blocked state, and return from whichever function call
+ * placed the task into the Blocked state.
+ *
+ * @param xTask The handle of the task to remove from the Blocked state.
+ *
+ * @return If the task referenced by xTask was not in the Blocked state then
+ * pdFAIL is returned.  Otherwise pdPASS is returned.
+ *
+ * \defgroup xTaskAbortDelay xTaskAbortDelay
+ * \ingroup TaskCtrl
+ */
+BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Obtain the priority of any task.
+ *
+ * @param xTask Handle of the task to be queried.  Passing a NULL
+ * handle results in the priority of the calling task being returned.
+ *
+ * @return The priority of xTask.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to obtain the priority of the created task.
+	 // It was created with tskIDLE_PRIORITY, but may have changed
+	 // it itself.
+	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
+	 {
+		 // The task has changed it's priority.
+	 }
+
+	 // ...
+
+	 // Is our priority higher than the created task?
+	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
+	 {
+		 // Our priority (obtained using NULL handle) is higher.
+	 }
+ }
+   </pre>
+ * \defgroup uxTaskPriorityGet uxTaskPriorityGet
+ * \ingroup TaskCtrl
+ */
+UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
+ *
+ * A version of uxTaskPriorityGet() that can be used from an ISR.
+ */
+UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
+ *
+ * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Obtain the state of any task.  States are encoded by the eTaskState
+ * enumerated type.
+ *
+ * @param xTask Handle of the task to be queried.
+ *
+ * @return The state of xTask at the time the function was called.  Note the
+ * state of the task might change between the function being called, and the
+ * functions return value being tested by the calling task.
+ */
+eTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
+ *
+ * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
+ * available.  See the configuration section for more information.
+ *
+ * Populates a TaskStatus_t structure with information about a task.
+ *
+ * @param xTask Handle of the task being queried.  If xTask is NULL then
+ * information will be returned about the calling task.
+ *
+ * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
+ * filled with information about the task referenced by the handle passed using
+ * the xTask parameter.
+ *
+ * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
+ * the stack high water mark of the task being queried.  Calculating the stack
+ * high water mark takes a relatively long time, and can make the system
+ * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
+ * allow the high water mark checking to be skipped.  The high watermark value
+ * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
+ * not set to pdFALSE;
+ *
+ * @param eState The TaskStatus_t structure contains a member to report the
+ * state of the task being queried.  Obtaining the task state is not as fast as
+ * a simple assignment - so the eState parameter is provided to allow the state
+ * information to be omitted from the TaskStatus_t structure.  To obtain state
+ * information then set eState to eInvalid - otherwise the value passed in
+ * eState will be reported as the task state in the TaskStatus_t structure.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+ TaskStatus_t xTaskDetails;
+
+    // Obtain the handle of a task from its name.
+    xHandle = xTaskGetHandle( "Task_Name" );
+
+    // Check the handle is not NULL.
+    configASSERT( xHandle );
+
+    // Use the handle to obtain further information about the task.
+    vTaskGetInfo( xHandle,
+                  &xTaskDetails,
+                  pdTRUE, // Include the high water mark in xTaskDetails.
+                  eInvalid ); // Include the task state in xTaskDetails.
+ }
+   </pre>
+ * \defgroup vTaskGetInfo vTaskGetInfo
+ * \ingroup TaskCtrl
+ */
+void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
+ *
+ * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Set the priority of any task.
+ *
+ * A context switch will occur before the function returns if the priority
+ * being set is higher than the currently executing task.
+ *
+ * @param xTask Handle to the task for which the priority is being set.
+ * Passing a NULL handle results in the priority of the calling task being set.
+ *
+ * @param uxNewPriority The priority to which the task will be set.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to raise the priority of the created task.
+	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
+
+	 // ...
+
+	 // Use a NULL handle to raise our priority to the same value.
+	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
+ }
+   </pre>
+ * \defgroup vTaskPrioritySet vTaskPrioritySet
+ * \ingroup TaskCtrl
+ */
+void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
+ *
+ * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Suspend any task.  When suspended a task will never get any microcontroller
+ * processing time, no matter what its priority.
+ *
+ * Calls to vTaskSuspend are not accumulative -
+ * i.e. calling vTaskSuspend () twice on the same task still only requires one
+ * call to vTaskResume () to ready the suspended task.
+ *
+ * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
+ * handle will cause the calling task to be suspended.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to suspend the created task.
+	 vTaskSuspend( xHandle );
+
+	 // ...
+
+	 // The created task will not run during this period, unless
+	 // another task calls vTaskResume( xHandle ).
+
+	 //...
+
+
+	 // Suspend ourselves.
+	 vTaskSuspend( NULL );
+
+	 // We cannot get here unless another task calls vTaskResume
+	 // with our handle as the parameter.
+ }
+   </pre>
+ * \defgroup vTaskSuspend vTaskSuspend
+ * \ingroup TaskCtrl
+ */
+void vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
+ *
+ * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
+ * See the configuration section for more information.
+ *
+ * Resumes a suspended task.
+ *
+ * A task that has been suspended by one or more calls to vTaskSuspend ()
+ * will be made available for running again by a single call to
+ * vTaskResume ().
+ *
+ * @param xTaskToResume Handle to the task being readied.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+ TaskHandle_t xHandle;
+
+	 // Create a task, storing the handle.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
+
+	 // ...
+
+	 // Use the handle to suspend the created task.
+	 vTaskSuspend( xHandle );
+
+	 // ...
+
+	 // The created task will not run during this period, unless
+	 // another task calls vTaskResume( xHandle ).
+
+	 //...
+
+
+	 // Resume the suspended task ourselves.
+	 vTaskResume( xHandle );
+
+	 // The created task will once again get microcontroller processing
+	 // time in accordance with its priority within the system.
+ }
+   </pre>
+ * \defgroup vTaskResume vTaskResume
+ * \ingroup TaskCtrl
+ */
+void vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
+ *
+ * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
+ * available.  See the configuration section for more information.
+ *
+ * An implementation of vTaskResume() that can be called from within an ISR.
+ *
+ * A task that has been suspended by one or more calls to vTaskSuspend ()
+ * will be made available for running again by a single call to
+ * xTaskResumeFromISR ().
+ *
+ * xTaskResumeFromISR() should not be used to synchronise a task with an
+ * interrupt if there is a chance that the interrupt could arrive prior to the
+ * task being suspended - as this can lead to interrupts being missed. Use of a
+ * semaphore as a synchronisation mechanism would avoid this eventuality.
+ *
+ * @param xTaskToResume Handle to the task being readied.
+ *
+ * @return pdTRUE if resuming the task should result in a context switch,
+ * otherwise pdFALSE. This is used by the ISR to determine if a context switch
+ * may be required following the ISR.
+ *
+ * \defgroup vTaskResumeFromISR vTaskResumeFromISR
+ * \ingroup TaskCtrl
+ */
+BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * SCHEDULER CONTROL
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <pre>void vTaskStartScheduler( void );</pre>
+ *
+ * Starts the real time kernel tick processing.  After calling the kernel
+ * has control over which tasks are executed and when.
+ *
+ * See the demo application file main.c for an example of creating
+ * tasks and starting the kernel.
+ *
+ * Example usage:
+   <pre>
+ void vAFunction( void )
+ {
+	 // Create at least one task before starting the kernel.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
+
+	 // Start the real time kernel with preemption.
+	 vTaskStartScheduler ();
+
+	 // Will not get here unless a task calls vTaskEndScheduler ()
+ }
+   </pre>
+ *
+ * \defgroup vTaskStartScheduler vTaskStartScheduler
+ * \ingroup SchedulerControl
+ */
+void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskEndScheduler( void );</pre>
+ *
+ * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
+ * in place of DOS, implements this function.
+ *
+ * Stops the real time kernel tick.  All created tasks will be automatically
+ * deleted and multitasking (either preemptive or cooperative) will
+ * stop.  Execution then resumes from the point where vTaskStartScheduler ()
+ * was called, as if vTaskStartScheduler () had just returned.
+ *
+ * See the demo application file main. c in the demo/PC directory for an
+ * example that uses vTaskEndScheduler ().
+ *
+ * vTaskEndScheduler () requires an exit function to be defined within the
+ * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
+ * performs hardware specific operations such as stopping the kernel tick.
+ *
+ * vTaskEndScheduler () will cause all of the resources allocated by the
+ * kernel to be freed - but will not free resources allocated by application
+ * tasks.
+ *
+ * Example usage:
+   <pre>
+ void vTaskCode( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // At some point we want to end the real time kernel processing
+		 // so call ...
+		 vTaskEndScheduler ();
+	 }
+ }
+
+ void vAFunction( void )
+ {
+	 // Create at least one task before starting the kernel.
+	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
+
+	 // Start the real time kernel with preemption.
+	 vTaskStartScheduler ();
+
+	 // Will only get here when the vTaskCode () task has called
+	 // vTaskEndScheduler ().  When we get here we are back to single task
+	 // execution.
+ }
+   </pre>
+ *
+ * \defgroup vTaskEndScheduler vTaskEndScheduler
+ * \ingroup SchedulerControl
+ */
+void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>void vTaskSuspendAll( void );</pre>
+ *
+ * Suspends the scheduler without disabling interrupts.  Context switches will
+ * not occur while the scheduler is suspended.
+ *
+ * After calling vTaskSuspendAll () the calling task will continue to execute
+ * without risk of being swapped out until a call to xTaskResumeAll () has been
+ * made.
+ *
+ * API functions that have the potential to cause a context switch (for example,
+ * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
+ * is suspended.
+ *
+ * Example usage:
+   <pre>
+ void vTask1( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // ...
+
+		 // At some point the task wants to perform a long operation during
+		 // which it does not want to get swapped out.  It cannot use
+		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
+		 // operation may cause interrupts to be missed - including the
+		 // ticks.
+
+		 // Prevent the real time kernel swapping out the task.
+		 vTaskSuspendAll ();
+
+		 // Perform the operation here.  There is no need to use critical
+		 // sections as we have all the microcontroller processing time.
+		 // During this time interrupts will still operate and the kernel
+		 // tick count will be maintained.
+
+		 // ...
+
+		 // The operation is complete.  Restart the kernel.
+		 xTaskResumeAll ();
+	 }
+ }
+   </pre>
+ * \defgroup vTaskSuspendAll vTaskSuspendAll
+ * \ingroup SchedulerControl
+ */
+void vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <pre>BaseType_t xTaskResumeAll( void );</pre>
+ *
+ * Resumes scheduler activity after it was suspended by a call to
+ * vTaskSuspendAll().
+ *
+ * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
+ * that were previously suspended by a call to vTaskSuspend().
+ *
+ * @return If resuming the scheduler caused a context switch then pdTRUE is
+ *		  returned, otherwise pdFALSE is returned.
+ *
+ * Example usage:
+   <pre>
+ void vTask1( void * pvParameters )
+ {
+	 for( ;; )
+	 {
+		 // Task code goes here.
+
+		 // ...
+
+		 // At some point the task wants to perform a long operation during
+		 // which it does not want to get swapped out.  It cannot use
+		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
+		 // operation may cause interrupts to be missed - including the
+		 // ticks.
+
+		 // Prevent the real time kernel swapping out the task.
+		 vTaskSuspendAll ();
+
+		 // Perform the operation here.  There is no need to use critical
+		 // sections as we have all the microcontroller processing time.
+		 // During this time interrupts will still operate and the real
+		 // time kernel tick count will be maintained.
+
+		 // ...
+
+		 // The operation is complete.  Restart the kernel.  We want to force
+		 // a context switch - but there is no point if resuming the scheduler
+		 // caused a context switch already.
+		 if( !xTaskResumeAll () )
+		 {
+			  taskYIELD ();
+		 }
+	 }
+ }
+   </pre>
+ * \defgroup xTaskResumeAll xTaskResumeAll
+ * \ingroup SchedulerControl
+ */
+BaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
+
+/*-----------------------------------------------------------
+ * TASK UTILITIES
+ *----------------------------------------------------------*/
+
+/**
+ * task. h
+ * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
+ *
+ * @return The count of ticks since vTaskStartScheduler was called.
+ *
+ * \defgroup xTaskGetTickCount xTaskGetTickCount
+ * \ingroup TaskUtils
+ */
+TickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
+ *
+ * @return The count of ticks since vTaskStartScheduler was called.
+ *
+ * This is a version of xTaskGetTickCount() that is safe to be called from an
+ * ISR - provided that TickType_t is the natural word size of the
+ * microcontroller being used or interrupt nesting is either not supported or
+ * not being used.
+ *
+ * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
+ * \ingroup TaskUtils
+ */
+TickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
+ *
+ * @return The number of tasks that the real time kernel is currently managing.
+ * This includes all ready, blocked and suspended tasks.  A task that
+ * has been deleted but not yet freed by the idle task will also be
+ * included in the count.
+ *
+ * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
+ * \ingroup TaskUtils
+ */
+UBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
+ *
+ * @return The text (human readable) name of the task referenced by the handle
+ * xTaskToQuery.  A task can query its own name by either passing in its own
+ * handle, or by setting xTaskToQuery to NULL.
+ *
+ * \defgroup pcTaskGetName pcTaskGetName
+ * \ingroup TaskUtils
+ */
+char *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
+ *
+ * NOTE:  This function takes a relatively long time to complete and should be
+ * used sparingly.
+ *
+ * @return The handle of the task that has the human readable name pcNameToQuery.
+ * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
+ * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
+ *
+ * \defgroup pcTaskGetHandle pcTaskGetHandle
+ * \ingroup TaskUtils
+ */
+TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task.h
+ * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
+ *
+ * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
+ * this function to be available.
+ *
+ * Returns the high water mark of the stack associated with xTask.  That is,
+ * the minimum free stack space there has been (in words, so on a 32 bit machine
+ * a value of 1 means 4 bytes) since the task started.  The smaller the returned
+ * number the closer the task has come to overflowing its stack.
+ *
+ * @param xTask Handle of the task associated with the stack to be checked.
+ * Set xTask to NULL to check the stack of the calling task.
+ *
+ * @return The smallest amount of free stack space there has been (in words, so
+ * actual spaces on the stack rather than bytes) since the task referenced by
+ * xTask was created.
+ */
+UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/* When using trace macros it is sometimes necessary to include task.h before
+FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
+so the following two prototypes will cause a compilation error.  This can be
+fixed by simply guarding against the inclusion of these two prototypes unless
+they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
+constant. */
+#ifdef configUSE_APPLICATION_TASK_TAG
+	#if configUSE_APPLICATION_TASK_TAG == 1
+		/**
+		 * task.h
+		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
+		 *
+		 * Sets pxHookFunction to be the task hook function used by the task xTask.
+		 * Passing xTask as NULL has the effect of setting the calling tasks hook
+		 * function.
+		 */
+		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
+
+		/**
+		 * task.h
+		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
+		 *
+		 * Returns the pxHookFunction value assigned to the task xTask.
+		 */
+		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
+#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
+
+#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
+
+	/* Each task contains an array of pointers that is dimensioned by the
+	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
+	kernel does not use the pointers itself, so the application writer can use
+	the pointers for any purpose they wish.  The following two functions are
+	used to set and query a pointer respectively. */
+	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
+	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
+
+#endif
+
+/**
+ * task.h
+ * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
+ *
+ * Calls the hook function associated with xTask.  Passing xTask as NULL has
+ * the effect of calling the Running tasks (the calling task) hook function.
+ *
+ * pvParameter is passed to the hook function for the task to interpret as it
+ * wants.  The return value is the value returned by the task hook function
+ * registered by the user.
+ */
+BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
+
+/**
+ * xTaskGetIdleTaskHandle() is only available if
+ * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
+ *
+ * Simply returns the handle of the idle task.  It is not valid to call
+ * xTaskGetIdleTaskHandle() before the scheduler has been started.
+ */
+TaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
+
+/**
+ * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
+ * uxTaskGetSystemState() to be available.
+ *
+ * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
+ * the system.  TaskStatus_t structures contain, among other things, members
+ * for the task handle, task name, task priority, task state, and total amount
+ * of run time consumed by the task.  See the TaskStatus_t structure
+ * definition in this file for the full member list.
+ *
+ * NOTE:  This function is intended for debugging use only as its use results in
+ * the scheduler remaining suspended for an extended period.
+ *
+ * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
+ * The array must contain at least one TaskStatus_t structure for each task
+ * that is under the control of the RTOS.  The number of tasks under the control
+ * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
+ *
+ * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
+ * parameter.  The size is specified as the number of indexes in the array, or
+ * the number of TaskStatus_t structures contained in the array, not by the
+ * number of bytes in the array.
+ *
+ * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
+ * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
+ * total run time (as defined by the run time stats clock, see
+ * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
+ * pulTotalRunTime can be set to NULL to omit the total run time information.
+ *
+ * @return The number of TaskStatus_t structures that were populated by
+ * uxTaskGetSystemState().  This should equal the number returned by the
+ * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
+ * in the uxArraySize parameter was too small.
+ *
+ * Example usage:
+   <pre>
+    // This example demonstrates how a human readable table of run time stats
+	// information is generated from raw data provided by uxTaskGetSystemState().
+	// The human readable table is written to pcWriteBuffer
+	void vTaskGetRunTimeStats( char *pcWriteBuffer )
+	{
+	TaskStatus_t *pxTaskStatusArray;
+	volatile UBaseType_t uxArraySize, x;
+	uint32_t ulTotalRunTime, ulStatsAsPercentage;
+
+		// Make sure the write buffer does not contain a string.
+		*pcWriteBuffer = 0x00;
+
+		// Take a snapshot of the number of tasks in case it changes while this
+		// function is executing.
+		uxArraySize = uxTaskGetNumberOfTasks();
+
+		// Allocate a TaskStatus_t structure for each task.  An array could be
+		// allocated statically at compile time.
+		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
+
+		if( pxTaskStatusArray != NULL )
+		{
+			// Generate raw status information about each task.
+			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
+
+			// For percentage calculations.
+			ulTotalRunTime /= 100UL;
+
+			// Avoid divide by zero errors.
+			if( ulTotalRunTime > 0 )
+			{
+				// For each populated position in the pxTaskStatusArray array,
+				// format the raw data as human readable ASCII data
+				for( x = 0; x < uxArraySize; x++ )
+				{
+					// What percentage of the total run time has the task used?
+					// This will always be rounded down to the nearest integer.
+					// ulTotalRunTimeDiv100 has already been divided by 100.
+					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
+
+					if( ulStatsAsPercentage > 0UL )
+					{
+						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
+					}
+					else
+					{
+						// If the percentage is zero here then the task has
+						// consumed less than 1% of the total run time.
+						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
+					}
+
+					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
+				}
+			}
+
+			// The array is no longer needed, free the memory it consumes.
+			vPortFree( pxTaskStatusArray );
+		}
+	}
+	</pre>
+ */
+UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
+ *
+ * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
+ * both be defined as 1 for this function to be available.  See the
+ * configuration section of the FreeRTOS.org website for more information.
+ *
+ * NOTE 1: This function will disable interrupts for its duration.  It is
+ * not intended for normal application runtime use but as a debug aid.
+ *
+ * Lists all the current tasks, along with their current state and stack
+ * usage high water mark.
+ *
+ * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
+ * suspended ('S').
+ *
+ * PLEASE NOTE:
+ *
+ * This function is provided for convenience only, and is used by many of the
+ * demo applications.  Do not consider it to be part of the scheduler.
+ *
+ * vTaskList() calls uxTaskGetSystemState(), then formats part of the
+ * uxTaskGetSystemState() output into a human readable table that displays task
+ * names, states and stack usage.
+ *
+ * vTaskList() has a dependency on the sprintf() C library function that might
+ * bloat the code size, use a lot of stack, and provide different results on
+ * different platforms.  An alternative, tiny, third party, and limited
+ * functionality implementation of sprintf() is provided in many of the
+ * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
+ * printf-stdarg.c does not provide a full snprintf() implementation!).
+ *
+ * It is recommended that production systems call uxTaskGetSystemState()
+ * directly to get access to raw stats data, rather than indirectly through a
+ * call to vTaskList().
+ *
+ * @param pcWriteBuffer A buffer into which the above mentioned details
+ * will be written, in ASCII form.  This buffer is assumed to be large
+ * enough to contain the generated report.  Approximately 40 bytes per
+ * task should be sufficient.
+ *
+ * \defgroup vTaskList vTaskList
+ * \ingroup TaskUtils
+ */
+void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
+ *
+ * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
+ * must both be defined as 1 for this function to be available.  The application
+ * must also then provide definitions for
+ * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
+ * to configure a peripheral timer/counter and return the timers current count
+ * value respectively.  The counter should be at least 10 times the frequency of
+ * the tick count.
+ *
+ * NOTE 1: This function will disable interrupts for its duration.  It is
+ * not intended for normal application runtime use but as a debug aid.
+ *
+ * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
+ * accumulated execution time being stored for each task.  The resolution
+ * of the accumulated time value depends on the frequency of the timer
+ * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
+ * Calling vTaskGetRunTimeStats() writes the total execution time of each
+ * task into a buffer, both as an absolute count value and as a percentage
+ * of the total system execution time.
+ *
+ * NOTE 2:
+ *
+ * This function is provided for convenience only, and is used by many of the
+ * demo applications.  Do not consider it to be part of the scheduler.
+ *
+ * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
+ * uxTaskGetSystemState() output into a human readable table that displays the
+ * amount of time each task has spent in the Running state in both absolute and
+ * percentage terms.
+ *
+ * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
+ * that might bloat the code size, use a lot of stack, and provide different
+ * results on different platforms.  An alternative, tiny, third party, and
+ * limited functionality implementation of sprintf() is provided in many of the
+ * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
+ * printf-stdarg.c does not provide a full snprintf() implementation!).
+ *
+ * It is recommended that production systems call uxTaskGetSystemState() directly
+ * to get access to raw stats data, rather than indirectly through a call to
+ * vTaskGetRunTimeStats().
+ *
+ * @param pcWriteBuffer A buffer into which the execution times will be
+ * written, in ASCII form.  This buffer is assumed to be large enough to
+ * contain the generated report.  Approximately 40 bytes per task should
+ * be sufficient.
+ *
+ * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
+ * \ingroup TaskUtils
+ */
+void vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param ulValue Data that can be sent with the notification.  How the data is
+ * used depends on the value of the eAction parameter.
+ *
+ * @param eAction Specifies how the notification updates the task's notification
+ * value, if at all.  Valid values for eAction are as follows:
+ *
+ * eSetBits -
+ * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
+ * always returns pdPASS in this case.
+ *
+ * eIncrement -
+ * The task's notification value is incremented.  ulValue is not used and
+ * xTaskNotify() always returns pdPASS in this case.
+ *
+ * eSetValueWithOverwrite -
+ * The task's notification value is set to the value of ulValue, even if the
+ * task being notified had not yet processed the previous notification (the
+ * task already had a notification pending).  xTaskNotify() always returns
+ * pdPASS in this case.
+ *
+ * eSetValueWithoutOverwrite -
+ * If the task being notified did not already have a notification pending then
+ * the task's notification value is set to ulValue and xTaskNotify() will
+ * return pdPASS.  If the task being notified already had a notification
+ * pending then no action is performed and pdFAIL is returned.
+ *
+ * eNoAction -
+ * The task receives a notification without its notification value being
+ * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
+ * this case.
+ *
+ *  pulPreviousNotificationValue -
+ *  Can be used to pass out the subject task's notification value before any
+ *  bits are modified by the notify function.
+ *
+ * @return Dependent on the value of eAction.  See the description of the
+ * eAction parameter.
+ *
+ * \defgroup xTaskNotify xTaskNotify
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
+#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
+#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * A version of xTaskNotify() that can be used from an interrupt service routine
+ * (ISR).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param ulValue Data that can be sent with the notification.  How the data is
+ * used depends on the value of the eAction parameter.
+ *
+ * @param eAction Specifies how the notification updates the task's notification
+ * value, if at all.  Valid values for eAction are as follows:
+ *
+ * eSetBits -
+ * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
+ * always returns pdPASS in this case.
+ *
+ * eIncrement -
+ * The task's notification value is incremented.  ulValue is not used and
+ * xTaskNotify() always returns pdPASS in this case.
+ *
+ * eSetValueWithOverwrite -
+ * The task's notification value is set to the value of ulValue, even if the
+ * task being notified had not yet processed the previous notification (the
+ * task already had a notification pending).  xTaskNotify() always returns
+ * pdPASS in this case.
+ *
+ * eSetValueWithoutOverwrite -
+ * If the task being notified did not already have a notification pending then
+ * the task's notification value is set to ulValue and xTaskNotify() will
+ * return pdPASS.  If the task being notified already had a notification
+ * pending then no action is performed and pdFAIL is returned.
+ *
+ * eNoAction -
+ * The task receives a notification without its notification value being
+ * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
+ * this case.
+ *
+ * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
+ * task to which the notification was sent to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently running task.  If
+ * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
+ * be requested before the interrupt is exited.  How a context switch is
+ * requested from an ISR is dependent on the port - see the documentation page
+ * for the port in use.
+ *
+ * @return Dependent on the value of eAction.  See the description of the
+ * eAction parameter.
+ *
+ * \defgroup xTaskNotify xTaskNotify
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
+#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * A notification sent to a task will remain pending until it is cleared by the
+ * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
+ * already in the Blocked state to wait for a notification when the notification
+ * arrives then the task will automatically be removed from the Blocked state
+ * (unblocked) and the notification cleared.
+ *
+ * A task can use xTaskNotifyWait() to [optionally] block to wait for a
+ * notification to be pending, or ulTaskNotifyTake() to [optionally] block
+ * to wait for its notification value to have a non-zero value.  The task does
+ * not consume any CPU time while it is in the Blocked state.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
+ * will be cleared in the calling task's notification value before the task
+ * checks to see if any notifications are pending, and optionally blocks if no
+ * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
+ * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
+ * the effect of resetting the task's notification value to 0.  Setting
+ * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
+ *
+ * @param ulBitsToClearOnExit If a notification is pending or received before
+ * the calling task exits the xTaskNotifyWait() function then the task's
+ * notification value (see the xTaskNotify() API function) is passed out using
+ * the pulNotificationValue parameter.  Then any bits that are set in
+ * ulBitsToClearOnExit will be cleared in the task's notification value (note
+ * *pulNotificationValue is set before any bits are cleared).  Setting
+ * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
+ * (if limits.h is not included) will have the effect of resetting the task's
+ * notification value to 0 before the function exits.  Setting
+ * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
+ * when the function exits (in which case the value passed out in
+ * pulNotificationValue will match the task's notification value).
+ *
+ * @param pulNotificationValue Used to pass the task's notification value out
+ * of the function.  Note the value passed out will not be effected by the
+ * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait in
+ * the Blocked state for a notification to be received, should a notification
+ * not already be pending when xTaskNotifyWait() was called.  The task
+ * will not consume any processing time while it is in the Blocked state.  This
+ * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
+ * used to convert a time specified in milliseconds to a time specified in
+ * ticks.
+ *
+ * @return If a notification was received (including notifications that were
+ * already pending when xTaskNotifyWait was called) then pdPASS is
+ * returned.  Otherwise pdFAIL is returned.
+ *
+ * \defgroup xTaskNotifyWait xTaskNotifyWait
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
+ * to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * xTaskNotifyGive() is a helper macro intended for use when task notifications
+ * are used as light weight and faster binary or counting semaphore equivalents.
+ * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
+ * the equivalent action that instead uses a task notification is
+ * xTaskNotifyGive().
+ *
+ * When task notifications are being used as a binary or counting semaphore
+ * equivalent then the task being notified should wait for the notification
+ * using the ulTaskNotificationTake() API function rather than the
+ * xTaskNotifyWait() API function.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
+ * eAction parameter set to eIncrement - so pdPASS is always returned.
+ *
+ * \defgroup xTaskNotifyGive xTaskNotifyGive
+ * \ingroup TaskNotifications
+ */
+#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
+
+/**
+ * task. h
+ * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
+ * to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * A version of xTaskNotifyGive() that can be called from an interrupt service
+ * routine (ISR).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * vTaskNotifyGiveFromISR() is intended for use when task notifications are
+ * used as light weight and faster binary or counting semaphore equivalents.
+ * Actual FreeRTOS semaphores are given from an ISR using the
+ * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
+ * a task notification is vTaskNotifyGiveFromISR().
+ *
+ * When task notifications are being used as a binary or counting semaphore
+ * equivalent then the task being notified should wait for the notification
+ * using the ulTaskNotificationTake() API function rather than the
+ * xTaskNotifyWait() API function.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
+ *
+ * @param xTaskToNotify The handle of the task being notified.  The handle to a
+ * task can be returned from the xTaskCreate() API function used to create the
+ * task, and the handle of the currently running task can be obtained by calling
+ * xTaskGetCurrentTaskHandle().
+ *
+ * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
+ * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
+ * task to which the notification was sent to leave the Blocked state, and the
+ * unblocked task has a priority higher than the currently running task.  If
+ * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
+ * should be requested before the interrupt is exited.  How a context switch is
+ * requested from an ISR is dependent on the port - see the documentation page
+ * for the port in use.
+ *
+ * \defgroup xTaskNotifyWait xTaskNotifyWait
+ * \ingroup TaskNotifications
+ */
+void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
+ *
+ * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
+ * function to be available.
+ *
+ * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
+ * "notification value", which is a 32-bit unsigned integer (uint32_t).
+ *
+ * Events can be sent to a task using an intermediary object.  Examples of such
+ * objects are queues, semaphores, mutexes and event groups.  Task notifications
+ * are a method of sending an event directly to a task without the need for such
+ * an intermediary object.
+ *
+ * A notification sent to a task can optionally perform an action, such as
+ * update, overwrite or increment the task's notification value.  In that way
+ * task notifications can be used to send data to a task, or be used as light
+ * weight and fast binary or counting semaphores.
+ *
+ * ulTaskNotifyTake() is intended for use when a task notification is used as a
+ * faster and lighter weight binary or counting semaphore alternative.  Actual
+ * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
+ * equivalent action that instead uses a task notification is
+ * ulTaskNotifyTake().
+ *
+ * When a task is using its notification value as a binary or counting semaphore
+ * other tasks should send notifications to it using the xTaskNotifyGive()
+ * macro, or xTaskNotify() function with the eAction parameter set to
+ * eIncrement.
+ *
+ * ulTaskNotifyTake() can either clear the task's notification value to
+ * zero on exit, in which case the notification value acts like a binary
+ * semaphore, or decrement the task's notification value on exit, in which case
+ * the notification value acts like a counting semaphore.
+ *
+ * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
+ * the task's notification value to be non-zero.  The task does not consume any
+ * CPU time while it is in the Blocked state.
+ *
+ * Where as xTaskNotifyWait() will return when a notification is pending,
+ * ulTaskNotifyTake() will return when the task's notification value is
+ * not zero.
+ *
+ * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
+ *
+ * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
+ * notification value is decremented when the function exits.  In this way the
+ * notification value acts like a counting semaphore.  If xClearCountOnExit is
+ * not pdFALSE then the task's notification value is cleared to zero when the
+ * function exits.  In this way the notification value acts like a binary
+ * semaphore.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait in
+ * the Blocked state for the task's notification value to be greater than zero,
+ * should the count not already be greater than zero when
+ * ulTaskNotifyTake() was called.  The task will not consume any processing
+ * time while it is in the Blocked state.  This is specified in kernel ticks,
+ * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
+ * specified in milliseconds to a time specified in ticks.
+ *
+ * @return The task's notification count before it is either cleared to zero or
+ * decremented (see the xClearCountOnExit parameter).
+ *
+ * \defgroup ulTaskNotifyTake ulTaskNotifyTake
+ * \ingroup TaskNotifications
+ */
+uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/**
+ * task. h
+ * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
+ *
+ * If the notification state of the task referenced by the handle xTask is
+ * eNotified, then set the task's notification state to eNotWaitingNotification.
+ * The task's notification value is not altered.  Set xTask to NULL to clear the
+ * notification state of the calling task.
+ *
+ * @return pdTRUE if the task's notification state was set to
+ * eNotWaitingNotification, otherwise pdFALSE.
+ * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
+ * \ingroup TaskNotifications
+ */
+BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
+
+/*-----------------------------------------------------------
+ * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
+ *----------------------------------------------------------*/
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
+ * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
+ * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * Called from the real time kernel tick (either preemptive or cooperative),
+ * this increments the tick count and checks if any tasks that are blocked
+ * for a finite period required removing from a blocked list and placing on
+ * a ready list.  If a non-zero value is returned then a context switch is
+ * required because either:
+ *   + A task was removed from a blocked list because its timeout had expired,
+ *     or
+ *   + Time slicing is in use and there is a task of equal priority to the
+ *     currently running task.
+ */
+BaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * Removes the calling task from the ready list and places it both
+ * on the list of tasks waiting for a particular event, and the
+ * list of delayed tasks.  The task will be removed from both lists
+ * and replaced on the ready list should either the event occur (and
+ * there be no higher priority tasks waiting on the same event) or
+ * the delay period expires.
+ *
+ * The 'unordered' version replaces the event list item value with the
+ * xItemValue value, and inserts the list item at the end of the list.
+ *
+ * The 'ordered' version uses the existing event list item value (which is the
+ * owning tasks priority) to insert the list item into the event list is task
+ * priority order.
+ *
+ * @param pxEventList The list containing tasks that are blocked waiting
+ * for the event to occur.
+ *
+ * @param xItemValue The item value to use for the event list item when the
+ * event list is not ordered by task priority.
+ *
+ * @param xTicksToWait The maximum amount of time that the task should wait
+ * for the event to occur.  This is specified in kernel ticks,the constant
+ * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
+ * period.
+ */
+void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * This function performs nearly the same function as vTaskPlaceOnEventList().
+ * The difference being that this function does not permit tasks to block
+ * indefinitely, whereas vTaskPlaceOnEventList() does.
+ *
+ */
+void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
+ * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
+ *
+ * Removes a task from both the specified event list and the list of blocked
+ * tasks, and places it on a ready queue.
+ *
+ * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
+ * if either an event occurs to unblock a task, or the block timeout period
+ * expires.
+ *
+ * xTaskRemoveFromEventList() is used when the event list is in task priority
+ * order.  It removes the list item from the head of the event list as that will
+ * have the highest priority owning task of all the tasks on the event list.
+ * vTaskRemoveFromUnorderedEventList() is used when the event list is not
+ * ordered and the event list items hold something other than the owning tasks
+ * priority.  In this case the event list item value is updated to the value
+ * passed in the xItemValue parameter.
+ *
+ * @return pdTRUE if the task being removed has a higher priority than the task
+ * making the call, otherwise pdFALSE.
+ */
+BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
+void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
+
+/*
+ * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
+ * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
+ * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
+ *
+ * Sets the pointer to the current TCB to the TCB of the highest priority task
+ * that is ready to run.
+ */
+void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
+ * THE EVENT BITS MODULE.
+ */
+TickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Return the handle of the calling task.
+ */
+TaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Capture the current time status for future reference.
+ */
+void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
+
+/*
+ * Compare the time status now with that previously captured to see if the
+ * timeout has expired.
+ */
+BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
+
+/*
+ * Shortcut used by the queue implementation to prevent unnecessary call to
+ * taskYIELD();
+ */
+void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Returns the scheduler state as taskSCHEDULER_RUNNING,
+ * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
+ */
+BaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * Raises the priority of the mutex holder to that of the calling task should
+ * the mutex holder have a priority less than the calling task.
+ */
+BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
+
+/*
+ * Set the priority of a task back to its proper priority in the case that it
+ * inherited a higher priority while it was holding a semaphore.
+ */
+BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
+
+/*
+ * If a higher priority task attempting to obtain a mutex caused a lower
+ * priority task to inherit the higher priority task's priority - but the higher
+ * priority task then timed out without obtaining the mutex, then the lower
+ * priority task will disinherit the priority again - but only down as far as
+ * the highest priority task that is still waiting for the mutex (if there were
+ * more than one task waiting for the mutex).
+ */
+void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
+
+/*
+ * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
+ */
+UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
+
+/*
+ * Set the uxTaskNumber of the task referenced by the xTask parameter to
+ * uxHandle.
+ */
+void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
+
+/*
+ * Only available when configUSE_TICKLESS_IDLE is set to 1.
+ * If tickless mode is being used, or a low power mode is implemented, then
+ * the tick interrupt will not execute during idle periods.  When this is the
+ * case, the tick count value maintained by the scheduler needs to be kept up
+ * to date with the actual execution time by being skipped forward by a time
+ * equal to the idle period.
+ */
+void vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
+
+/*
+ * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
+ * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
+ * specific sleep function to determine if it is ok to proceed with the sleep,
+ * and if it is ok to proceed, if it is ok to sleep indefinitely.
+ *
+ * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
+ * called with the scheduler suspended, not from within a critical section.  It
+ * is therefore possible for an interrupt to request a context switch between
+ * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
+ * entered.  eTaskConfirmSleepModeStatus() should be called from a short
+ * critical section between the timer being stopped and the sleep mode being
+ * entered to ensure it is ok to proceed into the sleep mode.
+ */
+eSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * For internal use only.  Increment the mutex held count when a mutex is
+ * taken and return the handle of the task that has taken the mutex.
+ */
+void *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
+
+/*
+ * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial
+ * section.
+ */
+void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* INC_TASK_H */
+
+
+
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_api.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_api.h
index 4668c99..210d797 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_api.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_api.h	
@@ -1,1753 +1,1753 @@
-/**************************************************************************/
-/*                                                                        */
-/*            Copyright (c) 1996-2012 by Express Logic Inc.               */
-/*                                                                        */
-/*  This software is copyrighted by and is the sole property of Express   */
-/*  Logic, Inc.  All rights, title, ownership, or other interests         */
-/*  in the software remain the property of Express Logic, Inc.  This      */
-/*  software may only be used in accordance with the corresponding        */
-/*  license agreement.  Any unauthorized use, duplication, transmission,  */
-/*  distribution, or disclosure of this software is expressly forbidden.  */
-/*                                                                        */
-/*  This Copyright notice may not be removed or modified without prior    */
-/*  written consent of Express Logic, Inc.                                */
-/*                                                                        */
-/*  Express Logic, Inc. reserves the right to modify this software        */
-/*  without notice.                                                       */
-/*                                                                        */
-/*  Express Logic, Inc.                     info@expresslogic.com         */
-/*  11423 West Bernardo Court               http://www.expresslogic.com   */
-/*  San Diego, CA  92127                                                  */
-/*                                                                        */
-/**************************************************************************/
-
-/**************************************************************************/
-/**************************************************************************/
-/**                                                                       */
-/** ThreadX Component                                                     */
-/**                                                                       */
-/**   Application Interface (API)                                         */
-/**                                                                       */
-/**************************************************************************/
-/**************************************************************************/
-
-/**************************************************************************/
-/*                                                                        */
-/*  APPLICATION INTERFACE DEFINITION                       RELEASE        */
-/*                                                                        */
-/*    tx_api.h                                            PORTABLE C      */
-/*                                                           5.6          */
-/*  AUTHOR                                                                */
-/*                                                                        */
-/*    William E. Lamie, Express Logic, Inc.                               */
-/*                                                                        */
-/*  DESCRIPTION                                                           */
-/*                                                                        */
-/*    This file defines the basic Application Interface (API) to the      */
-/*    high-performance ThreadX real-time kernel.  All service prototypes  */
-/*    and data structure definitions are defined in this file.            */
-/*    Please note that basic data type definitions and other architecture-*/
-/*    specific information is contained in the file tx_port.h.            */
-/*                                                                        */
-/*  RELEASE HISTORY                                                       */
-/*                                                                        */
-/*    DATE              NAME                      DESCRIPTION             */
-/*                                                                        */
-/*  12-12-2005     William E. Lamie         Initial Version 5.0           */
-/*  04-02-2007     William E. Lamie         Modified comment(s), and      */
-/*                                            replaced UL constant        */
-/*                                            modifier with ULONG cast,   */
-/*                                            resulting in version 5.1    */
-/*  12-12-2008     William E. Lamie         Modified comment(s), and      */
-/*                                            added trace constants,      */
-/*                                            resulting in version 5.2    */
-/*  07-04-2009     William E. Lamie         Modified comment(s), and      */
-/*                                            changed the start of user   */
-/*                                            trace events to 4096,       */
-/*                                            resulting in version 5.3    */
-/*  12-12-2009     William E. Lamie         Modified comment(s), changed  */
-/*                                            the definition of TX_NULL   */
-/*                                            to a pointer type, added    */
-/*                                            TX_MEMSET macro, modified   */
-/*                                            priority-inheritance struct */
-/*                                            members in TX_THREAD,changed*/
-/*                                            user event comments, added  */
-/*                                            callback for tracking thread*/
-/*                                            scheduling, merged event    */
-/*                                            logging and MULTI run-time  */
-/*                                            error checking support,     */
-/*                                            changed type of all internal*/
-/*                                            structure members used for  */
-/*                                            counting to UINT, and added */
-/*                                            safety critical exception   */
-/*                                            logic, resulting in         */
-/*                                            version 5.4                 */
-/*  07-15-2011     William E. Lamie         Modified comment(s), added    */
-/*                                            defines for major/minor     */
-/*                                            version information, and    */
-/*                                            removed unused original     */
-/*                                            threshold mutex structure   */
-/*                                            member, resulting in        */
-/*                                            version 5.5                 */
-/*  11-01-2012     William E. Lamie         Modified comment(s), and      */
-/*                                            modified minor version      */
-/*                                            define, resulting in        */
-/*                                            version 5.6                 */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef TX_API_H
-#define TX_API_H
-
-/* Determine if a C++ compiler is being used.  If so, ensure that standard
-   C is used to process the API information.  */
-
-#ifdef __cplusplus
-
-/* Yes, C++ compiler is present.  Use standard C.  */
-extern "C" {
-
-#endif
-
-/* Include the port-specific data type file.  */
-
-#include "tx_port.h"
-
-/* Define basic constants for the ThreadX kernel.  */
-
-/* Define the major/minor version information that can be used by the application
-   and the ThreadX source as well.  */
-
-#define __PRODUCT_THREADX__
-#define __THREADX_MAJOR_VERSION 5
-#define __THREADX_MINOR_VERSION 6
-
-/* API input parameters and general constants.  */
-
-#define TX_NO_WAIT 0
-#define TX_WAIT_FOREVER ((ULONG)0xFFFFFFFF)
-#define TX_AND 2
-#define TX_AND_CLEAR 3
-#define TX_OR 0
-#define TX_OR_CLEAR 1
-#define TX_1_ULONG 1
-#define TX_2_ULONG 2
-#define TX_4_ULONG 4
-#define TX_8_ULONG 8
-#define TX_16_ULONG 16
-#define TX_NO_TIME_SLICE 0
-#define TX_AUTO_START 1
-#define TX_DONT_START 0
-#define TX_AUTO_ACTIVATE 1
-#define TX_NO_ACTIVATE 0
-#define TX_TRUE 1
-#define TX_FALSE 0
-#define TX_NULL (void*)0
-#define TX_LOOP_FOREVER 1
-#define TX_INHERIT 1
-#define TX_NO_INHERIT 0
-#define TX_THREAD_ENTRY 0
-#define TX_THREAD_EXIT 1
-#define TX_STACK_FILL ((ULONG)0xEFEFEFEF)
-
-/* Thread execution state values.  */
-
-#define TX_READY 0
-#define TX_COMPLETED 1
-#define TX_TERMINATED 2
-#define TX_SUSPENDED 3
-#define TX_SLEEP 4
-#define TX_QUEUE_SUSP 5
-#define TX_SEMAPHORE_SUSP 6
-#define TX_EVENT_FLAG 7
-#define TX_BLOCK_MEMORY 8
-#define TX_BYTE_MEMORY 9
-#define TX_IO_DRIVER 10
-#define TX_FILE 11
-#define TX_TCP_IP 12
-#define TX_MUTEX_SUSP 13
-
-/* API return values.  */
-
-#define TX_SUCCESS 0x00
-#define TX_DELETED 0x01
-#define TX_NO_MEMORY 0x10
-#define TX_POOL_ERROR 0x02
-#define TX_PTR_ERROR 0x03
-#define TX_WAIT_ERROR 0x04
-#define TX_SIZE_ERROR 0x05
-#define TX_GROUP_ERROR 0x06
-#define TX_NO_EVENTS 0x07
-#define TX_OPTION_ERROR 0x08
-#define TX_QUEUE_ERROR 0x09
-#define TX_QUEUE_EMPTY 0x0A
-#define TX_QUEUE_FULL 0x0B
-#define TX_SEMAPHORE_ERROR 0x0C
-#define TX_NO_INSTANCE 0x0D
-#define TX_THREAD_ERROR 0x0E
-#define TX_PRIORITY_ERROR 0x0F
-#define TX_START_ERROR 0x10
-#define TX_DELETE_ERROR 0x11
-#define TX_RESUME_ERROR 0x12
-#define TX_CALLER_ERROR 0x13
-#define TX_SUSPEND_ERROR 0x14
-#define TX_TIMER_ERROR 0x15
-#define TX_TICK_ERROR 0x16
-#define TX_ACTIVATE_ERROR 0x17
-#define TX_THRESH_ERROR 0x18
-#define TX_SUSPEND_LIFTED 0x19
-#define TX_WAIT_ABORTED 0x1A
-#define TX_WAIT_ABORT_ERROR 0x1B
-#define TX_MUTEX_ERROR 0x1C
-#define TX_NOT_AVAILABLE 0x1D
-#define TX_NOT_OWNED 0x1E
-#define TX_INHERIT_ERROR 0x1F
-#define TX_NOT_DONE 0x20
-#define TX_CEILING_EXCEEDED 0x21
-#define TX_INVALID_CEILING 0x22
-#define TX_FEATURE_NOT_ENABLED 0xFF
-
-/* Define the TX_MEMSET macro to the standard library function, if not already defined.  */
-
-#ifndef TX_MEMSET
-#define TX_MEMSET(a, b, c) (memset)(a, b, c)
-/*
- Parentheses around memset prevent the compiler from adding a call to ___memset_chk().
- Somehow this header/definition is escaping the -fno-stack-protect and FORTIFY_SOURCE options.
- */
-#endif
-
-/* Event numbers 0 through 4095 are reserved by Express Logic. Specific event assignments are:
-
-								ThreadX events:     1-199
-								FileX events:       200-299
-								NetX events:        300-599
-								USBX events:        600-999
-
-   User-defined event numbers start at 4096 and continue through 65535, as defined by the constants
-   TX_TRACE_USER_EVENT_START and TX_TRACE_USER_EVENT_END, respectively. User events should be based
-   on these constants in case the user event number assignment is changed in future releases.  */
-
-#define TX_TRACE_USER_EVENT_START 4096 /* I1, I2, I3, I4 are user defined           */
-#define TX_TRACE_USER_EVENT_END 65535 /* I1, I2, I3, I4 are user defined           */
-
-/* Define event filters that can be used to selectively disable certain events or groups of events.
- */
-
-#define TX_TRACE_ALL_EVENTS 0x000007FF /* All ThreadX events                        */
-#define TX_TRACE_INTERNAL_EVENTS 0x00000001 /* ThreadX internal events                   */
-#define TX_TRACE_BLOCK_POOL_EVENTS 0x00000002 /* ThreadX Block Pool events                 */
-#define TX_TRACE_BYTE_POOL_EVENTS 0x00000004 /* ThreadX Byte Pool events                  */
-#define TX_TRACE_EVENT_FLAGS_EVENTS 0x00000008 /* ThreadX Event Flags events                */
-#define TX_TRACE_INTERRUPT_CONTROL_EVENT 0x00000010 /* ThreadX Interrupt Control events */
-#define TX_TRACE_MUTEX_EVENTS 0x00000020 /* ThreadX Mutex events                      */
-#define TX_TRACE_QUEUE_EVENTS 0x00000040 /* ThreadX Queue events                      */
-#define TX_TRACE_SEMAPHORE_EVENTS 0x00000080 /* ThreadX Semaphore events                  */
-#define TX_TRACE_THREAD_EVENTS 0x00000100 /* ThreadX Thread events                     */
-#define TX_TRACE_TIME_EVENTS 0x00000200 /* ThreadX Time events                       */
-#define TX_TRACE_TIMER_EVENTS 0x00000400 /* ThreadX Timer events                      */
-#define TX_TRACE_USER_EVENTS 0x80000000 /* ThreadX User Events                       */
-
-/* Define the control block definitions for all system objects.  */
-
-/* Define the basic timer management structures.  These are the structures
-   used to manage thread sleep, timeout, and user timer requests.  */
-
-/* Define the common internal timer control block.  */
-
-typedef struct TX_TIMER_INTERNAL_STRUCT
-{
-	/* Define the remaining ticks and re-initialization tick values.  */
-	ULONG tx_timer_internal_remaining_ticks;
-	ULONG tx_timer_internal_re_initialize_ticks;
-
-	/* Define the timeout function and timeout function parameter.  */
-	VOID (*tx_timer_internal_timeout_function)(ULONG);
-	ULONG tx_timer_internal_timeout_param;
-
-	/* Define the next and previous internal link pointers for active
-	   internal timers.  */
-	struct TX_TIMER_INTERNAL_STRUCT *tx_timer_internal_active_next,
-		*tx_timer_internal_active_previous;
-
-	/* Keep track of the pointer to the head of this list as well.  */
-	struct TX_TIMER_INTERNAL_STRUCT** tx_timer_internal_list_head;
-} TX_TIMER_INTERNAL;
-
-/* Define the timer structure utilized by the application.  */
-
-typedef struct TX_TIMER_STRUCT
-{
-	/* Define the timer ID used for error checking.  */
-	ULONG tx_timer_id;
-
-	/* Define the timer's name.  */
-	const CHAR* tx_timer_name;
-
-	/* Define the actual contents of the timer.  This is the block that
-	   is used in the actual timer expiration processing.  */
-	TX_TIMER_INTERNAL tx_timer_internal;
-
-	/* Define the pointers for the created list.  */
-	struct TX_TIMER_STRUCT *tx_timer_created_next, *tx_timer_created_previous;
-
-#ifdef TX_TIMER_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of timer activations.  */
-	ULONG tx_timer_performance_activate_count;
-
-	/* Define the number of timer reactivations.  */
-	ULONG tx_timer_performance_reactivate_count;
-
-	/* Define the number of timer deactivations.  */
-	ULONG tx_timer_performance_deactivate_count;
-
-	/* Define the number of timer expirations.  */
-	ULONG tx_timer_performance_expiration_count;
-
-	/* Define the total number of timer expiration adjustments.  */
-	ULONG tx_timer_performance_expiration_adjust_count;
-#endif
-
-} TX_TIMER;
-
-/* Statically defined keys for *_getspecific & *_setspecific apis' */
-typedef enum { TX_THREAD_SJLJ_KEY = 0, TX_THREAD_CXA_GLOBAL_KEY, TX_THREAD_MAX_KEY } TX_THREAD_KEYS;
-
-typedef struct TX_THREAD_SPECIFIC_STRUCT
-{
-	void* values[TX_THREAD_MAX_KEY];
-} TX_THREAD_SPECIFIC;
-
-typedef int TX_THREAD_KEY;
-
-/* ThreadX thread control block structure follows.  Additional fields
-   can be added providing they are added after the information that is
-   referenced in the port-specific assembly code.  */
-
-typedef struct TX_THREAD_STRUCT
-{
-	/* The first section of the control block contains critical
-	   information that is referenced by the port-specific
-	   assembly language code.  Any changes in this section could
-	   necessitate changes in the assembly language.  */
-
-	ULONG tx_thread_id; /* Control block ID         */
-	ULONG tx_thread_run_count; /* Thread's run counter     */
-	VOID* tx_thread_stack_ptr; /* Thread's stack pointer   */
-	VOID* tx_thread_stack_start; /* Stack starting address   */
-	VOID* tx_thread_stack_end; /* Stack ending address     */
-	ULONG tx_thread_stack_size; /* Stack size               */
-	ULONG tx_thread_time_slice; /* Current time-slice       */
-	ULONG tx_thread_new_time_slice; /* New time-slice           */
-
-	/* Define pointers to the next and previous ready threads.  */
-	struct TX_THREAD_STRUCT *tx_thread_ready_next, *tx_thread_ready_previous;
-
-	/***************************************************************/
-
-	/* Define the first port extension in the thread control block. This
-	   is typically defined to whitespace or a pointer type in tx_port.h.  */
-	TX_THREAD_EXTENSION_0
-
-	const CHAR* tx_thread_name; /* Pointer to thread's name     */
-	UINT tx_thread_priority; /* Priority of thread (0-1023)  */
-	UINT tx_thread_state; /* Thread's execution state     */
-	UINT tx_thread_delayed_suspend; /* Delayed suspend flag         */
-	UINT tx_thread_suspending; /* Thread suspending flag       */
-	UINT tx_thread_preempt_threshold; /* Preemption threshold         */
-
-	/* Define the thread schedule hook. The usage of this is port/application specific,
-	   but when used, the function pointer designated is called whenever the thread is
-	   scheduled and unscheduled.  */
-	VOID (*tx_thread_schedule_hook)(struct TX_THREAD_STRUCT*, ULONG);
-
-	/* Nothing after this point is referenced by the target-specific
-	   assembly language.  Hence, information after this point can
-	   be added to the control block providing the complete system
-	   is recompiled.  */
-
-	/* Define the thread's entry point and input parameter.  */
-	VOID (*tx_thread_entry)(ULONG);
-	ULONG tx_thread_entry_parameter;
-
-	/* Define the thread's timer block.   This is used for thread
-	   sleep and timeout requests.  */
-	TX_TIMER_INTERNAL tx_thread_timer;
-
-	/* Define the thread's cleanup function and associated data.  This
-	   is used to cleanup various data structures when a thread
-	   suspension is lifted or terminated either by the user or
-	   a timeout.  */
-	VOID (*tx_thread_suspend_cleanup)(struct TX_THREAD_STRUCT*);
-	VOID* tx_thread_suspend_control_block;
-	struct TX_THREAD_STRUCT *tx_thread_suspended_next, *tx_thread_suspended_previous;
-	ULONG tx_thread_suspend_info;
-	VOID* tx_thread_additional_suspend_info;
-	UINT tx_thread_suspend_option;
-	UINT tx_thread_suspend_status;
-
-	/* Define the second port extension in the thread control block. This
-	   is typically defined to whitespace or a pointer type in tx_port.h.  */
-	TX_THREAD_EXTENSION_1
-
-	/* Define pointers to the next and previous threads in the
-	   created list.  */
-	struct TX_THREAD_STRUCT *tx_thread_created_next, *tx_thread_created_previous;
-
-	/* Define the third port extension in the thread control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_THREAD_EXTENSION_2
-
-	/* Define a pointer type for FileX extensions.  */
-	VOID* tx_thread_filex_ptr;
-
-	/* Define the priority inheritance variables. These will be used
-	   to manage priority inheritance changes applied to this thread
-	   as a result of mutex get operations.  */
-	UINT tx_thread_user_priority;
-	UINT tx_thread_user_preempt_threshold;
-	UINT tx_thread_inherit_priority;
-	UINT tx_thread_owned_mutex_count;
-	struct TX_MUTEX_STRUCT* tx_thread_owned_mutex_list;
-
-#ifdef TX_THREAD_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of times this thread is resumed.  */
-	ULONG tx_thread_performance_resume_count;
-
-	/* Define the number of times this thread suspends.  */
-	ULONG tx_thread_performance_suspend_count;
-
-	/* Define the number of times this thread is preempted by calling
-	   a ThreadX API service.  */
-	ULONG tx_thread_performance_solicited_preemption_count;
-
-	/* Define the number of times this thread is preempted by an
-	   ISR calling a ThreadX API service.  */
-	ULONG tx_thread_performance_interrupt_preemption_count;
-
-	/* Define the number of priority inversions for this thread.  */
-	ULONG tx_thread_performance_priority_inversion_count;
-
-	/* Define the last thread pointer to preempt this thread.  */
-	struct TX_THREAD_STRUCT* tx_thread_performance_last_preempting_thread;
-
-	/* Define the total number of times this thread was time-sliced.  */
-	ULONG tx_thread_performance_time_slice_count;
-
-	/* Define the total number of times this thread relinquishes.  */
-	ULONG tx_thread_performance_relinquish_count;
-
-	/* Define the total number of times this thread had a timeout.  */
-	ULONG tx_thread_performance_timeout_count;
-
-	/* Define the total number of times this thread had suspension lifted
-	   because of the tx_thread_wait_abort service.  */
-	ULONG tx_thread_performance_wait_abort_count;
-#endif
-
-	/* Define the highest stack pointer variable.  */
-	VOID* tx_thread_stack_highest_ptr; /* Stack highest usage pointer  */
-
-#ifndef TX_DISABLE_NOTIFY_CALLBACKS
-
-	/* Define the application callback routine used to notify the application when
-	   the thread is entered or exits.  */
-	VOID (*tx_thread_entry_exit_notify)(struct TX_THREAD_STRUCT*, UINT);
-#endif
-
-	/* Define the fourth port extension in the thread control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_THREAD_EXTENSION_3
-
-	/* Define the user extension field.  This typically is defined
-	   to white space, but some ports of ThreadX may need to have
-	   additional fields in the thread control block.  This is
-	   defined in the file tx_port.h.  */
-	TX_THREAD_USER_EXTENSION
-
-} TX_THREAD;
-
-typedef struct TX_THREAD_ONCE_CONTROL
-{
-	volatile int once_value;
-} TX_THREAD_ONCE __attribute__((aligned(sizeof(struct TX_THREAD_ONCE_CONTROL))));
-
-#define TX_THREAD_ONCE_INIT_VALUE 0U
-#define TX_THREAD_ONCE_INIT       \
-	{                             \
-		TX_THREAD_ONCE_INIT_VALUE \
-	}
-
-/* Define the block memory pool structure utilized by the application.  */
-
-typedef struct TX_BLOCK_POOL_STRUCT
-{
-	/* Define the block pool ID used for error checking.  */
-	ULONG tx_block_pool_id;
-
-	/* Define the block pool's name.  */
-	const CHAR* tx_block_pool_name;
-
-	/* Define the number of available memory blocks in the pool.  */
-	UINT tx_block_pool_available;
-
-	/* Save the initial number of blocks.  */
-	UINT tx_block_pool_total;
-
-	/* Define the head pointer of the available block pool.  */
-	UCHAR* tx_block_pool_available_list;
-
-	/* Save the start address of the block pool's memory area.  */
-	UCHAR* tx_block_pool_start;
-
-	/* Save the block pool's size in bytes.  */
-	ULONG tx_block_pool_size;
-
-	/* Save the individual memory block size - rounded for alignment.  */
-	UINT tx_block_pool_block_size;
-
-	/* Define the block pool suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_block_pool_suspension_list;
-	UINT tx_block_pool_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_BLOCK_POOL_STRUCT *tx_block_pool_created_next, *tx_block_pool_created_previous;
-
-#ifdef TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of block allocates.  */
-	ULONG tx_block_pool_performance_allocate_count;
-
-	/* Define the number of block releases.  */
-	ULONG tx_block_pool_performance_release_count;
-
-	/* Define the number of block pool suspensions.  */
-	ULONG tx_block_pool_performance_suspension_count;
-
-	/* Define the number of block pool timeouts.  */
-	ULONG tx_block_pool_performance_timeout_count;
-#endif
-
-	/* Define the port extension in the block pool control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_BLOCK_POOL_EXTENSION
-
-} TX_BLOCK_POOL;
-
-/* Define the byte memory pool structure utilized by the application.  */
-
-typedef struct TX_BYTE_POOL_STRUCT
-{
-	/* Define the byte pool ID used for error checking.  */
-	ULONG tx_byte_pool_id;
-
-	/* Define the byte pool's name.  */
-	const CHAR* tx_byte_pool_name;
-
-	/* Define the number of available bytes in the pool.  */
-	ULONG tx_byte_pool_available;
-
-	/* Define the number of fragments in the pool.  */
-	UINT tx_byte_pool_fragments;
-
-	/* Define the head pointer of byte pool.  */
-	UCHAR* tx_byte_pool_list;
-
-	/* Define the search pointer used for initial searching for memory
-	   in a byte pool.  */
-	UCHAR* tx_byte_pool_search;
-
-	/* Save the start address of the byte pool's memory area.  */
-	UCHAR* tx_byte_pool_start;
-
-	/* Save the byte pool's size in bytes.  */
-	ULONG tx_byte_pool_size;
-
-	/* This is used to mark the owner of the byte memory pool during
-	   a search.  If this value changes during the search, the local search
-	   pointer must be reset.  */
-	struct TX_THREAD_STRUCT* tx_byte_pool_owner;
-
-	/* Define the byte pool suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_byte_pool_suspension_list;
-	UINT tx_byte_pool_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_BYTE_POOL_STRUCT *tx_byte_pool_created_next, *tx_byte_pool_created_previous;
-
-#ifdef TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of allocates.  */
-	ULONG tx_byte_pool_performance_allocate_count;
-
-	/* Define the number of releases.  */
-	ULONG tx_byte_pool_performance_release_count;
-
-	/* Define the number of adjacent memory fragment merges.  */
-	ULONG tx_byte_pool_performance_merge_count;
-
-	/* Define the number of memory fragment splits.  */
-	ULONG tx_byte_pool_performance_split_count;
-
-	/* Define the number of memory fragments searched that either were not free or could not satisfy
-	   the
-	   request.  */
-	ULONG tx_byte_pool_performance_search_count;
-
-	/* Define the number of byte pool suspensions.  */
-	ULONG tx_byte_pool_performance_suspension_count;
-
-	/* Define the number of byte pool timeouts.  */
-	ULONG tx_byte_pool_performance_timeout_count;
-#endif
-
-	/* Define the port extension in the byte pool control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_BYTE_POOL_EXTENSION
-
-} TX_BYTE_POOL;
-
-/* Define the event flags group structure utilized by the application.  */
-
-typedef struct TX_EVENT_FLAGS_GROUP_STRUCT
-{
-	/* Define the event flags group ID used for error checking.  */
-	ULONG tx_event_flags_group_id;
-
-	/* Define the event flags group's name.  */
-	const CHAR* tx_event_flags_group_name;
-
-	/* Define the actual current event flags in this group. A zero in a
-	   particular bit indicates the event flag is not set.  */
-	ULONG tx_event_flags_group_current;
-
-	/* Define the reset search flag that is set when an ISR sets flags during
-	   the search of the suspended threads list.  */
-	UINT tx_event_flags_group_reset_search;
-
-	/* Define the event flags group suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_event_flags_group_suspension_list;
-	UINT tx_event_flags_group_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_EVENT_FLAGS_GROUP_STRUCT *tx_event_flags_group_created_next,
-		*tx_event_flags_group_created_previous;
-
-	/* Define the delayed clearing event flags.  */
-	ULONG tx_event_flags_group_delayed_clear;
-
-#ifdef TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of event flag sets.  */
-	ULONG tx_event_flags_group_performance_set_count;
-
-	/* Define the number of event flag gets.  */
-	ULONG tx_event_flags_group_performance_get_count;
-
-	/* Define the number of event flag suspensions.  */
-	ULONG tx_event_flags_group_performance_suspension_count;
-
-	/* Define the number of event flag timeouts.  */
-	ULONG tx_event_flags_group_performance_timeout_count;
-#endif
-
-#ifndef TX_DISABLE_NOTIFY_CALLBACKS
-
-	/* Define the application callback routine used to notify the application when
-	   an event flag is set.  */
-	VOID (*tx_event_flags_group_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT*);
-#endif
-
-	/* Define the port extension in the event flags group control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_EVENT_FLAGS_GROUP_EXTENSION
-
-} TX_EVENT_FLAGS_GROUP;
-
-/* Define the mutex structure utilized by the application.  */
-
-typedef struct TX_MUTEX_STRUCT
-{
-	/* Define the mutex ID used for error checking.  */
-	ULONG tx_mutex_id;
-
-	/* Define the mutex's name.  */
-	const CHAR* tx_mutex_name;
-
-	/* Define the mutex ownership count.  */
-	UINT tx_mutex_ownership_count;
-
-	/* Define the mutex ownership pointer.  This pointer points to the
-	   the thread that owns the mutex.  */
-	TX_THREAD* tx_mutex_owner;
-
-	/* Define the priority inheritance flag.  If this flag is set, priority
-	   inheritance will be in effect.  */
-	UINT tx_mutex_inherit;
-
-	/* Define the save area for the owning thread's original priority.  */
-	UINT tx_mutex_original_priority;
-
-	/* Define the mutex suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_mutex_suspension_list;
-	UINT tx_mutex_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_MUTEX_STRUCT *tx_mutex_created_next, *tx_mutex_created_previous;
-
-	/* Define the priority of the highest priority thread waiting for
-	   this mutex.  */
-	UINT tx_mutex_highest_priority_waiting;
-
-	/* Define the owned list next and previous pointers.  */
-	struct TX_MUTEX_STRUCT *tx_mutex_owned_next, *tx_mutex_owned_previous;
-
-#ifdef TX_MUTEX_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of mutex puts.  */
-	ULONG tx_mutex_performance_put_count;
-
-	/* Define the total number of mutex gets.  */
-	ULONG tx_mutex_performance_get_count;
-
-	/* Define the total number of mutex suspensions.  */
-	ULONG tx_mutex_performance_suspension_count;
-
-	/* Define the total number of mutex timeouts.  */
-	ULONG tx_mutex_performance_timeout_count;
-
-	/* Define the total number of priority inversions.  */
-	ULONG tx_mutex_performance_priority_inversion_count;
-
-	/* Define the total number of priority inheritance conditions.  */
-	ULONG tx_mutex_performance_priority_inheritance_count;
-#endif
-
-	/* Define the port extension in the mutex control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_MUTEX_EXTENSION
-
-} TX_MUTEX;
-
-/* Define the queue structure utilized by the application.  */
-
-typedef struct TX_QUEUE_STRUCT
-{
-	/* Define the queue ID used for error checking.  */
-	ULONG tx_queue_id;
-
-	/* Define the queue's name.  */
-	const CHAR* tx_queue_name;
-
-	/* Define the message size that was specified in queue creation.  */
-	UINT tx_queue_message_size;
-
-	/* Define the total number of messages in the queue.  */
-	UINT tx_queue_capacity;
-
-	/* Define the current number of messages enqueued and the available
-	   queue storage space.  */
-	UINT tx_queue_enqueued;
-	UINT tx_queue_available_storage;
-
-	/* Define pointers that represent the start and end for the queue's
-	   message area.  */
-	ULONG* tx_queue_start;
-	ULONG* tx_queue_end;
-
-	/* Define the queue read and write pointers.  Send requests use the write
-	   pointer while receive requests use the read pointer.  */
-	ULONG* tx_queue_read;
-	ULONG* tx_queue_write;
-
-	/* Define the queue suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_queue_suspension_list;
-	UINT tx_queue_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_QUEUE_STRUCT *tx_queue_created_next, *tx_queue_created_previous;
-
-#ifdef TX_QUEUE_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of messages sent to this queue.  */
-	ULONG tx_queue_performance_messages_sent_count;
-
-	/* Define the number of messages received from this queue.  */
-	ULONG tx_queue_performance_messages_received_count;
-
-	/* Define the number of empty suspensions on this queue.  */
-	ULONG tx_queue_performance_empty_suspension_count;
-
-	/* Define the number of full suspensions on this queue.  */
-	ULONG tx_queue_performance_full_suspension_count;
-
-	/* Define the number of full non-suspensions on this queue. These
-	   messages are rejected with an appropriate error code.  */
-	ULONG tx_queue_performance_full_error_count;
-
-	/* Define the number of queue timeouts.  */
-	ULONG tx_queue_performance_timeout_count;
-#endif
-
-#ifndef TX_DISABLE_NOTIFY_CALLBACKS
-
-	/* Define the application callback routine used to notify the application when
-	   the a message is sent to the queue.  */
-	VOID (*tx_queue_send_notify)(struct TX_QUEUE_STRUCT*);
-#endif
-
-	/* Define the port extension in the queue control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_QUEUE_EXTENSION
-
-} TX_QUEUE;
-
-/* Define the semaphore structure utilized by the application.  */
-
-typedef struct TX_SEMAPHORE_STRUCT
-{
-	/* Define the semaphore ID used for error checking.  */
-	ULONG tx_semaphore_id;
-
-	/* Define the semaphore's name.  */
-	const CHAR* tx_semaphore_name;
-
-	/* Define the actual semaphore count.  A zero means that no semaphore
-	   instance is available.  */
-	ULONG tx_semaphore_count;
-
-	/* Define the semaphore suspension list head along with a count of
-	   how many threads are suspended.  */
-	struct TX_THREAD_STRUCT* tx_semaphore_suspension_list;
-	UINT tx_semaphore_suspended_count;
-
-	/* Define the created list next and previous pointers.  */
-	struct TX_SEMAPHORE_STRUCT *tx_semaphore_created_next, *tx_semaphore_created_previous;
-
-#ifdef TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO
-
-	/* Define the number of semaphore puts.  */
-	ULONG tx_semaphore_performance_put_count;
-
-	/* Define the number of semaphore gets.  */
-	ULONG tx_semaphore_performance_get_count;
-
-	/* Define the number of semaphore suspensions.  */
-	ULONG tx_semaphore_performance_suspension_count;
-
-	/* Define the number of semaphore timeouts.  */
-	ULONG tx_semaphore_performance_timeout_count;
-#endif
-
-#ifndef TX_DISABLE_NOTIFY_CALLBACKS
-
-	/* Define the application callback routine used to notify the application when
-	   the a semaphore is put.  */
-	VOID (*tx_semaphore_put_notify)(struct TX_SEMAPHORE_STRUCT*);
-#endif
-
-	/* Define the port extension in the semaphore control block. This
-	   is typically defined to whitespace in tx_port.h.  */
-	TX_SEMAPHORE_EXTENSION
-
-} TX_SEMAPHORE;
-
-/* Define the system API mappings based on the error checking
-   selected by the user.  Note: this section is only applicable to
-   application source code, hence the conditional that turns off this
-   stuff when the include file is processed by the ThreadX source. */
-
-#ifndef TX_SOURCE_CODE
-
-/* Determine if error checking is desired.  If so, map API functions
-   to the appropriate error checking front-ends.  Otherwise, map API
-   functions to the core functions that actually perform the work.
-   Note: error checking is enabled by default.  */
-
-#ifdef TX_DISABLE_ERROR_CHECKING
-
-/* Services without error checking.  */
-
-#define tx_kernel_enter _tx_initialize_kernel_enter
-
-#define tx_block_allocate _tx_block_allocate
-#define tx_block_pool_create _tx_block_pool_create
-#define tx_block_pool_delete _tx_block_pool_delete
-#define tx_block_pool_info_get _tx_block_pool_info_get
-#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
-#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
-#define tx_block_pool_prioritize _tx_block_pool_prioritize
-#define tx_block_release _tx_block_release
-
-#define tx_byte_allocate _tx_byte_allocate
-#define tx_byte_pool_create _tx_byte_pool_create
-#define tx_byte_pool_delete _tx_byte_pool_delete
-#define tx_byte_pool_info_get _tx_byte_pool_info_get
-#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
-#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
-#define tx_byte_pool_prioritize _tx_byte_pool_prioritize
-#define tx_byte_release _tx_byte_release
-
-#define tx_event_flags_create _tx_event_flags_create
-#define tx_event_flags_delete _tx_event_flags_delete
-#define tx_event_flags_get _tx_event_flags_get
-#define tx_event_flags_info_get _tx_event_flags_info_get
-#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
-#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
-#define tx_event_flags_set _tx_event_flags_set
-#define tx_event_flags_set_notify _tx_event_flags_set_notify
-
-#ifdef TX_ENABLE_EVENT_LOGGING
-UINT _tx_el_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_el_interrupt_control
-#else
-#ifdef TX_ENABLE_EVENT_TRACE
-UINT _tx_trace_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_trace_interrupt_control
-#else
-#define tx_interrupt_control _tx_thread_interrupt_control
-#endif
-#endif
-
-#define tx_mutex_create _tx_mutex_create
-#define tx_mutex_delete _tx_mutex_delete
-#define tx_mutex_get _tx_mutex_get
-#define tx_mutex_info_get _tx_mutex_info_get
-#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
-#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
-#define tx_mutex_prioritize _tx_mutex_prioritize
-#define tx_mutex_put _tx_mutex_put
-
-#define tx_queue_create _tx_queue_create
-#define tx_queue_delete _tx_queue_delete
-#define tx_queue_flush _tx_queue_flush
-#define tx_queue_info_get _tx_queue_info_get
-#define tx_queue_performance_info_get _tx_queue_performance_info_get
-#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
-#define tx_queue_receive _tx_queue_receive
-#define tx_queue_send _tx_queue_send
-#define tx_queue_send_notify _tx_queue_send_notify
-#define tx_queue_front_send _tx_queue_front_send
-#define tx_queue_prioritize _tx_queue_prioritize
-
-#define tx_semaphore_ceiling_put _tx_semaphore_ceiling_put
-#define tx_semaphore_create _tx_semaphore_create
-#define tx_semaphore_delete _tx_semaphore_delete
-#define tx_semaphore_get _tx_semaphore_get
-#define tx_semaphore_info_get _tx_semaphore_info_get
-#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
-#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
-#define tx_semaphore_prioritize _tx_semaphore_prioritize
-#define tx_semaphore_put _tx_semaphore_put
-#define tx_semaphore_put_notify _tx_semaphore_put_notify
-
-#define tx_thread_create _tx_thread_create
-#define tx_thread_delete _tx_thread_delete
-#define tx_thread_entry_exit_notify _tx_thread_entry_exit_notify
-#define tx_thread_identify _tx_thread_identify
-#define tx_thread_info_get _tx_thread_info_get
-#define tx_thread_performance_info_get _tx_thread_performance_info_get
-#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
-#define tx_thread_preemption_change _tx_thread_preemption_change
-#define tx_thread_priority_change _tx_thread_priority_change
-#define tx_thread_relinquish _tx_thread_relinquish
-#define tx_thread_reset _tx_thread_reset
-#define tx_thread_resume _tx_thread_resume
-#define tx_thread_sleep _tx_thread_sleep
-#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
-#define tx_thread_suspend _tx_thread_suspend
-#define tx_thread_terminate _tx_thread_terminate
-#define tx_thread_time_slice_change _tx_thread_time_slice_change
-#define tx_thread_wait_abort _tx_thread_wait_abort
-#define tx_thread_once _tx_thread_once
-#define tx_thread_getspecific _tx_thread_getspecific
-#define tx_thread_setspecific _tx_thread_setspecific
-
-#define tx_time_get _tx_time_get
-#define tx_time_set _tx_time_set
-#define tx_timer_activate _tx_timer_activate
-#define tx_timer_change _tx_timer_change
-#define tx_timer_create _tx_timer_create
-#define tx_timer_deactivate _tx_timer_deactivate
-#define tx_timer_delete _tx_timer_delete
-#define tx_timer_info_get _tx_timer_info_get
-#define tx_timer_performance_info_get _tx_timer_performance_info_get
-#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
-
-#define tx_trace_enable _tx_trace_enable
-#define tx_trace_event_filter _tx_trace_event_filter
-#define tx_trace_event_unfilter _tx_trace_event_unfilter
-#define tx_trace_disable _tx_trace_disable
-#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
-#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
-#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
-#define tx_trace_user_event_insert _tx_trace_user_event_insert
-
-#else
-
-/* Services with error checking.  */
-
-#define tx_kernel_enter _tx_initialize_kernel_enter
-
-/* Define the system API mappings depending on the runtime error
-   checking behavior selected by the user.  */
-
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-
-/* Services with MULTI runtime error checking ThreadX.  */
-
-#define tx_block_allocate _txr_block_allocate
-#define tx_block_pool_create(p, n, b, s, l) \
-	_txr_block_pool_create(p, n, b, s, l, sizeof(TX_BLOCK_POOL))
-#define tx_block_pool_delete _txr_block_pool_delete
-#define tx_block_pool_info_get _txr_block_pool_info_get
-#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
-#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
-#define tx_block_pool_prioritize _txr_block_pool_prioritize
-#define tx_block_release _txr_block_release
-
-#define tx_byte_allocate _txr_byte_allocate
-#define tx_byte_pool_create(p, n, s, l) _txr_byte_pool_create(p, n, s, l, sizeof(TX_BYTE_POOL))
-#define tx_byte_pool_delete _txr_byte_pool_delete
-#define tx_byte_pool_info_get _txr_byte_pool_info_get
-#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
-#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
-#define tx_byte_pool_prioritize _txr_byte_pool_prioritize
-#define tx_byte_release _txr_byte_release
-
-#define tx_event_flags_create(g, n) _txr_event_flags_create(g, n, sizeof(TX_EVENT_FLAGS_GROUP))
-#define tx_event_flags_delete _txr_event_flags_delete
-#define tx_event_flags_get _txr_event_flags_get
-#define tx_event_flags_info_get _txr_event_flags_info_get
-#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
-#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
-#define tx_event_flags_set _txr_event_flags_set
-#define tx_event_flags_set_notify _txr_event_flags_set_notify
-
-#ifdef TX_ENABLE_EVENT_LOGGING
-UINT _tx_el_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_el_interrupt_control
-#else
-#ifdef TX_ENABLE_EVENT_TRACE
-UINT _tx_trace_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_trace_interrupt_control
-#else
-#define tx_interrupt_control _tx_thread_interrupt_control
-#endif
-#endif
-
-#define tx_mutex_create(m, n, i) _txr_mutex_create(m, n, i, sizeof(TX_MUTEX))
-#define tx_mutex_delete _txr_mutex_delete
-#define tx_mutex_get _txr_mutex_get
-#define tx_mutex_info_get _txr_mutex_info_get
-#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
-#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
-#define tx_mutex_prioritize _txr_mutex_prioritize
-#define tx_mutex_put _txr_mutex_put
-
-#define tx_queue_create(q, n, m, s, l) _txr_queue_create(q, n, m, s, l, sizeof(TX_QUEUE))
-#define tx_queue_delete _txr_queue_delete
-#define tx_queue_flush _txr_queue_flush
-#define tx_queue_info_get _txr_queue_info_get
-#define tx_queue_performance_info_get _tx_queue_performance_info_get
-#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
-#define tx_queue_receive _txr_queue_receive
-#define tx_queue_send _txr_queue_send
-#define tx_queue_send_notify _txr_queue_send_notify
-#define tx_queue_front_send _txr_queue_front_send
-#define tx_queue_prioritize _txr_queue_prioritize
-
-#define tx_semaphore_ceiling_put _txr_semaphore_ceiling_put
-#define tx_semaphore_create(s, n, i) _txr_semaphore_create(s, n, i, sizeof(TX_SEMAPHORE))
-#define tx_semaphore_delete _txr_semaphore_delete
-#define tx_semaphore_get _txr_semaphore_get
-#define tx_semaphore_info_get _txr_semaphore_info_get
-#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
-#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
-#define tx_semaphore_prioritize _txr_semaphore_prioritize
-#define tx_semaphore_put _txr_semaphore_put
-#define tx_semaphore_put_notify _txr_semaphore_put_notify
-
-#define tx_thread_create(t, n, e, i, s, l, p, r, c, a) \
-	_txr_thread_create(t, n, e, i, s, l, p, r, c, a, sizeof(TX_THREAD))
-#define tx_thread_delete _txr_thread_delete
-#define tx_thread_entry_exit_notify _txr_thread_entry_exit_notify
-#define tx_thread_identify _tx_thread_identify
-#define tx_thread_info_get _txr_thread_info_get
-#define tx_thread_performance_info_get _tx_thread_performance_info_get
-#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
-#define tx_thread_preemption_change _txr_thread_preemption_change
-#define tx_thread_priority_change _txr_thread_priority_change
-#define tx_thread_relinquish _txe_thread_relinquish
-#define tx_thread_reset _txr_thread_reset
-#define tx_thread_resume _txr_thread_resume
-#define tx_thread_sleep _tx_thread_sleep
-#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
-#define tx_thread_suspend _txr_thread_suspend
-#define tx_thread_terminate _txr_thread_terminate
-#define tx_thread_time_slice_change _txr_thread_time_slice_change
-#define tx_thread_wait_abort _txr_thread_wait_abort
-#define tx_thread_once _tx_thread_once
-#define tx_thread_getspecific _tx_thread_getspecific
-#define tx_thread_setspecific _tx_thread_setspecific
-
-#define tx_time_get _tx_time_get
-#define tx_time_set _tx_time_set
-#define tx_timer_activate _txr_timer_activate
-#define tx_timer_change _txr_timer_change
-#define tx_timer_create(t, n, e, i, c, r, a) \
-	_txr_timer_create(t, n, e, i, c, r, a, sizeof(TX_TIMER))
-#define tx_timer_deactivate _txr_timer_deactivate
-#define tx_timer_delete _txr_timer_delete
-#define tx_timer_info_get _txr_timer_info_get
-#define tx_timer_performance_info_get _tx_timer_performance_info_get
-#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
-
-#define tx_trace_enable _tx_trace_enable
-#define tx_trace_event_filter _tx_trace_event_filter
-#define tx_trace_event_unfilter _tx_trace_event_unfilter
-#define tx_trace_disable _tx_trace_disable
-#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
-#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
-#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
-#define tx_trace_user_event_insert _tx_trace_user_event_insert
-
-#else
-
-#define tx_block_allocate _txe_block_allocate
-#define tx_block_pool_create(p, n, b, s, l) \
-	_txe_block_pool_create(p, n, b, s, l, sizeof(TX_BLOCK_POOL))
-#define tx_block_pool_delete _txe_block_pool_delete
-#define tx_block_pool_info_get _txe_block_pool_info_get
-#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
-#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
-#define tx_block_pool_prioritize _txe_block_pool_prioritize
-#define tx_block_release _txe_block_release
-
-#define tx_byte_allocate _txe_byte_allocate
-#define tx_byte_pool_create(p, n, s, l) _txe_byte_pool_create(p, n, s, l, sizeof(TX_BYTE_POOL))
-#define tx_byte_pool_delete _txe_byte_pool_delete
-#define tx_byte_pool_info_get _txe_byte_pool_info_get
-#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
-#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
-#define tx_byte_pool_prioritize _txe_byte_pool_prioritize
-#define tx_byte_release _txe_byte_release
-
-#define tx_event_flags_create(g, n) _txe_event_flags_create(g, n, sizeof(TX_EVENT_FLAGS_GROUP))
-#define tx_event_flags_delete _txe_event_flags_delete
-#define tx_event_flags_get _txe_event_flags_get
-#define tx_event_flags_info_get _txe_event_flags_info_get
-#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
-#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
-#define tx_event_flags_set _txe_event_flags_set
-#define tx_event_flags_set_notify _txe_event_flags_set_notify
-
-#ifdef TX_ENABLE_EVENT_LOGGING
-UINT _tx_el_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_el_interrupt_control
-#else
-#ifdef TX_ENABLE_EVENT_TRACE
-UINT _tx_trace_interrupt_control(UINT new_posture);
-#define tx_interrupt_control _tx_trace_interrupt_control
-#else
-#define tx_interrupt_control _tx_thread_interrupt_control
-#endif
-#endif
-
-#define tx_mutex_create(m, n, i) _txe_mutex_create(m, n, i, sizeof(TX_MUTEX))
-#define tx_mutex_delete _txe_mutex_delete
-#define tx_mutex_get _txe_mutex_get
-#define tx_mutex_info_get _txe_mutex_info_get
-#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
-#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
-#define tx_mutex_prioritize _txe_mutex_prioritize
-#define tx_mutex_put _txe_mutex_put
-
-#define tx_queue_create(q, n, m, s, l) _txe_queue_create(q, n, m, s, l, sizeof(TX_QUEUE))
-#define tx_queue_delete _txe_queue_delete
-#define tx_queue_flush _txe_queue_flush
-#define tx_queue_info_get _txe_queue_info_get
-#define tx_queue_performance_info_get _tx_queue_performance_info_get
-#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
-#define tx_queue_receive _txe_queue_receive
-#define tx_queue_send _txe_queue_send
-#define tx_queue_send_notify _txe_queue_send_notify
-#define tx_queue_front_send _txe_queue_front_send
-#define tx_queue_prioritize _txe_queue_prioritize
-
-#define tx_semaphore_ceiling_put _txe_semaphore_ceiling_put
-#define tx_semaphore_create(s, n, i) _txe_semaphore_create(s, n, i, sizeof(TX_SEMAPHORE))
-#define tx_semaphore_delete _txe_semaphore_delete
-#define tx_semaphore_get _txe_semaphore_get
-#define tx_semaphore_info_get _txe_semaphore_info_get
-#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
-#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
-#define tx_semaphore_prioritize _txe_semaphore_prioritize
-#define tx_semaphore_put _txe_semaphore_put
-#define tx_semaphore_put_notify _txe_semaphore_put_notify
-
-#define tx_thread_create(t, n, e, i, s, l, p, r, c, a) \
-	_txe_thread_create(t, n, e, i, s, l, p, r, c, a, sizeof(TX_THREAD))
-#define tx_thread_delete _txe_thread_delete
-#define tx_thread_entry_exit_notify _txe_thread_entry_exit_notify
-#define tx_thread_identify _tx_thread_identify
-#define tx_thread_info_get _txe_thread_info_get
-#define tx_thread_performance_info_get _tx_thread_performance_info_get
-#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
-#define tx_thread_preemption_change _txe_thread_preemption_change
-#define tx_thread_priority_change _txe_thread_priority_change
-#define tx_thread_relinquish _txe_thread_relinquish
-#define tx_thread_reset _txe_thread_reset
-#define tx_thread_resume _txe_thread_resume
-#define tx_thread_sleep _tx_thread_sleep
-#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
-#define tx_thread_suspend _txe_thread_suspend
-#define tx_thread_terminate _txe_thread_terminate
-#define tx_thread_time_slice_change _txe_thread_time_slice_change
-#define tx_thread_wait_abort _txe_thread_wait_abort
-#define tx_thread_once _tx_thread_once
-#define tx_thread_getspecific _tx_thread_getspecific
-#define tx_thread_setspecific _tx_thread_setspecific
-
-#define tx_time_get _tx_time_get
-#define tx_time_set _tx_time_set
-#define tx_timer_activate _txe_timer_activate
-#define tx_timer_change _txe_timer_change
-#define tx_timer_create(t, n, e, i, c, r, a) \
-	_txe_timer_create(t, n, e, i, c, r, a, sizeof(TX_TIMER))
-#define tx_timer_deactivate _txe_timer_deactivate
-#define tx_timer_delete _txe_timer_delete
-#define tx_timer_info_get _txe_timer_info_get
-#define tx_timer_performance_info_get _tx_timer_performance_info_get
-#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
-
-#define tx_trace_enable _tx_trace_enable
-#define tx_trace_event_filter _tx_trace_event_filter
-#define tx_trace_event_unfilter _tx_trace_event_unfilter
-#define tx_trace_disable _tx_trace_disable
-#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
-#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
-#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
-#define tx_trace_user_event_insert _tx_trace_user_event_insert
-
-#endif
-#endif
-
-/* Declare the tx_application_define function as having C linkage.  */
-
-VOID tx_application_define(VOID*);
-
-/* Define the ThreadX entry function that is typically called from the application's main()
- * function.  */
-
-VOID tx_kernel_enter(VOID);
-
-/* Define the function prototypes of the ThreadX API.  */
-
-UINT tx_block_allocate(TX_BLOCK_POOL* pool_ptr, VOID** block_ptr, ULONG wait_option);
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
-						   VOID* pool_start, ULONG pool_size);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
-							VOID* pool_start, ULONG pool_size, UINT pool_control_block_size);
-#else
-UINT _txe_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
-							VOID* pool_start, ULONG pool_size, UINT pool_control_block_size);
-#endif
-#endif
-UINT tx_block_pool_delete(TX_BLOCK_POOL* pool_ptr);
-UINT tx_block_pool_info_get(TX_BLOCK_POOL* pool_ptr, const CHAR** name, ULONG* available_blocks,
-							ULONG* total_blocks, TX_THREAD** first_suspended,
-							ULONG* suspended_count, TX_BLOCK_POOL** next_pool);
-UINT tx_block_pool_performance_info_get(TX_BLOCK_POOL* pool_ptr, ULONG* allocates, ULONG* releases,
-										ULONG* suspensions, ULONG* timeouts);
-UINT tx_block_pool_performance_system_info_get(ULONG* allocates, ULONG* releases,
-											   ULONG* suspensions, ULONG* timeouts);
-UINT tx_block_pool_prioritize(TX_BLOCK_POOL* pool_ptr);
-UINT tx_block_release(VOID* block_ptr);
-
-UINT tx_byte_allocate(TX_BYTE_POOL* pool_ptr, VOID** memory_ptr, ULONG memory_size,
-					  ULONG wait_option);
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
-						  ULONG pool_size);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
-						   ULONG pool_size, UINT pool_control_block_size);
-#else
-UINT _txe_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
-						   ULONG pool_size, UINT pool_control_block_size);
-#endif
-#endif
-UINT tx_byte_pool_delete(TX_BYTE_POOL* pool_ptr);
-UINT tx_byte_pool_info_get(TX_BYTE_POOL* pool_ptr, const CHAR** name, ULONG* available_bytes,
-						   ULONG* fragments, TX_THREAD** first_suspended, ULONG* suspended_count,
-						   TX_BYTE_POOL** next_pool);
-UINT tx_byte_pool_performance_info_get(TX_BYTE_POOL* pool_ptr, ULONG* allocates, ULONG* releases,
-									   ULONG* fragments_searched, ULONG* merges, ULONG* splits,
-									   ULONG* suspensions, ULONG* timeouts);
-UINT tx_byte_pool_performance_system_info_get(ULONG* allocates, ULONG* releases,
-											  ULONG* fragments_searched, ULONG* merges,
-											  ULONG* splits, ULONG* suspensions, ULONG* timeouts);
-UINT tx_byte_pool_prioritize(TX_BYTE_POOL* pool_ptr);
-UINT tx_byte_release(VOID* memory_ptr);
-
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr,
-							 UINT event_control_block_size);
-#else
-UINT _txe_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr,
-							 UINT event_control_block_size);
-#endif
-#endif
-UINT tx_event_flags_delete(TX_EVENT_FLAGS_GROUP* group_ptr);
-UINT tx_event_flags_get(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG requested_flags, UINT get_option,
-						ULONG* actual_flags_ptr, ULONG wait_option);
-UINT tx_event_flags_info_get(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR** name,
-							 ULONG* current_flags, TX_THREAD** first_suspended,
-							 ULONG* suspended_count, TX_EVENT_FLAGS_GROUP** next_group);
-UINT tx_event_flags_performance_info_get(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG* sets, ULONG* gets,
-										 ULONG* suspensions, ULONG* timeouts);
-UINT tx_event_flags_performance_system_info_get(ULONG* sets, ULONG* gets, ULONG* suspensions,
-												ULONG* timeouts);
-UINT tx_event_flags_set(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG flags_to_set, UINT set_option);
-UINT tx_event_flags_set_notify(TX_EVENT_FLAGS_GROUP* group_ptr,
-							   VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP*));
-
-UINT tx_interrupt_control(UINT new_posture);
-
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit,
-					   UINT mutex_control_block_size);
-#else
-UINT _txe_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit,
-					   UINT mutex_control_block_size);
-#endif
-#endif
-UINT tx_mutex_delete(TX_MUTEX* mutex_ptr);
-UINT tx_mutex_get(TX_MUTEX* mutex_ptr, ULONG wait_option);
-UINT tx_mutex_info_get(TX_MUTEX* mutex_ptr, const CHAR** name, ULONG* count, TX_THREAD** owner,
-					   TX_THREAD** first_suspended, ULONG* suspended_count, TX_MUTEX** next_mutex);
-UINT tx_mutex_performance_info_get(TX_MUTEX* mutex_ptr, ULONG* puts, ULONG* gets,
-								   ULONG* suspensions, ULONG* timeouts, ULONG* inversions,
-								   ULONG* inheritances);
-UINT tx_mutex_performance_system_info_get(ULONG* puts, ULONG* gets, ULONG* suspensions,
-										  ULONG* timeouts, ULONG* inversions, ULONG* inheritances);
-UINT tx_mutex_prioritize(TX_MUTEX* mutex_ptr);
-UINT tx_mutex_put(TX_MUTEX* mutex_ptr);
-
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
-					  VOID* queue_start, ULONG queue_size);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
-					   VOID* queue_start, ULONG queue_size, UINT queue_control_block_size);
-#else
-UINT _txe_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
-					   VOID* queue_start, ULONG queue_size, UINT queue_control_block_size);
-#endif
-#endif
-UINT tx_queue_delete(TX_QUEUE* queue_ptr);
-UINT tx_queue_flush(TX_QUEUE* queue_ptr);
-UINT tx_queue_info_get(TX_QUEUE* queue_ptr, const CHAR** name, ULONG* enqueued,
-					   ULONG* available_storage, TX_THREAD** first_suspended,
-					   ULONG* suspended_count, TX_QUEUE** next_queue);
-UINT tx_queue_performance_info_get(TX_QUEUE* queue_ptr, ULONG* messages_sent,
-								   ULONG* messages_received, ULONG* empty_suspensions,
-								   ULONG* full_suspensions, ULONG* full_errors, ULONG* timeouts);
-UINT tx_queue_performance_system_info_get(ULONG* messages_sent, ULONG* messages_received,
-										  ULONG* empty_suspensions, ULONG* full_suspensions,
-										  ULONG* full_errors, ULONG* timeouts);
-UINT tx_queue_receive(TX_QUEUE* queue_ptr, VOID* destination_ptr, ULONG wait_option);
-UINT tx_queue_send(TX_QUEUE* queue_ptr, VOID* source_ptr, ULONG wait_option);
-UINT tx_queue_send_notify(TX_QUEUE* queue_ptr, VOID (*queue_send_notify)(TX_QUEUE*));
-UINT tx_queue_front_send(TX_QUEUE* queue_ptr, VOID* source_ptr, ULONG wait_option);
-UINT tx_queue_prioritize(TX_QUEUE* queue_ptr);
-
-UINT tx_semaphore_ceiling_put(TX_SEMAPHORE* semaphore_ptr, ULONG ceiling);
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count,
-						   UINT semaphore_control_block_size);
-#else
-UINT _txe_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count,
-						   UINT semaphore_control_block_size);
-#endif
-#endif
-UINT tx_semaphore_delete(TX_SEMAPHORE* semaphore_ptr);
-UINT tx_semaphore_get(TX_SEMAPHORE* semaphore_ptr, ULONG wait_option);
-UINT tx_semaphore_info_get(TX_SEMAPHORE* semaphore_ptr, const CHAR** name, ULONG* current_value,
-						   TX_THREAD** first_suspended, ULONG* suspended_count,
-						   TX_SEMAPHORE** next_semaphore);
-UINT tx_semaphore_performance_info_get(TX_SEMAPHORE* semaphore_ptr, ULONG* puts, ULONG* gets,
-									   ULONG* suspensions, ULONG* timeouts);
-UINT tx_semaphore_performance_system_info_get(ULONG* puts, ULONG* gets, ULONG* suspensions,
-											  ULONG* timeouts);
-UINT tx_semaphore_prioritize(TX_SEMAPHORE* semaphore_ptr);
-UINT tx_semaphore_put(TX_SEMAPHORE* semaphore_ptr);
-UINT tx_semaphore_put_notify(TX_SEMAPHORE* semaphore_ptr,
-							 VOID (*semaphore_put_notify)(TX_SEMAPHORE*));
-
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
-					   ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
-					   UINT preempt_threshold, ULONG time_slice, UINT auto_start);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
-						ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
-						UINT preempt_threshold, ULONG time_slice, UINT auto_start,
-						UINT thread_control_block_size);
-#else
-UINT _txe_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
-						ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
-						UINT preempt_threshold, ULONG time_slice, UINT auto_start,
-						UINT thread_control_block_size);
-#endif
-#endif
-UINT tx_thread_delete(TX_THREAD* thread_ptr);
-UINT tx_thread_entry_exit_notify(TX_THREAD* thread_ptr,
-								 VOID (*thread_entry_exit_notify)(TX_THREAD*, UINT));
-TX_THREAD* tx_thread_identify(VOID);
-UINT tx_thread_info_get(TX_THREAD* thread_ptr, const CHAR** name, UINT* state, ULONG* run_count,
-						UINT* priority, UINT* preemption_threshold, ULONG* time_slice,
-						TX_THREAD** next_thread, TX_THREAD** next_suspended_thread);
-UINT tx_thread_performance_info_get(TX_THREAD* thread_ptr, ULONG* resumptions, ULONG* suspensions,
-									ULONG* solicited_preemptions, ULONG* interrupt_preemptions,
-									ULONG* priority_inversions, ULONG* time_slices,
-									ULONG* relinquishes, ULONG* timeouts, ULONG* wait_aborts,
-									TX_THREAD** last_preempted_by);
-UINT tx_thread_performance_system_info_get(ULONG* resumptions, ULONG* suspensions,
-										   ULONG* solicited_preemptions,
-										   ULONG* interrupt_preemptions, ULONG* priority_inversions,
-										   ULONG* time_slices, ULONG* relinquishes, ULONG* timeouts,
-										   ULONG* wait_aborts, ULONG* non_idle_returns,
-										   ULONG* idle_returns);
-UINT tx_thread_preemption_change(TX_THREAD* thread_ptr, UINT new_threshold, UINT* old_threshold);
-UINT tx_thread_priority_change(TX_THREAD* thread_ptr, UINT new_priority, UINT* old_priority);
-VOID tx_thread_relinquish(VOID);
-UINT tx_thread_reset(TX_THREAD* thread_ptr);
-UINT tx_thread_resume(TX_THREAD* thread_ptr);
-UINT tx_thread_sleep(ULONG timer_ticks);
-UINT tx_thread_stack_error_notify(VOID (*stack_error_handler)(TX_THREAD*));
-UINT tx_thread_suspend(TX_THREAD* thread_ptr);
-UINT tx_thread_terminate(TX_THREAD* thread_ptr);
-UINT tx_thread_time_slice_change(TX_THREAD* thread_ptr, ULONG new_time_slice,
-								 ULONG* old_time_slice);
-UINT tx_thread_wait_abort(TX_THREAD* thread_ptr);
-UINT tx_thread_once(TX_THREAD_ONCE* once_control, void (*once_routine)(void));
-VOID* tx_thread_getspecific(TX_THREAD_KEY key);
-VOID tx_thread_setspecific(TX_THREAD_KEY key, void* data);
-
-ULONG tx_time_get(VOID);
-VOID tx_time_set(ULONG new_time);
-
-UINT tx_timer_activate(TX_TIMER* timer_ptr);
-UINT tx_timer_change(TX_TIMER* timer_ptr, ULONG initial_ticks, ULONG reschedule_ticks);
-#ifdef TX_DISABLE_ERROR_CHECKING
-UINT _tx_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr, VOID (*expiration_function)(ULONG),
-					  ULONG expiration_input, ULONG initial_ticks, ULONG reschedule_ticks,
-					  UINT auto_activate);
-#else
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-UINT _txr_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr,
-					   VOID (*expiration_function)(ULONG), ULONG expiration_input,
-					   ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate,
-					   UINT timer_control_block_size);
-#else
-UINT _txe_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr,
-					   VOID (*expiration_function)(ULONG), ULONG expiration_input,
-					   ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate,
-					   UINT timer_control_block_size);
-#endif
-#endif
-UINT tx_timer_deactivate(TX_TIMER* timer_ptr);
-UINT tx_timer_delete(TX_TIMER* timer_ptr);
-UINT tx_timer_info_get(TX_TIMER* timer_ptr, const CHAR** name, UINT* active, ULONG* remaining_ticks,
-					   ULONG* reschedule_ticks, TX_TIMER** next_timer);
-UINT tx_timer_performance_info_get(TX_TIMER* timer_ptr, ULONG* activates, ULONG* reactivates,
-								   ULONG* deactivates, ULONG* expirations,
-								   ULONG* expiration_adjusts);
-UINT tx_timer_performance_system_info_get(ULONG* activates, ULONG* reactivates, ULONG* deactivates,
-										  ULONG* expirations, ULONG* expiration_adjusts);
-
-UINT tx_trace_enable(VOID* trace_buffer_start, ULONG trace_buffer_size, ULONG registry_entries);
-UINT tx_trace_event_filter(ULONG event_filter_bits);
-UINT tx_trace_event_unfilter(ULONG event_unfilter_bits);
-UINT tx_trace_disable(VOID);
-VOID tx_trace_isr_enter_insert(ULONG isr_id);
-VOID tx_trace_isr_exit_insert(ULONG isr_id);
-UINT tx_trace_buffer_full_notify(VOID (*full_buffer_callback)(VOID*));
-UINT tx_trace_user_event_insert(ULONG event_id, ULONG info_field_1, ULONG info_field_2,
-								ULONG info_field_3, ULONG info_field_4);
-
-#endif
-
-/* Define safety critical configuration and exception handling.  */
-
-#ifdef TX_SAFETY_CRITICAL
-
-/* Ensure the maximum number of priorities is defined in safety critical mode.  */
-#ifndef TX_MAX_PRIORITIES
-#error "tx_port.h: TX_MAX_PRIORITIES not defined."
-#endif
-
-/* Ensure the maximum number of priorities is a multiple of 32.  */
-#if(TX_MAX_PRIORITIES % 32) != 0
-#error "tx_port.h: TX_MAX_PRIORITIES must be a multiple of 32."
-#endif
-
-/* Ensure error checking is enabled.  */
-#ifdef TX_DISABLE_ERROR_CHECKING
-#error "TX_DISABLE_ERROR_CHECKING must not be defined."
-#endif
-
-/* Ensure timer ISR processing is not defined.  */
-#ifdef TX_TIMER_PROCESS_IN_ISR
-#error "TX_TIMER_PROCESS_IN_ISR must not be defined."
-#endif
-
-/* Ensure timer reactivation in-line is not defined.  */
-#ifdef TX_REACTIVATE_INLINE
-#error "TX_REACTIVATE_INLINE must not be defined."
-#endif
-
-/* Ensure disable stack filling is not defined.  */
-#ifdef TX_DISABLE_STACK_FILLING
-#error "TX_DISABLE_STACK_FILLING must not be defined."
-#endif
-
-/* Ensure enable stack checking is not defined.  */
-#ifdef TX_ENABLE_STACK_CHECKING
-#error "TX_ENABLE_STACK_CHECKING must not be defined."
-#endif
-
-/* Ensure disable preemption-threshold is not defined.  */
-#ifdef TX_DISABLE_PREEMPTION_THRESHOLD
-#error "TX_DISABLE_PREEMPTION_THRESHOLD must not be defined."
-#endif
-
-/* Ensure disable redundant clearing is not defined.  */
-#ifdef TX_DISABLE_REDUNDANT_CLEARING
-#error "TX_DISABLE_REDUNDANT_CLEARING must not be defined."
-#endif
-
-/* Ensure no timer is not defined.  */
-#ifdef TX_NO_TIMER
-#error "TX_NO_TIMER must not be defined."
-#endif
-
-/* Ensure disable notify callbacks is not defined.  */
-#ifdef TX_DISABLE_NOTIFY_CALLBACKS
-#error "TX_DISABLE_NOTIFY_CALLBACKS must not be defined."
-#endif
-
-/* Ensure inline thread suspend/resume is not defined.  */
-#ifdef TX_INLINE_THREAD_RESUME_SUSPEND
-#error "TX_INLINE_THREAD_RESUME_SUSPEND must not be defined."
-#endif
-
-/* Ensure not interruptable is not defined.  */
-#ifdef TX_NOT_INTERRUPTABLE
-#error "TX_NOT_INTERRUPTABLE must not be defined."
-#endif
-
-/* Ensure event trace enable is not defined.  */
-#ifdef TX_ENABLE_EVENT_TRACE
-#error "TX_ENABLE_EVENT_TRACE must not be defined."
-#endif
-
-/* Ensure block pool performance info enable is not defined.  */
-#ifdef TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO
-#error "TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure byte pool performance info enable is not defined.  */
-#ifdef TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO
-#error "TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure event flag performance info enable is not defined.  */
-#ifdef TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO
-#error "TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure mutex performance info enable is not defined.   */
-#ifdef TX_MUTEX_ENABLE_PERFORMANCE_INFO
-#error "TX_MUTEX_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure queue performance info enable is not defined.  */
-#ifdef TX_QUEUE_ENABLE_PERFORMANCE_INFO
-#error "TX_QUEUE_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure semaphore performance info enable is not defined.  */
-#ifdef TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO
-#error "TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure thread performance info enable is not defined.  */
-#ifdef TX_THREAD_ENABLE_PERFORMANCE_INFO
-#error "TX_THREAD_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Ensure timer performance info enable is not defined.  */
-#ifdef TX_TIMER_ENABLE_PERFORMANCE_INFO
-#error "TX_TIMER_ENABLE_PERFORMANCE_INFO must not be defined."
-#endif
-
-/* Now define the safety critical exception handler.  */
-
-VOID _tx_safety_critical_exception_handler(const CHAR* file_name, INT line_number, UINT status);
-
-#ifndef TX_SAFETY_CRITICAL_EXCEPTION
-#define TX_SAFETY_CRITICAL_EXCEPTION(a, b, c) _tx_safety_critical_exception_handler(a, b, c);
-#endif
-
-#ifndef TX_SAFETY_CRITICAL_EXCEPTION_HANDLER
-#define TX_SAFETY_CRITICAL_EXCEPTION_HANDLER                                           \
-	VOID _tx_safety_critical_exception_handler(const CHAR* file_name, INT line_number, \
-											   UINT status)                            \
-	{                                                                                  \
-		while(1)                                                                       \
-		{                                                                              \
-		}                                                                              \
-	}
-#endif
-#endif
-
-#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
-
-/* Define ThreadX API MULTI run-time error checking function.  */
-void __ghs_rnerr(char* errMsg, int stackLevels, int stackTraceDisplay, void* hexVal);
-
-#endif
-
-/* Bring in the event logging constants and prototypes.  Note that
-   TX_ENABLE_EVENT_LOGGING must be defined when building the ThreadX
-   library components in order to enable event logging.  */
-
-#ifdef TX_ENABLE_EVENT_LOGGING
-#include "tx_el.h"
-#else
-#ifndef TX_SOURCE_CODE
-#define _tx_el_user_event_insert(a, b, c, d, e)
-#endif
-#define TX_EL_INITIALIZE
-#define TX_EL_THREAD_REGISTER(a)
-#define TX_EL_THREAD_UNREGISTER(a)
-#define TX_EL_THREAD_STATUS_CHANGE_INSERT(a, b)
-#define TX_EL_BYTE_ALLOCATE_INSERT
-#define TX_EL_BYTE_POOL_CREATE_INSERT
-#define TX_EL_BYTE_POOL_DELETE_INSERT
-#define TX_EL_BYTE_RELEASE_INSERT
-#define TX_EL_BLOCK_ALLOCATE_INSERT
-#define TX_EL_BLOCK_POOL_CREATE_INSERT
-#define TX_EL_BLOCK_POOL_DELETE_INSERT
-#define TX_EL_BLOCK_RELEASE_INSERT
-#define TX_EL_EVENT_FLAGS_CREATE_INSERT
-#define TX_EL_EVENT_FLAGS_DELETE_INSERT
-#define TX_EL_EVENT_FLAGS_GET_INSERT
-#define TX_EL_EVENT_FLAGS_SET_INSERT
-#define TX_EL_INTERRUPT_CONTROL_INSERT
-#define TX_EL_QUEUE_CREATE_INSERT
-#define TX_EL_QUEUE_DELETE_INSERT
-#define TX_EL_QUEUE_FLUSH_INSERT
-#define TX_EL_QUEUE_RECEIVE_INSERT
-#define TX_EL_QUEUE_SEND_INSERT
-#define TX_EL_SEMAPHORE_CREATE_INSERT
-#define TX_EL_SEMAPHORE_DELETE_INSERT
-#define TX_EL_SEMAPHORE_GET_INSERT
-#define TX_EL_SEMAPHORE_PUT_INSERT
-#define TX_EL_THREAD_CREATE_INSERT
-#define TX_EL_THREAD_DELETE_INSERT
-#define TX_EL_THREAD_IDENTIFY_INSERT
-#define TX_EL_THREAD_PREEMPTION_CHANGE_INSERT
-#define TX_EL_THREAD_PRIORITY_CHANGE_INSERT
-#define TX_EL_THREAD_RELINQUISH_INSERT
-#define TX_EL_THREAD_RESUME_INSERT
-#define TX_EL_THREAD_SLEEP_INSERT
-#define TX_EL_THREAD_SUSPEND_INSERT
-#define TX_EL_THREAD_TERMINATE_INSERT
-#define TX_EL_THREAD_TIME_SLICE_CHANGE_INSERT
-#define TX_EL_TIME_GET_INSERT
-#define TX_EL_TIME_SET_INSERT
-#define TX_EL_TIMER_ACTIVATE_INSERT
-#define TX_EL_TIMER_CHANGE_INSERT
-#define TX_EL_TIMER_CREATE_INSERT
-#define TX_EL_TIMER_DEACTIVATE_INSERT
-#define TX_EL_TIMER_DELETE_INSERT
-#define TX_EL_BLOCK_POOL_INFO_GET_INSERT
-#define TX_EL_BLOCK_POOL_PRIORITIZE_INSERT
-#define TX_EL_BYTE_POOL_INFO_GET_INSERT
-#define TX_EL_BYTE_POOL_PRIORITIZE_INSERT
-#define TX_EL_EVENT_FLAGS_INFO_GET_INSERT
-#define TX_EL_MUTEX_CREATE_INSERT
-#define TX_EL_MUTEX_DELETE_INSERT
-#define TX_EL_MUTEX_GET_INSERT
-#define TX_EL_MUTEX_INFO_GET_INSERT
-#define TX_EL_MUTEX_PRIORITIZE_INSERT
-#define TX_EL_MUTEX_PUT_INSERT
-#define TX_EL_QUEUE_INFO_GET_INSERT
-#define TX_EL_QUEUE_FRONT_SEND_INSERT
-#define TX_EL_QUEUE_PRIORITIZE_INSERT
-#define TX_EL_SEMAPHORE_INFO_GET_INSERT
-#define TX_EL_SEMAPHORE_PRIORITIZE_INSERT
-#define TX_EL_THREAD_INFO_GET_INSERT
-#define TX_EL_THREAD_WAIT_ABORT_INSERT
-#define TX_EL_TIMER_INFO_GET_INSERT
-#define TX_EL_BLOCK_POOL_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_BLOCK_POOL_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_BYTE_POOL_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_BYTE_POOL_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_EVENT_FLAGS_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_EVENT_FLAGS_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_EVENT_FLAGS_SET_NOTIFY_INSERT
-#define TX_EL_MUTEX_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_MUTEX_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_QUEUE_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_QUEUE_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_QUEUE_SEND_NOTIFY_INSERT
-#define TX_EL_SEMAPHORE_CEILING_PUT_INSERT
-#define TX_EL_SEMAPHORE_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_SEMAPHORE_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_SEMAPHORE_PUT_NOTIFY_INSERT
-#define TX_EL_THREAD_ENTRY_EXIT_NOTIFY_INSERT
-#define TX_EL_THREAD_RESET_INSERT
-#define TX_EL_THREAD_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_THREAD_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-#define TX_EL_THREAD_STACK_ERROR_NOTIFY_INSERT
-#define TX_EL_TIMER_PERFORMANCE_INFO_GET_INSERT
-#define TX_EL_TIMER_PERFORMANCE_SYSTEM_INFO_GET_INSERT
-
-#endif
-
-extern void threadx_thread_destroy_extension(TX_THREAD*);
-
-/* Determine if a C++ compiler is being used.  If so, complete the standard
-   C conditional started above.  */
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+/**************************************************************************/
+/*                                                                        */
+/*            Copyright (c) 1996-2012 by Express Logic Inc.               */
+/*                                                                        */
+/*  This software is copyrighted by and is the sole property of Express   */
+/*  Logic, Inc.  All rights, title, ownership, or other interests         */
+/*  in the software remain the property of Express Logic, Inc.  This      */
+/*  software may only be used in accordance with the corresponding        */
+/*  license agreement.  Any unauthorized use, duplication, transmission,  */
+/*  distribution, or disclosure of this software is expressly forbidden.  */
+/*                                                                        */
+/*  This Copyright notice may not be removed or modified without prior    */
+/*  written consent of Express Logic, Inc.                                */
+/*                                                                        */
+/*  Express Logic, Inc. reserves the right to modify this software        */
+/*  without notice.                                                       */
+/*                                                                        */
+/*  Express Logic, Inc.                     info@expresslogic.com         */
+/*  11423 West Bernardo Court               http://www.expresslogic.com   */
+/*  San Diego, CA  92127                                                  */
+/*                                                                        */
+/**************************************************************************/
+
+/**************************************************************************/
+/**************************************************************************/
+/**                                                                       */
+/** ThreadX Component                                                     */
+/**                                                                       */
+/**   Application Interface (API)                                         */
+/**                                                                       */
+/**************************************************************************/
+/**************************************************************************/
+
+/**************************************************************************/
+/*                                                                        */
+/*  APPLICATION INTERFACE DEFINITION                       RELEASE        */
+/*                                                                        */
+/*    tx_api.h                                            PORTABLE C      */
+/*                                                           5.6          */
+/*  AUTHOR                                                                */
+/*                                                                        */
+/*    William E. Lamie, Express Logic, Inc.                               */
+/*                                                                        */
+/*  DESCRIPTION                                                           */
+/*                                                                        */
+/*    This file defines the basic Application Interface (API) to the      */
+/*    high-performance ThreadX real-time kernel.  All service prototypes  */
+/*    and data structure definitions are defined in this file.            */
+/*    Please note that basic data type definitions and other architecture-*/
+/*    specific information is contained in the file tx_port.h.            */
+/*                                                                        */
+/*  RELEASE HISTORY                                                       */
+/*                                                                        */
+/*    DATE              NAME                      DESCRIPTION             */
+/*                                                                        */
+/*  12-12-2005     William E. Lamie         Initial Version 5.0           */
+/*  04-02-2007     William E. Lamie         Modified comment(s), and      */
+/*                                            replaced UL constant        */
+/*                                            modifier with ULONG cast,   */
+/*                                            resulting in version 5.1    */
+/*  12-12-2008     William E. Lamie         Modified comment(s), and      */
+/*                                            added trace constants,      */
+/*                                            resulting in version 5.2    */
+/*  07-04-2009     William E. Lamie         Modified comment(s), and      */
+/*                                            changed the start of user   */
+/*                                            trace events to 4096,       */
+/*                                            resulting in version 5.3    */
+/*  12-12-2009     William E. Lamie         Modified comment(s), changed  */
+/*                                            the definition of TX_NULL   */
+/*                                            to a pointer type, added    */
+/*                                            TX_MEMSET macro, modified   */
+/*                                            priority-inheritance struct */
+/*                                            members in TX_THREAD,changed*/
+/*                                            user event comments, added  */
+/*                                            callback for tracking thread*/
+/*                                            scheduling, merged event    */
+/*                                            logging and MULTI run-time  */
+/*                                            error checking support,     */
+/*                                            changed type of all internal*/
+/*                                            structure members used for  */
+/*                                            counting to UINT, and added */
+/*                                            safety critical exception   */
+/*                                            logic, resulting in         */
+/*                                            version 5.4                 */
+/*  07-15-2011     William E. Lamie         Modified comment(s), added    */
+/*                                            defines for major/minor     */
+/*                                            version information, and    */
+/*                                            removed unused original     */
+/*                                            threshold mutex structure   */
+/*                                            member, resulting in        */
+/*                                            version 5.5                 */
+/*  11-01-2012     William E. Lamie         Modified comment(s), and      */
+/*                                            modified minor version      */
+/*                                            define, resulting in        */
+/*                                            version 5.6                 */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef TX_API_H
+#define TX_API_H
+
+/* Determine if a C++ compiler is being used.  If so, ensure that standard
+   C is used to process the API information.  */
+
+#ifdef __cplusplus
+
+/* Yes, C++ compiler is present.  Use standard C.  */
+extern "C" {
+
+#endif
+
+/* Include the port-specific data type file.  */
+
+#include "tx_port.h"
+
+/* Define basic constants for the ThreadX kernel.  */
+
+/* Define the major/minor version information that can be used by the application
+   and the ThreadX source as well.  */
+
+#define __PRODUCT_THREADX__
+#define __THREADX_MAJOR_VERSION 5
+#define __THREADX_MINOR_VERSION 6
+
+/* API input parameters and general constants.  */
+
+#define TX_NO_WAIT 0
+#define TX_WAIT_FOREVER ((ULONG)0xFFFFFFFF)
+#define TX_AND 2
+#define TX_AND_CLEAR 3
+#define TX_OR 0
+#define TX_OR_CLEAR 1
+#define TX_1_ULONG 1
+#define TX_2_ULONG 2
+#define TX_4_ULONG 4
+#define TX_8_ULONG 8
+#define TX_16_ULONG 16
+#define TX_NO_TIME_SLICE 0
+#define TX_AUTO_START 1
+#define TX_DONT_START 0
+#define TX_AUTO_ACTIVATE 1
+#define TX_NO_ACTIVATE 0
+#define TX_TRUE 1
+#define TX_FALSE 0
+#define TX_NULL (void*)0
+#define TX_LOOP_FOREVER 1
+#define TX_INHERIT 1
+#define TX_NO_INHERIT 0
+#define TX_THREAD_ENTRY 0
+#define TX_THREAD_EXIT 1
+#define TX_STACK_FILL ((ULONG)0xEFEFEFEF)
+
+/* Thread execution state values.  */
+
+#define TX_READY 0
+#define TX_COMPLETED 1
+#define TX_TERMINATED 2
+#define TX_SUSPENDED 3
+#define TX_SLEEP 4
+#define TX_QUEUE_SUSP 5
+#define TX_SEMAPHORE_SUSP 6
+#define TX_EVENT_FLAG 7
+#define TX_BLOCK_MEMORY 8
+#define TX_BYTE_MEMORY 9
+#define TX_IO_DRIVER 10
+#define TX_FILE 11
+#define TX_TCP_IP 12
+#define TX_MUTEX_SUSP 13
+
+/* API return values.  */
+
+#define TX_SUCCESS 0x00
+#define TX_DELETED 0x01
+#define TX_NO_MEMORY 0x10
+#define TX_POOL_ERROR 0x02
+#define TX_PTR_ERROR 0x03
+#define TX_WAIT_ERROR 0x04
+#define TX_SIZE_ERROR 0x05
+#define TX_GROUP_ERROR 0x06
+#define TX_NO_EVENTS 0x07
+#define TX_OPTION_ERROR 0x08
+#define TX_QUEUE_ERROR 0x09
+#define TX_QUEUE_EMPTY 0x0A
+#define TX_QUEUE_FULL 0x0B
+#define TX_SEMAPHORE_ERROR 0x0C
+#define TX_NO_INSTANCE 0x0D
+#define TX_THREAD_ERROR 0x0E
+#define TX_PRIORITY_ERROR 0x0F
+#define TX_START_ERROR 0x10
+#define TX_DELETE_ERROR 0x11
+#define TX_RESUME_ERROR 0x12
+#define TX_CALLER_ERROR 0x13
+#define TX_SUSPEND_ERROR 0x14
+#define TX_TIMER_ERROR 0x15
+#define TX_TICK_ERROR 0x16
+#define TX_ACTIVATE_ERROR 0x17
+#define TX_THRESH_ERROR 0x18
+#define TX_SUSPEND_LIFTED 0x19
+#define TX_WAIT_ABORTED 0x1A
+#define TX_WAIT_ABORT_ERROR 0x1B
+#define TX_MUTEX_ERROR 0x1C
+#define TX_NOT_AVAILABLE 0x1D
+#define TX_NOT_OWNED 0x1E
+#define TX_INHERIT_ERROR 0x1F
+#define TX_NOT_DONE 0x20
+#define TX_CEILING_EXCEEDED 0x21
+#define TX_INVALID_CEILING 0x22
+#define TX_FEATURE_NOT_ENABLED 0xFF
+
+/* Define the TX_MEMSET macro to the standard library function, if not already defined.  */
+
+#ifndef TX_MEMSET
+#define TX_MEMSET(a, b, c) (memset)(a, b, c)
+/*
+ Parentheses around memset prevent the compiler from adding a call to ___memset_chk().
+ Somehow this header/definition is escaping the -fno-stack-protect and FORTIFY_SOURCE options.
+ */
+#endif
+
+/* Event numbers 0 through 4095 are reserved by Express Logic. Specific event assignments are:
+
+								ThreadX events:     1-199
+								FileX events:       200-299
+								NetX events:        300-599
+								USBX events:        600-999
+
+   User-defined event numbers start at 4096 and continue through 65535, as defined by the constants
+   TX_TRACE_USER_EVENT_START and TX_TRACE_USER_EVENT_END, respectively. User events should be based
+   on these constants in case the user event number assignment is changed in future releases.  */
+
+#define TX_TRACE_USER_EVENT_START 4096 /* I1, I2, I3, I4 are user defined           */
+#define TX_TRACE_USER_EVENT_END 65535 /* I1, I2, I3, I4 are user defined           */
+
+/* Define event filters that can be used to selectively disable certain events or groups of events.
+ */
+
+#define TX_TRACE_ALL_EVENTS 0x000007FF /* All ThreadX events                        */
+#define TX_TRACE_INTERNAL_EVENTS 0x00000001 /* ThreadX internal events                   */
+#define TX_TRACE_BLOCK_POOL_EVENTS 0x00000002 /* ThreadX Block Pool events                 */
+#define TX_TRACE_BYTE_POOL_EVENTS 0x00000004 /* ThreadX Byte Pool events                  */
+#define TX_TRACE_EVENT_FLAGS_EVENTS 0x00000008 /* ThreadX Event Flags events                */
+#define TX_TRACE_INTERRUPT_CONTROL_EVENT 0x00000010 /* ThreadX Interrupt Control events */
+#define TX_TRACE_MUTEX_EVENTS 0x00000020 /* ThreadX Mutex events                      */
+#define TX_TRACE_QUEUE_EVENTS 0x00000040 /* ThreadX Queue events                      */
+#define TX_TRACE_SEMAPHORE_EVENTS 0x00000080 /* ThreadX Semaphore events                  */
+#define TX_TRACE_THREAD_EVENTS 0x00000100 /* ThreadX Thread events                     */
+#define TX_TRACE_TIME_EVENTS 0x00000200 /* ThreadX Time events                       */
+#define TX_TRACE_TIMER_EVENTS 0x00000400 /* ThreadX Timer events                      */
+#define TX_TRACE_USER_EVENTS 0x80000000 /* ThreadX User Events                       */
+
+/* Define the control block definitions for all system objects.  */
+
+/* Define the basic timer management structures.  These are the structures
+   used to manage thread sleep, timeout, and user timer requests.  */
+
+/* Define the common internal timer control block.  */
+
+typedef struct TX_TIMER_INTERNAL_STRUCT
+{
+	/* Define the remaining ticks and re-initialization tick values.  */
+	ULONG tx_timer_internal_remaining_ticks;
+	ULONG tx_timer_internal_re_initialize_ticks;
+
+	/* Define the timeout function and timeout function parameter.  */
+	VOID (*tx_timer_internal_timeout_function)(ULONG);
+	ULONG tx_timer_internal_timeout_param;
+
+	/* Define the next and previous internal link pointers for active
+	   internal timers.  */
+	struct TX_TIMER_INTERNAL_STRUCT *tx_timer_internal_active_next,
+		*tx_timer_internal_active_previous;
+
+	/* Keep track of the pointer to the head of this list as well.  */
+	struct TX_TIMER_INTERNAL_STRUCT** tx_timer_internal_list_head;
+} TX_TIMER_INTERNAL;
+
+/* Define the timer structure utilized by the application.  */
+
+typedef struct TX_TIMER_STRUCT
+{
+	/* Define the timer ID used for error checking.  */
+	ULONG tx_timer_id;
+
+	/* Define the timer's name.  */
+	const CHAR* tx_timer_name;
+
+	/* Define the actual contents of the timer.  This is the block that
+	   is used in the actual timer expiration processing.  */
+	TX_TIMER_INTERNAL tx_timer_internal;
+
+	/* Define the pointers for the created list.  */
+	struct TX_TIMER_STRUCT *tx_timer_created_next, *tx_timer_created_previous;
+
+#ifdef TX_TIMER_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of timer activations.  */
+	ULONG tx_timer_performance_activate_count;
+
+	/* Define the number of timer reactivations.  */
+	ULONG tx_timer_performance_reactivate_count;
+
+	/* Define the number of timer deactivations.  */
+	ULONG tx_timer_performance_deactivate_count;
+
+	/* Define the number of timer expirations.  */
+	ULONG tx_timer_performance_expiration_count;
+
+	/* Define the total number of timer expiration adjustments.  */
+	ULONG tx_timer_performance_expiration_adjust_count;
+#endif
+
+} TX_TIMER;
+
+/* Statically defined keys for *_getspecific & *_setspecific apis' */
+typedef enum { TX_THREAD_SJLJ_KEY = 0, TX_THREAD_CXA_GLOBAL_KEY, TX_THREAD_MAX_KEY } TX_THREAD_KEYS;
+
+typedef struct TX_THREAD_SPECIFIC_STRUCT
+{
+	void* values[TX_THREAD_MAX_KEY];
+} TX_THREAD_SPECIFIC;
+
+typedef int TX_THREAD_KEY;
+
+/* ThreadX thread control block structure follows.  Additional fields
+   can be added providing they are added after the information that is
+   referenced in the port-specific assembly code.  */
+
+typedef struct TX_THREAD_STRUCT
+{
+	/* The first section of the control block contains critical
+	   information that is referenced by the port-specific
+	   assembly language code.  Any changes in this section could
+	   necessitate changes in the assembly language.  */
+
+	ULONG tx_thread_id; /* Control block ID         */
+	ULONG tx_thread_run_count; /* Thread's run counter     */
+	VOID* tx_thread_stack_ptr; /* Thread's stack pointer   */
+	VOID* tx_thread_stack_start; /* Stack starting address   */
+	VOID* tx_thread_stack_end; /* Stack ending address     */
+	ULONG tx_thread_stack_size; /* Stack size               */
+	ULONG tx_thread_time_slice; /* Current time-slice       */
+	ULONG tx_thread_new_time_slice; /* New time-slice           */
+
+	/* Define pointers to the next and previous ready threads.  */
+	struct TX_THREAD_STRUCT *tx_thread_ready_next, *tx_thread_ready_previous;
+
+	/***************************************************************/
+
+	/* Define the first port extension in the thread control block. This
+	   is typically defined to whitespace or a pointer type in tx_port.h.  */
+	TX_THREAD_EXTENSION_0
+
+	const CHAR* tx_thread_name; /* Pointer to thread's name     */
+	UINT tx_thread_priority; /* Priority of thread (0-1023)  */
+	UINT tx_thread_state; /* Thread's execution state     */
+	UINT tx_thread_delayed_suspend; /* Delayed suspend flag         */
+	UINT tx_thread_suspending; /* Thread suspending flag       */
+	UINT tx_thread_preempt_threshold; /* Preemption threshold         */
+
+	/* Define the thread schedule hook. The usage of this is port/application specific,
+	   but when used, the function pointer designated is called whenever the thread is
+	   scheduled and unscheduled.  */
+	VOID (*tx_thread_schedule_hook)(struct TX_THREAD_STRUCT*, ULONG);
+
+	/* Nothing after this point is referenced by the target-specific
+	   assembly language.  Hence, information after this point can
+	   be added to the control block providing the complete system
+	   is recompiled.  */
+
+	/* Define the thread's entry point and input parameter.  */
+	VOID (*tx_thread_entry)(ULONG);
+	ULONG tx_thread_entry_parameter;
+
+	/* Define the thread's timer block.   This is used for thread
+	   sleep and timeout requests.  */
+	TX_TIMER_INTERNAL tx_thread_timer;
+
+	/* Define the thread's cleanup function and associated data.  This
+	   is used to cleanup various data structures when a thread
+	   suspension is lifted or terminated either by the user or
+	   a timeout.  */
+	VOID (*tx_thread_suspend_cleanup)(struct TX_THREAD_STRUCT*);
+	VOID* tx_thread_suspend_control_block;
+	struct TX_THREAD_STRUCT *tx_thread_suspended_next, *tx_thread_suspended_previous;
+	ULONG tx_thread_suspend_info;
+	VOID* tx_thread_additional_suspend_info;
+	UINT tx_thread_suspend_option;
+	UINT tx_thread_suspend_status;
+
+	/* Define the second port extension in the thread control block. This
+	   is typically defined to whitespace or a pointer type in tx_port.h.  */
+	TX_THREAD_EXTENSION_1
+
+	/* Define pointers to the next and previous threads in the
+	   created list.  */
+	struct TX_THREAD_STRUCT *tx_thread_created_next, *tx_thread_created_previous;
+
+	/* Define the third port extension in the thread control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_THREAD_EXTENSION_2
+
+	/* Define a pointer type for FileX extensions.  */
+	VOID* tx_thread_filex_ptr;
+
+	/* Define the priority inheritance variables. These will be used
+	   to manage priority inheritance changes applied to this thread
+	   as a result of mutex get operations.  */
+	UINT tx_thread_user_priority;
+	UINT tx_thread_user_preempt_threshold;
+	UINT tx_thread_inherit_priority;
+	UINT tx_thread_owned_mutex_count;
+	struct TX_MUTEX_STRUCT* tx_thread_owned_mutex_list;
+
+#ifdef TX_THREAD_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of times this thread is resumed.  */
+	ULONG tx_thread_performance_resume_count;
+
+	/* Define the number of times this thread suspends.  */
+	ULONG tx_thread_performance_suspend_count;
+
+	/* Define the number of times this thread is preempted by calling
+	   a ThreadX API service.  */
+	ULONG tx_thread_performance_solicited_preemption_count;
+
+	/* Define the number of times this thread is preempted by an
+	   ISR calling a ThreadX API service.  */
+	ULONG tx_thread_performance_interrupt_preemption_count;
+
+	/* Define the number of priority inversions for this thread.  */
+	ULONG tx_thread_performance_priority_inversion_count;
+
+	/* Define the last thread pointer to preempt this thread.  */
+	struct TX_THREAD_STRUCT* tx_thread_performance_last_preempting_thread;
+
+	/* Define the total number of times this thread was time-sliced.  */
+	ULONG tx_thread_performance_time_slice_count;
+
+	/* Define the total number of times this thread relinquishes.  */
+	ULONG tx_thread_performance_relinquish_count;
+
+	/* Define the total number of times this thread had a timeout.  */
+	ULONG tx_thread_performance_timeout_count;
+
+	/* Define the total number of times this thread had suspension lifted
+	   because of the tx_thread_wait_abort service.  */
+	ULONG tx_thread_performance_wait_abort_count;
+#endif
+
+	/* Define the highest stack pointer variable.  */
+	VOID* tx_thread_stack_highest_ptr; /* Stack highest usage pointer  */
+
+#ifndef TX_DISABLE_NOTIFY_CALLBACKS
+
+	/* Define the application callback routine used to notify the application when
+	   the thread is entered or exits.  */
+	VOID (*tx_thread_entry_exit_notify)(struct TX_THREAD_STRUCT*, UINT);
+#endif
+
+	/* Define the fourth port extension in the thread control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_THREAD_EXTENSION_3
+
+	/* Define the user extension field.  This typically is defined
+	   to white space, but some ports of ThreadX may need to have
+	   additional fields in the thread control block.  This is
+	   defined in the file tx_port.h.  */
+	TX_THREAD_USER_EXTENSION
+
+} TX_THREAD;
+
+typedef struct TX_THREAD_ONCE_CONTROL
+{
+	volatile int once_value;
+} TX_THREAD_ONCE __attribute__((aligned(sizeof(struct TX_THREAD_ONCE_CONTROL))));
+
+#define TX_THREAD_ONCE_INIT_VALUE 0U
+#define TX_THREAD_ONCE_INIT       \
+	{                             \
+		TX_THREAD_ONCE_INIT_VALUE \
+	}
+
+/* Define the block memory pool structure utilized by the application.  */
+
+typedef struct TX_BLOCK_POOL_STRUCT
+{
+	/* Define the block pool ID used for error checking.  */
+	ULONG tx_block_pool_id;
+
+	/* Define the block pool's name.  */
+	const CHAR* tx_block_pool_name;
+
+	/* Define the number of available memory blocks in the pool.  */
+	UINT tx_block_pool_available;
+
+	/* Save the initial number of blocks.  */
+	UINT tx_block_pool_total;
+
+	/* Define the head pointer of the available block pool.  */
+	UCHAR* tx_block_pool_available_list;
+
+	/* Save the start address of the block pool's memory area.  */
+	UCHAR* tx_block_pool_start;
+
+	/* Save the block pool's size in bytes.  */
+	ULONG tx_block_pool_size;
+
+	/* Save the individual memory block size - rounded for alignment.  */
+	UINT tx_block_pool_block_size;
+
+	/* Define the block pool suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_block_pool_suspension_list;
+	UINT tx_block_pool_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_BLOCK_POOL_STRUCT *tx_block_pool_created_next, *tx_block_pool_created_previous;
+
+#ifdef TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of block allocates.  */
+	ULONG tx_block_pool_performance_allocate_count;
+
+	/* Define the number of block releases.  */
+	ULONG tx_block_pool_performance_release_count;
+
+	/* Define the number of block pool suspensions.  */
+	ULONG tx_block_pool_performance_suspension_count;
+
+	/* Define the number of block pool timeouts.  */
+	ULONG tx_block_pool_performance_timeout_count;
+#endif
+
+	/* Define the port extension in the block pool control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_BLOCK_POOL_EXTENSION
+
+} TX_BLOCK_POOL;
+
+/* Define the byte memory pool structure utilized by the application.  */
+
+typedef struct TX_BYTE_POOL_STRUCT
+{
+	/* Define the byte pool ID used for error checking.  */
+	ULONG tx_byte_pool_id;
+
+	/* Define the byte pool's name.  */
+	const CHAR* tx_byte_pool_name;
+
+	/* Define the number of available bytes in the pool.  */
+	ULONG tx_byte_pool_available;
+
+	/* Define the number of fragments in the pool.  */
+	UINT tx_byte_pool_fragments;
+
+	/* Define the head pointer of byte pool.  */
+	UCHAR* tx_byte_pool_list;
+
+	/* Define the search pointer used for initial searching for memory
+	   in a byte pool.  */
+	UCHAR* tx_byte_pool_search;
+
+	/* Save the start address of the byte pool's memory area.  */
+	UCHAR* tx_byte_pool_start;
+
+	/* Save the byte pool's size in bytes.  */
+	ULONG tx_byte_pool_size;
+
+	/* This is used to mark the owner of the byte memory pool during
+	   a search.  If this value changes during the search, the local search
+	   pointer must be reset.  */
+	struct TX_THREAD_STRUCT* tx_byte_pool_owner;
+
+	/* Define the byte pool suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_byte_pool_suspension_list;
+	UINT tx_byte_pool_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_BYTE_POOL_STRUCT *tx_byte_pool_created_next, *tx_byte_pool_created_previous;
+
+#ifdef TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of allocates.  */
+	ULONG tx_byte_pool_performance_allocate_count;
+
+	/* Define the number of releases.  */
+	ULONG tx_byte_pool_performance_release_count;
+
+	/* Define the number of adjacent memory fragment merges.  */
+	ULONG tx_byte_pool_performance_merge_count;
+
+	/* Define the number of memory fragment splits.  */
+	ULONG tx_byte_pool_performance_split_count;
+
+	/* Define the number of memory fragments searched that either were not free or could not satisfy
+	   the
+	   request.  */
+	ULONG tx_byte_pool_performance_search_count;
+
+	/* Define the number of byte pool suspensions.  */
+	ULONG tx_byte_pool_performance_suspension_count;
+
+	/* Define the number of byte pool timeouts.  */
+	ULONG tx_byte_pool_performance_timeout_count;
+#endif
+
+	/* Define the port extension in the byte pool control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_BYTE_POOL_EXTENSION
+
+} TX_BYTE_POOL;
+
+/* Define the event flags group structure utilized by the application.  */
+
+typedef struct TX_EVENT_FLAGS_GROUP_STRUCT
+{
+	/* Define the event flags group ID used for error checking.  */
+	ULONG tx_event_flags_group_id;
+
+	/* Define the event flags group's name.  */
+	const CHAR* tx_event_flags_group_name;
+
+	/* Define the actual current event flags in this group. A zero in a
+	   particular bit indicates the event flag is not set.  */
+	ULONG tx_event_flags_group_current;
+
+	/* Define the reset search flag that is set when an ISR sets flags during
+	   the search of the suspended threads list.  */
+	UINT tx_event_flags_group_reset_search;
+
+	/* Define the event flags group suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_event_flags_group_suspension_list;
+	UINT tx_event_flags_group_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_EVENT_FLAGS_GROUP_STRUCT *tx_event_flags_group_created_next,
+		*tx_event_flags_group_created_previous;
+
+	/* Define the delayed clearing event flags.  */
+	ULONG tx_event_flags_group_delayed_clear;
+
+#ifdef TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of event flag sets.  */
+	ULONG tx_event_flags_group_performance_set_count;
+
+	/* Define the number of event flag gets.  */
+	ULONG tx_event_flags_group_performance_get_count;
+
+	/* Define the number of event flag suspensions.  */
+	ULONG tx_event_flags_group_performance_suspension_count;
+
+	/* Define the number of event flag timeouts.  */
+	ULONG tx_event_flags_group_performance_timeout_count;
+#endif
+
+#ifndef TX_DISABLE_NOTIFY_CALLBACKS
+
+	/* Define the application callback routine used to notify the application when
+	   an event flag is set.  */
+	VOID (*tx_event_flags_group_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT*);
+#endif
+
+	/* Define the port extension in the event flags group control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_EVENT_FLAGS_GROUP_EXTENSION
+
+} TX_EVENT_FLAGS_GROUP;
+
+/* Define the mutex structure utilized by the application.  */
+
+typedef struct TX_MUTEX_STRUCT
+{
+	/* Define the mutex ID used for error checking.  */
+	ULONG tx_mutex_id;
+
+	/* Define the mutex's name.  */
+	const CHAR* tx_mutex_name;
+
+	/* Define the mutex ownership count.  */
+	UINT tx_mutex_ownership_count;
+
+	/* Define the mutex ownership pointer.  This pointer points to the
+	   the thread that owns the mutex.  */
+	TX_THREAD* tx_mutex_owner;
+
+	/* Define the priority inheritance flag.  If this flag is set, priority
+	   inheritance will be in effect.  */
+	UINT tx_mutex_inherit;
+
+	/* Define the save area for the owning thread's original priority.  */
+	UINT tx_mutex_original_priority;
+
+	/* Define the mutex suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_mutex_suspension_list;
+	UINT tx_mutex_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_MUTEX_STRUCT *tx_mutex_created_next, *tx_mutex_created_previous;
+
+	/* Define the priority of the highest priority thread waiting for
+	   this mutex.  */
+	UINT tx_mutex_highest_priority_waiting;
+
+	/* Define the owned list next and previous pointers.  */
+	struct TX_MUTEX_STRUCT *tx_mutex_owned_next, *tx_mutex_owned_previous;
+
+#ifdef TX_MUTEX_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of mutex puts.  */
+	ULONG tx_mutex_performance_put_count;
+
+	/* Define the total number of mutex gets.  */
+	ULONG tx_mutex_performance_get_count;
+
+	/* Define the total number of mutex suspensions.  */
+	ULONG tx_mutex_performance_suspension_count;
+
+	/* Define the total number of mutex timeouts.  */
+	ULONG tx_mutex_performance_timeout_count;
+
+	/* Define the total number of priority inversions.  */
+	ULONG tx_mutex_performance_priority_inversion_count;
+
+	/* Define the total number of priority inheritance conditions.  */
+	ULONG tx_mutex_performance_priority_inheritance_count;
+#endif
+
+	/* Define the port extension in the mutex control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_MUTEX_EXTENSION
+
+} TX_MUTEX;
+
+/* Define the queue structure utilized by the application.  */
+
+typedef struct TX_QUEUE_STRUCT
+{
+	/* Define the queue ID used for error checking.  */
+	ULONG tx_queue_id;
+
+	/* Define the queue's name.  */
+	const CHAR* tx_queue_name;
+
+	/* Define the message size that was specified in queue creation.  */
+	UINT tx_queue_message_size;
+
+	/* Define the total number of messages in the queue.  */
+	UINT tx_queue_capacity;
+
+	/* Define the current number of messages enqueued and the available
+	   queue storage space.  */
+	UINT tx_queue_enqueued;
+	UINT tx_queue_available_storage;
+
+	/* Define pointers that represent the start and end for the queue's
+	   message area.  */
+	ULONG* tx_queue_start;
+	ULONG* tx_queue_end;
+
+	/* Define the queue read and write pointers.  Send requests use the write
+	   pointer while receive requests use the read pointer.  */
+	ULONG* tx_queue_read;
+	ULONG* tx_queue_write;
+
+	/* Define the queue suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_queue_suspension_list;
+	UINT tx_queue_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_QUEUE_STRUCT *tx_queue_created_next, *tx_queue_created_previous;
+
+#ifdef TX_QUEUE_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of messages sent to this queue.  */
+	ULONG tx_queue_performance_messages_sent_count;
+
+	/* Define the number of messages received from this queue.  */
+	ULONG tx_queue_performance_messages_received_count;
+
+	/* Define the number of empty suspensions on this queue.  */
+	ULONG tx_queue_performance_empty_suspension_count;
+
+	/* Define the number of full suspensions on this queue.  */
+	ULONG tx_queue_performance_full_suspension_count;
+
+	/* Define the number of full non-suspensions on this queue. These
+	   messages are rejected with an appropriate error code.  */
+	ULONG tx_queue_performance_full_error_count;
+
+	/* Define the number of queue timeouts.  */
+	ULONG tx_queue_performance_timeout_count;
+#endif
+
+#ifndef TX_DISABLE_NOTIFY_CALLBACKS
+
+	/* Define the application callback routine used to notify the application when
+	   the a message is sent to the queue.  */
+	VOID (*tx_queue_send_notify)(struct TX_QUEUE_STRUCT*);
+#endif
+
+	/* Define the port extension in the queue control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_QUEUE_EXTENSION
+
+} TX_QUEUE;
+
+/* Define the semaphore structure utilized by the application.  */
+
+typedef struct TX_SEMAPHORE_STRUCT
+{
+	/* Define the semaphore ID used for error checking.  */
+	ULONG tx_semaphore_id;
+
+	/* Define the semaphore's name.  */
+	const CHAR* tx_semaphore_name;
+
+	/* Define the actual semaphore count.  A zero means that no semaphore
+	   instance is available.  */
+	ULONG tx_semaphore_count;
+
+	/* Define the semaphore suspension list head along with a count of
+	   how many threads are suspended.  */
+	struct TX_THREAD_STRUCT* tx_semaphore_suspension_list;
+	UINT tx_semaphore_suspended_count;
+
+	/* Define the created list next and previous pointers.  */
+	struct TX_SEMAPHORE_STRUCT *tx_semaphore_created_next, *tx_semaphore_created_previous;
+
+#ifdef TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO
+
+	/* Define the number of semaphore puts.  */
+	ULONG tx_semaphore_performance_put_count;
+
+	/* Define the number of semaphore gets.  */
+	ULONG tx_semaphore_performance_get_count;
+
+	/* Define the number of semaphore suspensions.  */
+	ULONG tx_semaphore_performance_suspension_count;
+
+	/* Define the number of semaphore timeouts.  */
+	ULONG tx_semaphore_performance_timeout_count;
+#endif
+
+#ifndef TX_DISABLE_NOTIFY_CALLBACKS
+
+	/* Define the application callback routine used to notify the application when
+	   the a semaphore is put.  */
+	VOID (*tx_semaphore_put_notify)(struct TX_SEMAPHORE_STRUCT*);
+#endif
+
+	/* Define the port extension in the semaphore control block. This
+	   is typically defined to whitespace in tx_port.h.  */
+	TX_SEMAPHORE_EXTENSION
+
+} TX_SEMAPHORE;
+
+/* Define the system API mappings based on the error checking
+   selected by the user.  Note: this section is only applicable to
+   application source code, hence the conditional that turns off this
+   stuff when the include file is processed by the ThreadX source. */
+
+#ifndef TX_SOURCE_CODE
+
+/* Determine if error checking is desired.  If so, map API functions
+   to the appropriate error checking front-ends.  Otherwise, map API
+   functions to the core functions that actually perform the work.
+   Note: error checking is enabled by default.  */
+
+#ifdef TX_DISABLE_ERROR_CHECKING
+
+/* Services without error checking.  */
+
+#define tx_kernel_enter _tx_initialize_kernel_enter
+
+#define tx_block_allocate _tx_block_allocate
+#define tx_block_pool_create _tx_block_pool_create
+#define tx_block_pool_delete _tx_block_pool_delete
+#define tx_block_pool_info_get _tx_block_pool_info_get
+#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
+#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
+#define tx_block_pool_prioritize _tx_block_pool_prioritize
+#define tx_block_release _tx_block_release
+
+#define tx_byte_allocate _tx_byte_allocate
+#define tx_byte_pool_create _tx_byte_pool_create
+#define tx_byte_pool_delete _tx_byte_pool_delete
+#define tx_byte_pool_info_get _tx_byte_pool_info_get
+#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
+#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
+#define tx_byte_pool_prioritize _tx_byte_pool_prioritize
+#define tx_byte_release _tx_byte_release
+
+#define tx_event_flags_create _tx_event_flags_create
+#define tx_event_flags_delete _tx_event_flags_delete
+#define tx_event_flags_get _tx_event_flags_get
+#define tx_event_flags_info_get _tx_event_flags_info_get
+#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
+#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
+#define tx_event_flags_set _tx_event_flags_set
+#define tx_event_flags_set_notify _tx_event_flags_set_notify
+
+#ifdef TX_ENABLE_EVENT_LOGGING
+UINT _tx_el_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_el_interrupt_control
+#else
+#ifdef TX_ENABLE_EVENT_TRACE
+UINT _tx_trace_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_trace_interrupt_control
+#else
+#define tx_interrupt_control _tx_thread_interrupt_control
+#endif
+#endif
+
+#define tx_mutex_create _tx_mutex_create
+#define tx_mutex_delete _tx_mutex_delete
+#define tx_mutex_get _tx_mutex_get
+#define tx_mutex_info_get _tx_mutex_info_get
+#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
+#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
+#define tx_mutex_prioritize _tx_mutex_prioritize
+#define tx_mutex_put _tx_mutex_put
+
+#define tx_queue_create _tx_queue_create
+#define tx_queue_delete _tx_queue_delete
+#define tx_queue_flush _tx_queue_flush
+#define tx_queue_info_get _tx_queue_info_get
+#define tx_queue_performance_info_get _tx_queue_performance_info_get
+#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
+#define tx_queue_receive _tx_queue_receive
+#define tx_queue_send _tx_queue_send
+#define tx_queue_send_notify _tx_queue_send_notify
+#define tx_queue_front_send _tx_queue_front_send
+#define tx_queue_prioritize _tx_queue_prioritize
+
+#define tx_semaphore_ceiling_put _tx_semaphore_ceiling_put
+#define tx_semaphore_create _tx_semaphore_create
+#define tx_semaphore_delete _tx_semaphore_delete
+#define tx_semaphore_get _tx_semaphore_get
+#define tx_semaphore_info_get _tx_semaphore_info_get
+#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
+#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
+#define tx_semaphore_prioritize _tx_semaphore_prioritize
+#define tx_semaphore_put _tx_semaphore_put
+#define tx_semaphore_put_notify _tx_semaphore_put_notify
+
+#define tx_thread_create _tx_thread_create
+#define tx_thread_delete _tx_thread_delete
+#define tx_thread_entry_exit_notify _tx_thread_entry_exit_notify
+#define tx_thread_identify _tx_thread_identify
+#define tx_thread_info_get _tx_thread_info_get
+#define tx_thread_performance_info_get _tx_thread_performance_info_get
+#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
+#define tx_thread_preemption_change _tx_thread_preemption_change
+#define tx_thread_priority_change _tx_thread_priority_change
+#define tx_thread_relinquish _tx_thread_relinquish
+#define tx_thread_reset _tx_thread_reset
+#define tx_thread_resume _tx_thread_resume
+#define tx_thread_sleep _tx_thread_sleep
+#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
+#define tx_thread_suspend _tx_thread_suspend
+#define tx_thread_terminate _tx_thread_terminate
+#define tx_thread_time_slice_change _tx_thread_time_slice_change
+#define tx_thread_wait_abort _tx_thread_wait_abort
+#define tx_thread_once _tx_thread_once
+#define tx_thread_getspecific _tx_thread_getspecific
+#define tx_thread_setspecific _tx_thread_setspecific
+
+#define tx_time_get _tx_time_get
+#define tx_time_set _tx_time_set
+#define tx_timer_activate _tx_timer_activate
+#define tx_timer_change _tx_timer_change
+#define tx_timer_create _tx_timer_create
+#define tx_timer_deactivate _tx_timer_deactivate
+#define tx_timer_delete _tx_timer_delete
+#define tx_timer_info_get _tx_timer_info_get
+#define tx_timer_performance_info_get _tx_timer_performance_info_get
+#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
+
+#define tx_trace_enable _tx_trace_enable
+#define tx_trace_event_filter _tx_trace_event_filter
+#define tx_trace_event_unfilter _tx_trace_event_unfilter
+#define tx_trace_disable _tx_trace_disable
+#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
+#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
+#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
+#define tx_trace_user_event_insert _tx_trace_user_event_insert
+
+#else
+
+/* Services with error checking.  */
+
+#define tx_kernel_enter _tx_initialize_kernel_enter
+
+/* Define the system API mappings depending on the runtime error
+   checking behavior selected by the user.  */
+
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+
+/* Services with MULTI runtime error checking ThreadX.  */
+
+#define tx_block_allocate _txr_block_allocate
+#define tx_block_pool_create(p, n, b, s, l) \
+	_txr_block_pool_create(p, n, b, s, l, sizeof(TX_BLOCK_POOL))
+#define tx_block_pool_delete _txr_block_pool_delete
+#define tx_block_pool_info_get _txr_block_pool_info_get
+#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
+#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
+#define tx_block_pool_prioritize _txr_block_pool_prioritize
+#define tx_block_release _txr_block_release
+
+#define tx_byte_allocate _txr_byte_allocate
+#define tx_byte_pool_create(p, n, s, l) _txr_byte_pool_create(p, n, s, l, sizeof(TX_BYTE_POOL))
+#define tx_byte_pool_delete _txr_byte_pool_delete
+#define tx_byte_pool_info_get _txr_byte_pool_info_get
+#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
+#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
+#define tx_byte_pool_prioritize _txr_byte_pool_prioritize
+#define tx_byte_release _txr_byte_release
+
+#define tx_event_flags_create(g, n) _txr_event_flags_create(g, n, sizeof(TX_EVENT_FLAGS_GROUP))
+#define tx_event_flags_delete _txr_event_flags_delete
+#define tx_event_flags_get _txr_event_flags_get
+#define tx_event_flags_info_get _txr_event_flags_info_get
+#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
+#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
+#define tx_event_flags_set _txr_event_flags_set
+#define tx_event_flags_set_notify _txr_event_flags_set_notify
+
+#ifdef TX_ENABLE_EVENT_LOGGING
+UINT _tx_el_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_el_interrupt_control
+#else
+#ifdef TX_ENABLE_EVENT_TRACE
+UINT _tx_trace_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_trace_interrupt_control
+#else
+#define tx_interrupt_control _tx_thread_interrupt_control
+#endif
+#endif
+
+#define tx_mutex_create(m, n, i) _txr_mutex_create(m, n, i, sizeof(TX_MUTEX))
+#define tx_mutex_delete _txr_mutex_delete
+#define tx_mutex_get _txr_mutex_get
+#define tx_mutex_info_get _txr_mutex_info_get
+#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
+#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
+#define tx_mutex_prioritize _txr_mutex_prioritize
+#define tx_mutex_put _txr_mutex_put
+
+#define tx_queue_create(q, n, m, s, l) _txr_queue_create(q, n, m, s, l, sizeof(TX_QUEUE))
+#define tx_queue_delete _txr_queue_delete
+#define tx_queue_flush _txr_queue_flush
+#define tx_queue_info_get _txr_queue_info_get
+#define tx_queue_performance_info_get _tx_queue_performance_info_get
+#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
+#define tx_queue_receive _txr_queue_receive
+#define tx_queue_send _txr_queue_send
+#define tx_queue_send_notify _txr_queue_send_notify
+#define tx_queue_front_send _txr_queue_front_send
+#define tx_queue_prioritize _txr_queue_prioritize
+
+#define tx_semaphore_ceiling_put _txr_semaphore_ceiling_put
+#define tx_semaphore_create(s, n, i) _txr_semaphore_create(s, n, i, sizeof(TX_SEMAPHORE))
+#define tx_semaphore_delete _txr_semaphore_delete
+#define tx_semaphore_get _txr_semaphore_get
+#define tx_semaphore_info_get _txr_semaphore_info_get
+#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
+#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
+#define tx_semaphore_prioritize _txr_semaphore_prioritize
+#define tx_semaphore_put _txr_semaphore_put
+#define tx_semaphore_put_notify _txr_semaphore_put_notify
+
+#define tx_thread_create(t, n, e, i, s, l, p, r, c, a) \
+	_txr_thread_create(t, n, e, i, s, l, p, r, c, a, sizeof(TX_THREAD))
+#define tx_thread_delete _txr_thread_delete
+#define tx_thread_entry_exit_notify _txr_thread_entry_exit_notify
+#define tx_thread_identify _tx_thread_identify
+#define tx_thread_info_get _txr_thread_info_get
+#define tx_thread_performance_info_get _tx_thread_performance_info_get
+#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
+#define tx_thread_preemption_change _txr_thread_preemption_change
+#define tx_thread_priority_change _txr_thread_priority_change
+#define tx_thread_relinquish _txe_thread_relinquish
+#define tx_thread_reset _txr_thread_reset
+#define tx_thread_resume _txr_thread_resume
+#define tx_thread_sleep _tx_thread_sleep
+#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
+#define tx_thread_suspend _txr_thread_suspend
+#define tx_thread_terminate _txr_thread_terminate
+#define tx_thread_time_slice_change _txr_thread_time_slice_change
+#define tx_thread_wait_abort _txr_thread_wait_abort
+#define tx_thread_once _tx_thread_once
+#define tx_thread_getspecific _tx_thread_getspecific
+#define tx_thread_setspecific _tx_thread_setspecific
+
+#define tx_time_get _tx_time_get
+#define tx_time_set _tx_time_set
+#define tx_timer_activate _txr_timer_activate
+#define tx_timer_change _txr_timer_change
+#define tx_timer_create(t, n, e, i, c, r, a) \
+	_txr_timer_create(t, n, e, i, c, r, a, sizeof(TX_TIMER))
+#define tx_timer_deactivate _txr_timer_deactivate
+#define tx_timer_delete _txr_timer_delete
+#define tx_timer_info_get _txr_timer_info_get
+#define tx_timer_performance_info_get _tx_timer_performance_info_get
+#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
+
+#define tx_trace_enable _tx_trace_enable
+#define tx_trace_event_filter _tx_trace_event_filter
+#define tx_trace_event_unfilter _tx_trace_event_unfilter
+#define tx_trace_disable _tx_trace_disable
+#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
+#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
+#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
+#define tx_trace_user_event_insert _tx_trace_user_event_insert
+
+#else
+
+#define tx_block_allocate _txe_block_allocate
+#define tx_block_pool_create(p, n, b, s, l) \
+	_txe_block_pool_create(p, n, b, s, l, sizeof(TX_BLOCK_POOL))
+#define tx_block_pool_delete _txe_block_pool_delete
+#define tx_block_pool_info_get _txe_block_pool_info_get
+#define tx_block_pool_performance_info_get _tx_block_pool_performance_info_get
+#define tx_block_pool_performance_system_info_get _tx_block_pool_performance_system_info_get
+#define tx_block_pool_prioritize _txe_block_pool_prioritize
+#define tx_block_release _txe_block_release
+
+#define tx_byte_allocate _txe_byte_allocate
+#define tx_byte_pool_create(p, n, s, l) _txe_byte_pool_create(p, n, s, l, sizeof(TX_BYTE_POOL))
+#define tx_byte_pool_delete _txe_byte_pool_delete
+#define tx_byte_pool_info_get _txe_byte_pool_info_get
+#define tx_byte_pool_performance_info_get _tx_byte_pool_performance_info_get
+#define tx_byte_pool_performance_system_info_get _tx_byte_pool_performance_system_info_get
+#define tx_byte_pool_prioritize _txe_byte_pool_prioritize
+#define tx_byte_release _txe_byte_release
+
+#define tx_event_flags_create(g, n) _txe_event_flags_create(g, n, sizeof(TX_EVENT_FLAGS_GROUP))
+#define tx_event_flags_delete _txe_event_flags_delete
+#define tx_event_flags_get _txe_event_flags_get
+#define tx_event_flags_info_get _txe_event_flags_info_get
+#define tx_event_flags_performance_info_get _tx_event_flags_performance_info_get
+#define tx_event_flags_performance_system_info_get _tx_event_flags_performance_system_info_get
+#define tx_event_flags_set _txe_event_flags_set
+#define tx_event_flags_set_notify _txe_event_flags_set_notify
+
+#ifdef TX_ENABLE_EVENT_LOGGING
+UINT _tx_el_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_el_interrupt_control
+#else
+#ifdef TX_ENABLE_EVENT_TRACE
+UINT _tx_trace_interrupt_control(UINT new_posture);
+#define tx_interrupt_control _tx_trace_interrupt_control
+#else
+#define tx_interrupt_control _tx_thread_interrupt_control
+#endif
+#endif
+
+#define tx_mutex_create(m, n, i) _txe_mutex_create(m, n, i, sizeof(TX_MUTEX))
+#define tx_mutex_delete _txe_mutex_delete
+#define tx_mutex_get _txe_mutex_get
+#define tx_mutex_info_get _txe_mutex_info_get
+#define tx_mutex_performance_info_get _tx_mutex_performance_info_get
+#define tx_mutex_performance_system_info_get _tx_mutex_performance_system_info_get
+#define tx_mutex_prioritize _txe_mutex_prioritize
+#define tx_mutex_put _txe_mutex_put
+
+#define tx_queue_create(q, n, m, s, l) _txe_queue_create(q, n, m, s, l, sizeof(TX_QUEUE))
+#define tx_queue_delete _txe_queue_delete
+#define tx_queue_flush _txe_queue_flush
+#define tx_queue_info_get _txe_queue_info_get
+#define tx_queue_performance_info_get _tx_queue_performance_info_get
+#define tx_queue_performance_system_info_get _tx_queue_performance_system_info_get
+#define tx_queue_receive _txe_queue_receive
+#define tx_queue_send _txe_queue_send
+#define tx_queue_send_notify _txe_queue_send_notify
+#define tx_queue_front_send _txe_queue_front_send
+#define tx_queue_prioritize _txe_queue_prioritize
+
+#define tx_semaphore_ceiling_put _txe_semaphore_ceiling_put
+#define tx_semaphore_create(s, n, i) _txe_semaphore_create(s, n, i, sizeof(TX_SEMAPHORE))
+#define tx_semaphore_delete _txe_semaphore_delete
+#define tx_semaphore_get _txe_semaphore_get
+#define tx_semaphore_info_get _txe_semaphore_info_get
+#define tx_semaphore_performance_info_get _tx_semaphore_performance_info_get
+#define tx_semaphore_performance_system_info_get _tx_semaphore_performance_system_info_get
+#define tx_semaphore_prioritize _txe_semaphore_prioritize
+#define tx_semaphore_put _txe_semaphore_put
+#define tx_semaphore_put_notify _txe_semaphore_put_notify
+
+#define tx_thread_create(t, n, e, i, s, l, p, r, c, a) \
+	_txe_thread_create(t, n, e, i, s, l, p, r, c, a, sizeof(TX_THREAD))
+#define tx_thread_delete _txe_thread_delete
+#define tx_thread_entry_exit_notify _txe_thread_entry_exit_notify
+#define tx_thread_identify _tx_thread_identify
+#define tx_thread_info_get _txe_thread_info_get
+#define tx_thread_performance_info_get _tx_thread_performance_info_get
+#define tx_thread_performance_system_info_get _tx_thread_performance_system_info_get
+#define tx_thread_preemption_change _txe_thread_preemption_change
+#define tx_thread_priority_change _txe_thread_priority_change
+#define tx_thread_relinquish _txe_thread_relinquish
+#define tx_thread_reset _txe_thread_reset
+#define tx_thread_resume _txe_thread_resume
+#define tx_thread_sleep _tx_thread_sleep
+#define tx_thread_stack_error_notify _tx_thread_stack_error_notify
+#define tx_thread_suspend _txe_thread_suspend
+#define tx_thread_terminate _txe_thread_terminate
+#define tx_thread_time_slice_change _txe_thread_time_slice_change
+#define tx_thread_wait_abort _txe_thread_wait_abort
+#define tx_thread_once _tx_thread_once
+#define tx_thread_getspecific _tx_thread_getspecific
+#define tx_thread_setspecific _tx_thread_setspecific
+
+#define tx_time_get _tx_time_get
+#define tx_time_set _tx_time_set
+#define tx_timer_activate _txe_timer_activate
+#define tx_timer_change _txe_timer_change
+#define tx_timer_create(t, n, e, i, c, r, a) \
+	_txe_timer_create(t, n, e, i, c, r, a, sizeof(TX_TIMER))
+#define tx_timer_deactivate _txe_timer_deactivate
+#define tx_timer_delete _txe_timer_delete
+#define tx_timer_info_get _txe_timer_info_get
+#define tx_timer_performance_info_get _tx_timer_performance_info_get
+#define tx_timer_performance_system_info_get _tx_timer_performance_system_info_get
+
+#define tx_trace_enable _tx_trace_enable
+#define tx_trace_event_filter _tx_trace_event_filter
+#define tx_trace_event_unfilter _tx_trace_event_unfilter
+#define tx_trace_disable _tx_trace_disable
+#define tx_trace_isr_enter_insert _tx_trace_isr_enter_insert
+#define tx_trace_isr_exit_insert _tx_trace_isr_exit_insert
+#define tx_trace_buffer_full_notify _tx_trace_buffer_full_notify
+#define tx_trace_user_event_insert _tx_trace_user_event_insert
+
+#endif
+#endif
+
+/* Declare the tx_application_define function as having C linkage.  */
+
+VOID tx_application_define(VOID*);
+
+/* Define the ThreadX entry function that is typically called from the application's main()
+ * function.  */
+
+VOID tx_kernel_enter(VOID);
+
+/* Define the function prototypes of the ThreadX API.  */
+
+UINT tx_block_allocate(TX_BLOCK_POOL* pool_ptr, VOID** block_ptr, ULONG wait_option);
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
+						   VOID* pool_start, ULONG pool_size);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
+							VOID* pool_start, ULONG pool_size, UINT pool_control_block_size);
+#else
+UINT _txe_block_pool_create(TX_BLOCK_POOL* pool_ptr, const CHAR* name_ptr, ULONG block_size,
+							VOID* pool_start, ULONG pool_size, UINT pool_control_block_size);
+#endif
+#endif
+UINT tx_block_pool_delete(TX_BLOCK_POOL* pool_ptr);
+UINT tx_block_pool_info_get(TX_BLOCK_POOL* pool_ptr, const CHAR** name, ULONG* available_blocks,
+							ULONG* total_blocks, TX_THREAD** first_suspended,
+							ULONG* suspended_count, TX_BLOCK_POOL** next_pool);
+UINT tx_block_pool_performance_info_get(TX_BLOCK_POOL* pool_ptr, ULONG* allocates, ULONG* releases,
+										ULONG* suspensions, ULONG* timeouts);
+UINT tx_block_pool_performance_system_info_get(ULONG* allocates, ULONG* releases,
+											   ULONG* suspensions, ULONG* timeouts);
+UINT tx_block_pool_prioritize(TX_BLOCK_POOL* pool_ptr);
+UINT tx_block_release(VOID* block_ptr);
+
+UINT tx_byte_allocate(TX_BYTE_POOL* pool_ptr, VOID** memory_ptr, ULONG memory_size,
+					  ULONG wait_option);
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
+						  ULONG pool_size);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
+						   ULONG pool_size, UINT pool_control_block_size);
+#else
+UINT _txe_byte_pool_create(TX_BYTE_POOL* pool_ptr, const CHAR* name_ptr, VOID* pool_start,
+						   ULONG pool_size, UINT pool_control_block_size);
+#endif
+#endif
+UINT tx_byte_pool_delete(TX_BYTE_POOL* pool_ptr);
+UINT tx_byte_pool_info_get(TX_BYTE_POOL* pool_ptr, const CHAR** name, ULONG* available_bytes,
+						   ULONG* fragments, TX_THREAD** first_suspended, ULONG* suspended_count,
+						   TX_BYTE_POOL** next_pool);
+UINT tx_byte_pool_performance_info_get(TX_BYTE_POOL* pool_ptr, ULONG* allocates, ULONG* releases,
+									   ULONG* fragments_searched, ULONG* merges, ULONG* splits,
+									   ULONG* suspensions, ULONG* timeouts);
+UINT tx_byte_pool_performance_system_info_get(ULONG* allocates, ULONG* releases,
+											  ULONG* fragments_searched, ULONG* merges,
+											  ULONG* splits, ULONG* suspensions, ULONG* timeouts);
+UINT tx_byte_pool_prioritize(TX_BYTE_POOL* pool_ptr);
+UINT tx_byte_release(VOID* memory_ptr);
+
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr,
+							 UINT event_control_block_size);
+#else
+UINT _txe_event_flags_create(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR* name_ptr,
+							 UINT event_control_block_size);
+#endif
+#endif
+UINT tx_event_flags_delete(TX_EVENT_FLAGS_GROUP* group_ptr);
+UINT tx_event_flags_get(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG requested_flags, UINT get_option,
+						ULONG* actual_flags_ptr, ULONG wait_option);
+UINT tx_event_flags_info_get(TX_EVENT_FLAGS_GROUP* group_ptr, const CHAR** name,
+							 ULONG* current_flags, TX_THREAD** first_suspended,
+							 ULONG* suspended_count, TX_EVENT_FLAGS_GROUP** next_group);
+UINT tx_event_flags_performance_info_get(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG* sets, ULONG* gets,
+										 ULONG* suspensions, ULONG* timeouts);
+UINT tx_event_flags_performance_system_info_get(ULONG* sets, ULONG* gets, ULONG* suspensions,
+												ULONG* timeouts);
+UINT tx_event_flags_set(TX_EVENT_FLAGS_GROUP* group_ptr, ULONG flags_to_set, UINT set_option);
+UINT tx_event_flags_set_notify(TX_EVENT_FLAGS_GROUP* group_ptr,
+							   VOID (*events_set_notify)(TX_EVENT_FLAGS_GROUP*));
+
+UINT tx_interrupt_control(UINT new_posture);
+
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit,
+					   UINT mutex_control_block_size);
+#else
+UINT _txe_mutex_create(TX_MUTEX* mutex_ptr, const CHAR* name_ptr, UINT inherit,
+					   UINT mutex_control_block_size);
+#endif
+#endif
+UINT tx_mutex_delete(TX_MUTEX* mutex_ptr);
+UINT tx_mutex_get(TX_MUTEX* mutex_ptr, ULONG wait_option);
+UINT tx_mutex_info_get(TX_MUTEX* mutex_ptr, const CHAR** name, ULONG* count, TX_THREAD** owner,
+					   TX_THREAD** first_suspended, ULONG* suspended_count, TX_MUTEX** next_mutex);
+UINT tx_mutex_performance_info_get(TX_MUTEX* mutex_ptr, ULONG* puts, ULONG* gets,
+								   ULONG* suspensions, ULONG* timeouts, ULONG* inversions,
+								   ULONG* inheritances);
+UINT tx_mutex_performance_system_info_get(ULONG* puts, ULONG* gets, ULONG* suspensions,
+										  ULONG* timeouts, ULONG* inversions, ULONG* inheritances);
+UINT tx_mutex_prioritize(TX_MUTEX* mutex_ptr);
+UINT tx_mutex_put(TX_MUTEX* mutex_ptr);
+
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
+					  VOID* queue_start, ULONG queue_size);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
+					   VOID* queue_start, ULONG queue_size, UINT queue_control_block_size);
+#else
+UINT _txe_queue_create(TX_QUEUE* queue_ptr, const CHAR* name_ptr, UINT message_size,
+					   VOID* queue_start, ULONG queue_size, UINT queue_control_block_size);
+#endif
+#endif
+UINT tx_queue_delete(TX_QUEUE* queue_ptr);
+UINT tx_queue_flush(TX_QUEUE* queue_ptr);
+UINT tx_queue_info_get(TX_QUEUE* queue_ptr, const CHAR** name, ULONG* enqueued,
+					   ULONG* available_storage, TX_THREAD** first_suspended,
+					   ULONG* suspended_count, TX_QUEUE** next_queue);
+UINT tx_queue_performance_info_get(TX_QUEUE* queue_ptr, ULONG* messages_sent,
+								   ULONG* messages_received, ULONG* empty_suspensions,
+								   ULONG* full_suspensions, ULONG* full_errors, ULONG* timeouts);
+UINT tx_queue_performance_system_info_get(ULONG* messages_sent, ULONG* messages_received,
+										  ULONG* empty_suspensions, ULONG* full_suspensions,
+										  ULONG* full_errors, ULONG* timeouts);
+UINT tx_queue_receive(TX_QUEUE* queue_ptr, VOID* destination_ptr, ULONG wait_option);
+UINT tx_queue_send(TX_QUEUE* queue_ptr, VOID* source_ptr, ULONG wait_option);
+UINT tx_queue_send_notify(TX_QUEUE* queue_ptr, VOID (*queue_send_notify)(TX_QUEUE*));
+UINT tx_queue_front_send(TX_QUEUE* queue_ptr, VOID* source_ptr, ULONG wait_option);
+UINT tx_queue_prioritize(TX_QUEUE* queue_ptr);
+
+UINT tx_semaphore_ceiling_put(TX_SEMAPHORE* semaphore_ptr, ULONG ceiling);
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count,
+						   UINT semaphore_control_block_size);
+#else
+UINT _txe_semaphore_create(TX_SEMAPHORE* semaphore_ptr, const CHAR* name_ptr, ULONG initial_count,
+						   UINT semaphore_control_block_size);
+#endif
+#endif
+UINT tx_semaphore_delete(TX_SEMAPHORE* semaphore_ptr);
+UINT tx_semaphore_get(TX_SEMAPHORE* semaphore_ptr, ULONG wait_option);
+UINT tx_semaphore_info_get(TX_SEMAPHORE* semaphore_ptr, const CHAR** name, ULONG* current_value,
+						   TX_THREAD** first_suspended, ULONG* suspended_count,
+						   TX_SEMAPHORE** next_semaphore);
+UINT tx_semaphore_performance_info_get(TX_SEMAPHORE* semaphore_ptr, ULONG* puts, ULONG* gets,
+									   ULONG* suspensions, ULONG* timeouts);
+UINT tx_semaphore_performance_system_info_get(ULONG* puts, ULONG* gets, ULONG* suspensions,
+											  ULONG* timeouts);
+UINT tx_semaphore_prioritize(TX_SEMAPHORE* semaphore_ptr);
+UINT tx_semaphore_put(TX_SEMAPHORE* semaphore_ptr);
+UINT tx_semaphore_put_notify(TX_SEMAPHORE* semaphore_ptr,
+							 VOID (*semaphore_put_notify)(TX_SEMAPHORE*));
+
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
+					   ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
+					   UINT preempt_threshold, ULONG time_slice, UINT auto_start);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
+						ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
+						UINT preempt_threshold, ULONG time_slice, UINT auto_start,
+						UINT thread_control_block_size);
+#else
+UINT _txe_thread_create(TX_THREAD* thread_ptr, const CHAR* name_ptr, VOID (*entry_function)(ULONG),
+						ULONG entry_input, VOID* stack_start, ULONG stack_size, UINT priority,
+						UINT preempt_threshold, ULONG time_slice, UINT auto_start,
+						UINT thread_control_block_size);
+#endif
+#endif
+UINT tx_thread_delete(TX_THREAD* thread_ptr);
+UINT tx_thread_entry_exit_notify(TX_THREAD* thread_ptr,
+								 VOID (*thread_entry_exit_notify)(TX_THREAD*, UINT));
+TX_THREAD* tx_thread_identify(VOID);
+UINT tx_thread_info_get(TX_THREAD* thread_ptr, const CHAR** name, UINT* state, ULONG* run_count,
+						UINT* priority, UINT* preemption_threshold, ULONG* time_slice,
+						TX_THREAD** next_thread, TX_THREAD** next_suspended_thread);
+UINT tx_thread_performance_info_get(TX_THREAD* thread_ptr, ULONG* resumptions, ULONG* suspensions,
+									ULONG* solicited_preemptions, ULONG* interrupt_preemptions,
+									ULONG* priority_inversions, ULONG* time_slices,
+									ULONG* relinquishes, ULONG* timeouts, ULONG* wait_aborts,
+									TX_THREAD** last_preempted_by);
+UINT tx_thread_performance_system_info_get(ULONG* resumptions, ULONG* suspensions,
+										   ULONG* solicited_preemptions,
+										   ULONG* interrupt_preemptions, ULONG* priority_inversions,
+										   ULONG* time_slices, ULONG* relinquishes, ULONG* timeouts,
+										   ULONG* wait_aborts, ULONG* non_idle_returns,
+										   ULONG* idle_returns);
+UINT tx_thread_preemption_change(TX_THREAD* thread_ptr, UINT new_threshold, UINT* old_threshold);
+UINT tx_thread_priority_change(TX_THREAD* thread_ptr, UINT new_priority, UINT* old_priority);
+VOID tx_thread_relinquish(VOID);
+UINT tx_thread_reset(TX_THREAD* thread_ptr);
+UINT tx_thread_resume(TX_THREAD* thread_ptr);
+UINT tx_thread_sleep(ULONG timer_ticks);
+UINT tx_thread_stack_error_notify(VOID (*stack_error_handler)(TX_THREAD*));
+UINT tx_thread_suspend(TX_THREAD* thread_ptr);
+UINT tx_thread_terminate(TX_THREAD* thread_ptr);
+UINT tx_thread_time_slice_change(TX_THREAD* thread_ptr, ULONG new_time_slice,
+								 ULONG* old_time_slice);
+UINT tx_thread_wait_abort(TX_THREAD* thread_ptr);
+UINT tx_thread_once(TX_THREAD_ONCE* once_control, void (*once_routine)(void));
+VOID* tx_thread_getspecific(TX_THREAD_KEY key);
+VOID tx_thread_setspecific(TX_THREAD_KEY key, void* data);
+
+ULONG tx_time_get(VOID);
+VOID tx_time_set(ULONG new_time);
+
+UINT tx_timer_activate(TX_TIMER* timer_ptr);
+UINT tx_timer_change(TX_TIMER* timer_ptr, ULONG initial_ticks, ULONG reschedule_ticks);
+#ifdef TX_DISABLE_ERROR_CHECKING
+UINT _tx_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr, VOID (*expiration_function)(ULONG),
+					  ULONG expiration_input, ULONG initial_ticks, ULONG reschedule_ticks,
+					  UINT auto_activate);
+#else
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+UINT _txr_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr,
+					   VOID (*expiration_function)(ULONG), ULONG expiration_input,
+					   ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate,
+					   UINT timer_control_block_size);
+#else
+UINT _txe_timer_create(TX_TIMER* timer_ptr, const CHAR* name_ptr,
+					   VOID (*expiration_function)(ULONG), ULONG expiration_input,
+					   ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate,
+					   UINT timer_control_block_size);
+#endif
+#endif
+UINT tx_timer_deactivate(TX_TIMER* timer_ptr);
+UINT tx_timer_delete(TX_TIMER* timer_ptr);
+UINT tx_timer_info_get(TX_TIMER* timer_ptr, const CHAR** name, UINT* active, ULONG* remaining_ticks,
+					   ULONG* reschedule_ticks, TX_TIMER** next_timer);
+UINT tx_timer_performance_info_get(TX_TIMER* timer_ptr, ULONG* activates, ULONG* reactivates,
+								   ULONG* deactivates, ULONG* expirations,
+								   ULONG* expiration_adjusts);
+UINT tx_timer_performance_system_info_get(ULONG* activates, ULONG* reactivates, ULONG* deactivates,
+										  ULONG* expirations, ULONG* expiration_adjusts);
+
+UINT tx_trace_enable(VOID* trace_buffer_start, ULONG trace_buffer_size, ULONG registry_entries);
+UINT tx_trace_event_filter(ULONG event_filter_bits);
+UINT tx_trace_event_unfilter(ULONG event_unfilter_bits);
+UINT tx_trace_disable(VOID);
+VOID tx_trace_isr_enter_insert(ULONG isr_id);
+VOID tx_trace_isr_exit_insert(ULONG isr_id);
+UINT tx_trace_buffer_full_notify(VOID (*full_buffer_callback)(VOID*));
+UINT tx_trace_user_event_insert(ULONG event_id, ULONG info_field_1, ULONG info_field_2,
+								ULONG info_field_3, ULONG info_field_4);
+
+#endif
+
+/* Define safety critical configuration and exception handling.  */
+
+#ifdef TX_SAFETY_CRITICAL
+
+/* Ensure the maximum number of priorities is defined in safety critical mode.  */
+#ifndef TX_MAX_PRIORITIES
+#error "tx_port.h: TX_MAX_PRIORITIES not defined."
+#endif
+
+/* Ensure the maximum number of priorities is a multiple of 32.  */
+#if(TX_MAX_PRIORITIES % 32) != 0
+#error "tx_port.h: TX_MAX_PRIORITIES must be a multiple of 32."
+#endif
+
+/* Ensure error checking is enabled.  */
+#ifdef TX_DISABLE_ERROR_CHECKING
+#error "TX_DISABLE_ERROR_CHECKING must not be defined."
+#endif
+
+/* Ensure timer ISR processing is not defined.  */
+#ifdef TX_TIMER_PROCESS_IN_ISR
+#error "TX_TIMER_PROCESS_IN_ISR must not be defined."
+#endif
+
+/* Ensure timer reactivation in-line is not defined.  */
+#ifdef TX_REACTIVATE_INLINE
+#error "TX_REACTIVATE_INLINE must not be defined."
+#endif
+
+/* Ensure disable stack filling is not defined.  */
+#ifdef TX_DISABLE_STACK_FILLING
+#error "TX_DISABLE_STACK_FILLING must not be defined."
+#endif
+
+/* Ensure enable stack checking is not defined.  */
+#ifdef TX_ENABLE_STACK_CHECKING
+#error "TX_ENABLE_STACK_CHECKING must not be defined."
+#endif
+
+/* Ensure disable preemption-threshold is not defined.  */
+#ifdef TX_DISABLE_PREEMPTION_THRESHOLD
+#error "TX_DISABLE_PREEMPTION_THRESHOLD must not be defined."
+#endif
+
+/* Ensure disable redundant clearing is not defined.  */
+#ifdef TX_DISABLE_REDUNDANT_CLEARING
+#error "TX_DISABLE_REDUNDANT_CLEARING must not be defined."
+#endif
+
+/* Ensure no timer is not defined.  */
+#ifdef TX_NO_TIMER
+#error "TX_NO_TIMER must not be defined."
+#endif
+
+/* Ensure disable notify callbacks is not defined.  */
+#ifdef TX_DISABLE_NOTIFY_CALLBACKS
+#error "TX_DISABLE_NOTIFY_CALLBACKS must not be defined."
+#endif
+
+/* Ensure inline thread suspend/resume is not defined.  */
+#ifdef TX_INLINE_THREAD_RESUME_SUSPEND
+#error "TX_INLINE_THREAD_RESUME_SUSPEND must not be defined."
+#endif
+
+/* Ensure not interruptable is not defined.  */
+#ifdef TX_NOT_INTERRUPTABLE
+#error "TX_NOT_INTERRUPTABLE must not be defined."
+#endif
+
+/* Ensure event trace enable is not defined.  */
+#ifdef TX_ENABLE_EVENT_TRACE
+#error "TX_ENABLE_EVENT_TRACE must not be defined."
+#endif
+
+/* Ensure block pool performance info enable is not defined.  */
+#ifdef TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO
+#error "TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure byte pool performance info enable is not defined.  */
+#ifdef TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO
+#error "TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure event flag performance info enable is not defined.  */
+#ifdef TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO
+#error "TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure mutex performance info enable is not defined.   */
+#ifdef TX_MUTEX_ENABLE_PERFORMANCE_INFO
+#error "TX_MUTEX_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure queue performance info enable is not defined.  */
+#ifdef TX_QUEUE_ENABLE_PERFORMANCE_INFO
+#error "TX_QUEUE_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure semaphore performance info enable is not defined.  */
+#ifdef TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO
+#error "TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure thread performance info enable is not defined.  */
+#ifdef TX_THREAD_ENABLE_PERFORMANCE_INFO
+#error "TX_THREAD_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Ensure timer performance info enable is not defined.  */
+#ifdef TX_TIMER_ENABLE_PERFORMANCE_INFO
+#error "TX_TIMER_ENABLE_PERFORMANCE_INFO must not be defined."
+#endif
+
+/* Now define the safety critical exception handler.  */
+
+VOID _tx_safety_critical_exception_handler(const CHAR* file_name, INT line_number, UINT status);
+
+#ifndef TX_SAFETY_CRITICAL_EXCEPTION
+#define TX_SAFETY_CRITICAL_EXCEPTION(a, b, c) _tx_safety_critical_exception_handler(a, b, c);
+#endif
+
+#ifndef TX_SAFETY_CRITICAL_EXCEPTION_HANDLER
+#define TX_SAFETY_CRITICAL_EXCEPTION_HANDLER                                           \
+	VOID _tx_safety_critical_exception_handler(const CHAR* file_name, INT line_number, \
+											   UINT status)                            \
+	{                                                                                  \
+		while(1)                                                                       \
+		{                                                                              \
+		}                                                                              \
+	}
+#endif
+#endif
+
+#ifdef TX_ENABLE_MULTI_ERROR_CHECKING
+
+/* Define ThreadX API MULTI run-time error checking function.  */
+void __ghs_rnerr(char* errMsg, int stackLevels, int stackTraceDisplay, void* hexVal);
+
+#endif
+
+/* Bring in the event logging constants and prototypes.  Note that
+   TX_ENABLE_EVENT_LOGGING must be defined when building the ThreadX
+   library components in order to enable event logging.  */
+
+#ifdef TX_ENABLE_EVENT_LOGGING
+#include "tx_el.h"
+#else
+#ifndef TX_SOURCE_CODE
+#define _tx_el_user_event_insert(a, b, c, d, e)
+#endif
+#define TX_EL_INITIALIZE
+#define TX_EL_THREAD_REGISTER(a)
+#define TX_EL_THREAD_UNREGISTER(a)
+#define TX_EL_THREAD_STATUS_CHANGE_INSERT(a, b)
+#define TX_EL_BYTE_ALLOCATE_INSERT
+#define TX_EL_BYTE_POOL_CREATE_INSERT
+#define TX_EL_BYTE_POOL_DELETE_INSERT
+#define TX_EL_BYTE_RELEASE_INSERT
+#define TX_EL_BLOCK_ALLOCATE_INSERT
+#define TX_EL_BLOCK_POOL_CREATE_INSERT
+#define TX_EL_BLOCK_POOL_DELETE_INSERT
+#define TX_EL_BLOCK_RELEASE_INSERT
+#define TX_EL_EVENT_FLAGS_CREATE_INSERT
+#define TX_EL_EVENT_FLAGS_DELETE_INSERT
+#define TX_EL_EVENT_FLAGS_GET_INSERT
+#define TX_EL_EVENT_FLAGS_SET_INSERT
+#define TX_EL_INTERRUPT_CONTROL_INSERT
+#define TX_EL_QUEUE_CREATE_INSERT
+#define TX_EL_QUEUE_DELETE_INSERT
+#define TX_EL_QUEUE_FLUSH_INSERT
+#define TX_EL_QUEUE_RECEIVE_INSERT
+#define TX_EL_QUEUE_SEND_INSERT
+#define TX_EL_SEMAPHORE_CREATE_INSERT
+#define TX_EL_SEMAPHORE_DELETE_INSERT
+#define TX_EL_SEMAPHORE_GET_INSERT
+#define TX_EL_SEMAPHORE_PUT_INSERT
+#define TX_EL_THREAD_CREATE_INSERT
+#define TX_EL_THREAD_DELETE_INSERT
+#define TX_EL_THREAD_IDENTIFY_INSERT
+#define TX_EL_THREAD_PREEMPTION_CHANGE_INSERT
+#define TX_EL_THREAD_PRIORITY_CHANGE_INSERT
+#define TX_EL_THREAD_RELINQUISH_INSERT
+#define TX_EL_THREAD_RESUME_INSERT
+#define TX_EL_THREAD_SLEEP_INSERT
+#define TX_EL_THREAD_SUSPEND_INSERT
+#define TX_EL_THREAD_TERMINATE_INSERT
+#define TX_EL_THREAD_TIME_SLICE_CHANGE_INSERT
+#define TX_EL_TIME_GET_INSERT
+#define TX_EL_TIME_SET_INSERT
+#define TX_EL_TIMER_ACTIVATE_INSERT
+#define TX_EL_TIMER_CHANGE_INSERT
+#define TX_EL_TIMER_CREATE_INSERT
+#define TX_EL_TIMER_DEACTIVATE_INSERT
+#define TX_EL_TIMER_DELETE_INSERT
+#define TX_EL_BLOCK_POOL_INFO_GET_INSERT
+#define TX_EL_BLOCK_POOL_PRIORITIZE_INSERT
+#define TX_EL_BYTE_POOL_INFO_GET_INSERT
+#define TX_EL_BYTE_POOL_PRIORITIZE_INSERT
+#define TX_EL_EVENT_FLAGS_INFO_GET_INSERT
+#define TX_EL_MUTEX_CREATE_INSERT
+#define TX_EL_MUTEX_DELETE_INSERT
+#define TX_EL_MUTEX_GET_INSERT
+#define TX_EL_MUTEX_INFO_GET_INSERT
+#define TX_EL_MUTEX_PRIORITIZE_INSERT
+#define TX_EL_MUTEX_PUT_INSERT
+#define TX_EL_QUEUE_INFO_GET_INSERT
+#define TX_EL_QUEUE_FRONT_SEND_INSERT
+#define TX_EL_QUEUE_PRIORITIZE_INSERT
+#define TX_EL_SEMAPHORE_INFO_GET_INSERT
+#define TX_EL_SEMAPHORE_PRIORITIZE_INSERT
+#define TX_EL_THREAD_INFO_GET_INSERT
+#define TX_EL_THREAD_WAIT_ABORT_INSERT
+#define TX_EL_TIMER_INFO_GET_INSERT
+#define TX_EL_BLOCK_POOL_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_BLOCK_POOL_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_BYTE_POOL_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_BYTE_POOL_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_EVENT_FLAGS_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_EVENT_FLAGS_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_EVENT_FLAGS_SET_NOTIFY_INSERT
+#define TX_EL_MUTEX_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_MUTEX_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_QUEUE_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_QUEUE_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_QUEUE_SEND_NOTIFY_INSERT
+#define TX_EL_SEMAPHORE_CEILING_PUT_INSERT
+#define TX_EL_SEMAPHORE_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_SEMAPHORE_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_SEMAPHORE_PUT_NOTIFY_INSERT
+#define TX_EL_THREAD_ENTRY_EXIT_NOTIFY_INSERT
+#define TX_EL_THREAD_RESET_INSERT
+#define TX_EL_THREAD_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_THREAD_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+#define TX_EL_THREAD_STACK_ERROR_NOTIFY_INSERT
+#define TX_EL_TIMER_PERFORMANCE_INFO_GET_INSERT
+#define TX_EL_TIMER_PERFORMANCE_SYSTEM_INFO_GET_INSERT
+
+#endif
+
+extern void threadx_thread_destroy_extension(TX_THREAD*);
+
+/* Determine if a C++ compiler is being used.  If so, complete the standard
+   C conditional started above.  */
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_port.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_port.h
index 1cba5dd..5e89de0 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_port.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/dependencies/rtos/threadx/tx_port.h	
@@ -1,320 +1,320 @@
-/**************************************************************************/
-/*                                                                        */
-/*            Copyright (c) 1996-2014 by Express Logic Inc.               */
-/*                                                                        */
-/*  This software is copyrighted by and is the sole property of Express   */
-/*  Logic, Inc.  All rights, title, ownership, or other interests         */
-/*  in the software remain the property of Express Logic, Inc.  This      */
-/*  software may only be used in accordance with the corresponding        */
-/*  license agreement.  Any unauthorized use, duplication, transmission,  */
-/*  distribution, or disclosure of this software is expressly forbidden.  */
-/*                                                                        */
-/*  This Copyright notice may not be removed or modified without prior    */
-/*  written consent of Express Logic, Inc.                                */
-/*                                                                        */
-/*  Express Logic, Inc. reserves the right to modify this software        */
-/*  without notice.                                                       */
-/*                                                                        */
-/*  Express Logic, Inc.                     info@expresslogic.com         */
-/*  11423 West Bernardo Court               http://www.expresslogic.com   */
-/*  San Diego, CA  92127                                                  */
-/*                                                                        */
-/**************************************************************************/
-
-/**************************************************************************/
-/**************************************************************************/
-/**                                                                       */
-/** ThreadX Component                                                     */
-/**                                                                       */
-/**   Port Specific                                                       */
-/**                                                                       */
-/**************************************************************************/
-/**************************************************************************/
-
-/**************************************************************************/
-/*                                                                        */
-/*  PORT SPECIFIC C INFORMATION                            RELEASE        */
-/*                                                                        */
-/*    tx_port.h                                         Cortex-A5/GNU     */
-/*                                                           5.0          */
-/*                                                                        */
-/*  AUTHOR                                                                */
-/*                                                                        */
-/*    William E. Lamie, Express Logic, Inc.                               */
-/*                                                                        */
-/*  DESCRIPTION                                                           */
-/*                                                                        */
-/*    This file contains data type definitions that make the ThreadX      */
-/*    real-time kernel function identically on a variety of different     */
-/*    processor architectures.  For example, the size or number of bits   */
-/*    in an "int" data type vary between microprocessor architectures and */
-/*    even C compilers for the same microprocessor.  ThreadX does not     */
-/*    directly use native C data types.  Instead, ThreadX creates its     */
-/*    own special types that can be mapped to actual data types by this   */
-/*    file to guarantee consistency in the interface and functionality.   */
-/*                                                                        */
-/*  RELEASE HISTORY                                                       */
-/*                                                                        */
-/*    DATE              NAME                      DESCRIPTION             */
-/*                                                                        */
-/*  01-01-2014     William E. Lamie         Initial Cortex-A5 GNU         */
-/*                                            Support Version 5.0         */
-/*                                                                        */
-/**************************************************************************/
-
-#ifndef TX_PORT_H
-#define TX_PORT_H
-
-/* Determine if the optional ThreadX user define file should be used.  */
-
-#ifdef TX_INCLUDE_USER_DEFINE_FILE
-
-/* Yes, include the user defines in tx_user.h. The defines in this file may
-   alternately be defined on the command line.  */
-
-#include "tx_user.h"
-#endif
-
-/* Define compiler library include files.  */
-
-#include <string.h>
-
-/* Define ThreadX basic types for this port.  */
-
-#define VOID void
-typedef char CHAR;
-typedef unsigned char UCHAR;
-typedef int INT;
-typedef unsigned int UINT;
-typedef long LONG;
-typedef unsigned long ULONG;
-typedef short SHORT;
-typedef unsigned short USHORT;
-
-/* Define the priority levels for ThreadX.  Legal values range
-   from 32 to 1024 and MUST be evenly divisible by 32.  */
-
-#ifndef TX_MAX_PRIORITIES
-#define TX_MAX_PRIORITIES 32
-#endif
-
-/* Define the minimum stack for a ThreadX thread on this processor. If the size supplied during
-   thread creation is less than this value, the thread create call will return an error.  */
-
-#ifndef TX_MINIMUM_STACK
-#define TX_MINIMUM_STACK 200 /* Minimum stack size for this port  */
-#endif
-
-/* Define the system timer thread's default stack size and priority.  These are only applicable
-   if TX_TIMER_PROCESS_IN_ISR is not defined.  */
-
-#ifndef TX_TIMER_THREAD_STACK_SIZE
-#define TX_TIMER_THREAD_STACK_SIZE 1024 /* Default timer thread stack size  */
-#endif
-
-#ifndef TX_TIMER_THREAD_PRIORITY
-#define TX_TIMER_THREAD_PRIORITY 0 /* Default timer thread priority    */
-#endif
-
-/* Define various constants for the ThreadX ARM port.  */
-
-#ifdef TX_ENABLE_FIQ_SUPPORT
-#define TX_INT_DISABLE 0xC0 /* Disable IRQ & FIQ interrupts     */
-#else
-#define TX_INT_DISABLE 0x80 /* Disable IRQ interrupts           */
-#endif
-#define TX_INT_ENABLE 0x00 /* Enable IRQ interrupts            */
-
-// uncomment this if you want to enable event trace
-//#define TX_ENABLE_EVENT_TRACE
-
-/* Define the clock source for trace event entry time stamp. The following two item are port
-   specific.
-   For example, if the time source is at the address 0x0a800024 and is 16-bits in size, the clock
-   source constants would be:
-*/
-#define TX_TRACE_TIME_SOURCE 0x0a800024UL
-#define TX_TRACE_TIME_MASK 0x0000FFFFUL
-
-#ifndef TX_TRACE_TIME_SOURCE
-#define TX_TRACE_TIME_SOURCE ++_tx_trace_simulated_time
-#endif
-#ifndef TX_TRACE_TIME_MASK
-#define TX_TRACE_TIME_MASK 0xFFFFFFFFUL
-#endif
-
-/* Define the port specific options for the _tx_build_options variable. This variable indicates
-   how the ThreadX library was built.  */
-
-#ifdef TX_ENABLE_FIQ_SUPPORT
-#define TX_FIQ_ENABLED 1
-#else
-#define TX_FIQ_ENABLED 0
-#endif
-
-#ifdef TX_ENABLE_IRQ_NESTING
-#define TX_IRQ_NESTING_ENABLED 2
-#else
-#define TX_IRQ_NESTING_ENABLED 0
-#endif
-
-#ifdef TX_ENABLE_FIQ_NESTING
-#define TX_FIQ_NESTING_ENABLED 4
-#else
-#define TX_FIQ_NESTING_ENABLED 0
-#endif
-
-#define TX_PORT_SPECIFIC_BUILD_OPTIONS \
-	TX_FIQ_ENABLED | TX_IRQ_NESTING_ENABLED | TX_FIQ_NESTING_ENABLED
-
-/* Define the in-line initialization constant so that modules with in-line
-   initialization capabilities can prevent their initialization from being
-   a function call.  */
-
-#define TX_INLINE_INITIALIZATION
-
-/* Determine whether or not stack checking is enabled. By default, ThreadX stack checking is
-   disabled. When the following is defined, ThreadX thread stack checking is enabled.  If stack
-   checking is enabled (TX_ENABLE_STACK_CHECKING is defined), the TX_DISABLE_STACK_FILLING
-   define is negated, thereby forcing the stack fill which is necessary for the stack checking
-   logic.  */
-
-#ifdef TX_ENABLE_STACK_CHECKING
-#undef TX_DISABLE_STACK_FILLING
-
-// Lives in threadx/src/tx_thread_stack_analyze.c
-void tx_thread_stack_check(void* thread_ptr);
-
-#define TX_THREAD_STACK_CHECK(thread_ptr) tx_thread_stack_check(thread_ptr);
-#endif
-
-/* Define the TX_THREAD control block extensions for this port. The main reason
-   for the multiple macros is so that backward compatibility can be maintained with
-   existing ThreadX kernel awareness modules.  */
-
-#define TX_THREAD_EXTENSION_0
-#define TX_THREAD_EXTENSION_1
-#define TX_THREAD_EXTENSION_2 ULONG tx_thread_vfp_enable;
-#define TX_THREAD_EXTENSION_3 TX_THREAD_SPECIFIC tx_thread_storage;
-
-/* Define the port extensions of the remaining ThreadX objects.  */
-
-#define TX_BLOCK_POOL_EXTENSION
-#define TX_BYTE_POOL_EXTENSION
-#define TX_EVENT_FLAGS_GROUP_EXTENSION
-#define TX_MUTEX_EXTENSION
-#define TX_QUEUE_EXTENSION
-#define TX_SEMAPHORE_EXTENSION
-#define TX_TIMER_EXTENSION
-
-/* Define the user extension field of the thread control block.  Nothing
-   additional is needed for this port so it is defined as white space.  */
-
-#ifndef TX_THREAD_USER_EXTENSION
-#define TX_THREAD_USER_EXTENSION void* counters;
-#endif
-
-/* Define the macros for processing extensions in tx_thread_create, tx_thread_delete,
-   tx_thread_shell_entry, and tx_thread_terminate.  */
-
-#define TX_THREAD_CREATE_EXTENSION(thread_ptr)
-#define TX_THREAD_DELETE_EXTENSION(thread_ptr) threadx_thread_destroy_extension(thread_ptr);
-#define TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
-#define TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
-
-/* Define the ThreadX object creation extensions for the remaining objects.  */
-
-#define TX_BLOCK_POOL_CREATE_EXTENSION(pool_ptr)
-#define TX_BYTE_POOL_CREATE_EXTENSION(pool_ptr)
-#define TX_EVENT_FLAGS_GROUP_CREATE_EXTENSION(group_ptr)
-#define TX_MUTEX_CREATE_EXTENSION(mutex_ptr)
-#define TX_QUEUE_CREATE_EXTENSION(queue_ptr)
-#define TX_SEMAPHORE_CREATE_EXTENSION(semaphore_ptr)
-#define TX_TIMER_CREATE_EXTENSION(timer_ptr)
-
-/* Define the ThreadX object deletion extensions for the remaining objects.  */
-
-#define TX_BLOCK_POOL_DELETE_EXTENSION(pool_ptr)
-#define TX_BYTE_POOL_DELETE_EXTENSION(pool_ptr)
-#define TX_EVENT_FLAGS_GROUP_DELETE_EXTENSION(group_ptr)
-#define TX_MUTEX_DELETE_EXTENSION(mutex_ptr)
-#define TX_QUEUE_DELETE_EXTENSION(queue_ptr)
-#define TX_SEMAPHORE_DELETE_EXTENSION(semaphore_ptr)
-#define TX_TIMER_DELETE_EXTENSION(timer_ptr)
-
-/* Determine if the ARM architecture has the CLZ instruction. This is available on
-   architectures v5 and above. If available, redefine the macro for calculating the
-   lowest bit set.  */
-
-#if __ARM_ARCH > 4
-
-//#ifndef __thumb__
-
-#define TX_LOWEST_SET_BIT_CALCULATE(m, b)            \
-	m = m & ((ULONG)(-((LONG)m)));                   \
-	asm volatile(" CLZ  %0,%1 " : "=r"(b) : "r"(m)); \
-	b = 31 - b;
-//#endif
-#endif
-
-/* Define ThreadX interrupt lockout and restore macros for protection on
-   access of critical kernel information.  The restore interrupt macro must
-   restore the interrupt posture of the running thread prior to the value
-   present prior to the disable macro.  In most cases, the save area macro
-   is used to define a local function save area for the disable and restore
-   macros.  */
-
-#ifdef __thumb__
-
-unsigned int _tx_thread_interrupt_disable(void);
-unsigned int _tx_thread_interrupt_restore(UINT old_posture);
-
-#define TX_INTERRUPT_SAVE_AREA unsigned int interrupt_save;
-
-#define TX_DISABLE interrupt_save = _tx_thread_interrupt_disable();
-#define TX_RESTORE _tx_thread_interrupt_restore(interrupt_save);
-
-#else
-
-#define TX_INTERRUPT_SAVE_AREA unsigned int interrupt_save;
-
-#ifdef TX_ENABLE_FIQ_SUPPORT
-#define TX_DISABLE asm volatile(" MRS %0,CPSR; CPSID if " : "=r"(interrupt_save));
-#else
-#define TX_DISABLE asm volatile(" MRS %0,CPSR; CPSID i " : "=r"(interrupt_save));
-#endif
-
-#define TX_RESTORE asm volatile(" MSR CPSR_c,%0 " ::"r"(interrupt_save));
-
-#endif
-
-/* Define VFP extension for the Cortex-A5.  Each is assumed to be called in the context of the
-   executing
-   thread.  */
-
-void tx_thread_vfp_enable(void);
-void tx_thread_vfp_disable(void);
-
-/* Define the interrupt lockout macros for each ThreadX object.  */
-
-#define TX_BLOCK_POOL_DISABLE TX_DISABLE
-#define TX_BYTE_POOL_DISABLE TX_DISABLE
-#define TX_EVENT_FLAGS_GROUP_DISABLE TX_DISABLE
-#define TX_MUTEX_DISABLE TX_DISABLE
-#define TX_QUEUE_DISABLE TX_DISABLE
-#define TX_SEMAPHORE_DISABLE TX_DISABLE
-
-extern void tx_pre_scheduler_hook(void);
-
-#define TX_PORT_SPECIFIC_PRE_SCHEDULER_INITIALIZATION tx_pre_scheduler_hook();
-
-/* Define the version ID of ThreadX.  This may be utilized by the application.  */
-
-#ifdef TX_THREAD_INIT
-CHAR _tx_version_id[] = "Copyright (c) 1996-2014 Express Logic Inc. * ThreadX Cortex-A5/GNU "
-						"Version G5.6.5.0 SN: 4109-270-0501 *";
-#else
-extern CHAR _tx_version_id[];
-#endif
-
-#endif
+/**************************************************************************/
+/*                                                                        */
+/*            Copyright (c) 1996-2014 by Express Logic Inc.               */
+/*                                                                        */
+/*  This software is copyrighted by and is the sole property of Express   */
+/*  Logic, Inc.  All rights, title, ownership, or other interests         */
+/*  in the software remain the property of Express Logic, Inc.  This      */
+/*  software may only be used in accordance with the corresponding        */
+/*  license agreement.  Any unauthorized use, duplication, transmission,  */
+/*  distribution, or disclosure of this software is expressly forbidden.  */
+/*                                                                        */
+/*  This Copyright notice may not be removed or modified without prior    */
+/*  written consent of Express Logic, Inc.                                */
+/*                                                                        */
+/*  Express Logic, Inc. reserves the right to modify this software        */
+/*  without notice.                                                       */
+/*                                                                        */
+/*  Express Logic, Inc.                     info@expresslogic.com         */
+/*  11423 West Bernardo Court               http://www.expresslogic.com   */
+/*  San Diego, CA  92127                                                  */
+/*                                                                        */
+/**************************************************************************/
+
+/**************************************************************************/
+/**************************************************************************/
+/**                                                                       */
+/** ThreadX Component                                                     */
+/**                                                                       */
+/**   Port Specific                                                       */
+/**                                                                       */
+/**************************************************************************/
+/**************************************************************************/
+
+/**************************************************************************/
+/*                                                                        */
+/*  PORT SPECIFIC C INFORMATION                            RELEASE        */
+/*                                                                        */
+/*    tx_port.h                                         Cortex-A5/GNU     */
+/*                                                           5.0          */
+/*                                                                        */
+/*  AUTHOR                                                                */
+/*                                                                        */
+/*    William E. Lamie, Express Logic, Inc.                               */
+/*                                                                        */
+/*  DESCRIPTION                                                           */
+/*                                                                        */
+/*    This file contains data type definitions that make the ThreadX      */
+/*    real-time kernel function identically on a variety of different     */
+/*    processor architectures.  For example, the size or number of bits   */
+/*    in an "int" data type vary between microprocessor architectures and */
+/*    even C compilers for the same microprocessor.  ThreadX does not     */
+/*    directly use native C data types.  Instead, ThreadX creates its     */
+/*    own special types that can be mapped to actual data types by this   */
+/*    file to guarantee consistency in the interface and functionality.   */
+/*                                                                        */
+/*  RELEASE HISTORY                                                       */
+/*                                                                        */
+/*    DATE              NAME                      DESCRIPTION             */
+/*                                                                        */
+/*  01-01-2014     William E. Lamie         Initial Cortex-A5 GNU         */
+/*                                            Support Version 5.0         */
+/*                                                                        */
+/**************************************************************************/
+
+#ifndef TX_PORT_H
+#define TX_PORT_H
+
+/* Determine if the optional ThreadX user define file should be used.  */
+
+#ifdef TX_INCLUDE_USER_DEFINE_FILE
+
+/* Yes, include the user defines in tx_user.h. The defines in this file may
+   alternately be defined on the command line.  */
+
+#include "tx_user.h"
+#endif
+
+/* Define compiler library include files.  */
+
+#include <string.h>
+
+/* Define ThreadX basic types for this port.  */
+
+#define VOID void
+typedef char CHAR;
+typedef unsigned char UCHAR;
+typedef int INT;
+typedef unsigned int UINT;
+typedef long LONG;
+typedef unsigned long ULONG;
+typedef short SHORT;
+typedef unsigned short USHORT;
+
+/* Define the priority levels for ThreadX.  Legal values range
+   from 32 to 1024 and MUST be evenly divisible by 32.  */
+
+#ifndef TX_MAX_PRIORITIES
+#define TX_MAX_PRIORITIES 32
+#endif
+
+/* Define the minimum stack for a ThreadX thread on this processor. If the size supplied during
+   thread creation is less than this value, the thread create call will return an error.  */
+
+#ifndef TX_MINIMUM_STACK
+#define TX_MINIMUM_STACK 200 /* Minimum stack size for this port  */
+#endif
+
+/* Define the system timer thread's default stack size and priority.  These are only applicable
+   if TX_TIMER_PROCESS_IN_ISR is not defined.  */
+
+#ifndef TX_TIMER_THREAD_STACK_SIZE
+#define TX_TIMER_THREAD_STACK_SIZE 1024 /* Default timer thread stack size  */
+#endif
+
+#ifndef TX_TIMER_THREAD_PRIORITY
+#define TX_TIMER_THREAD_PRIORITY 0 /* Default timer thread priority    */
+#endif
+
+/* Define various constants for the ThreadX ARM port.  */
+
+#ifdef TX_ENABLE_FIQ_SUPPORT
+#define TX_INT_DISABLE 0xC0 /* Disable IRQ & FIQ interrupts     */
+#else
+#define TX_INT_DISABLE 0x80 /* Disable IRQ interrupts           */
+#endif
+#define TX_INT_ENABLE 0x00 /* Enable IRQ interrupts            */
+
+// uncomment this if you want to enable event trace
+//#define TX_ENABLE_EVENT_TRACE
+
+/* Define the clock source for trace event entry time stamp. The following two item are port
+   specific.
+   For example, if the time source is at the address 0x0a800024 and is 16-bits in size, the clock
+   source constants would be:
+*/
+#define TX_TRACE_TIME_SOURCE 0x0a800024UL
+#define TX_TRACE_TIME_MASK 0x0000FFFFUL
+
+#ifndef TX_TRACE_TIME_SOURCE
+#define TX_TRACE_TIME_SOURCE ++_tx_trace_simulated_time
+#endif
+#ifndef TX_TRACE_TIME_MASK
+#define TX_TRACE_TIME_MASK 0xFFFFFFFFUL
+#endif
+
+/* Define the port specific options for the _tx_build_options variable. This variable indicates
+   how the ThreadX library was built.  */
+
+#ifdef TX_ENABLE_FIQ_SUPPORT
+#define TX_FIQ_ENABLED 1
+#else
+#define TX_FIQ_ENABLED 0
+#endif
+
+#ifdef TX_ENABLE_IRQ_NESTING
+#define TX_IRQ_NESTING_ENABLED 2
+#else
+#define TX_IRQ_NESTING_ENABLED 0
+#endif
+
+#ifdef TX_ENABLE_FIQ_NESTING
+#define TX_FIQ_NESTING_ENABLED 4
+#else
+#define TX_FIQ_NESTING_ENABLED 0
+#endif
+
+#define TX_PORT_SPECIFIC_BUILD_OPTIONS \
+	TX_FIQ_ENABLED | TX_IRQ_NESTING_ENABLED | TX_FIQ_NESTING_ENABLED
+
+/* Define the in-line initialization constant so that modules with in-line
+   initialization capabilities can prevent their initialization from being
+   a function call.  */
+
+#define TX_INLINE_INITIALIZATION
+
+/* Determine whether or not stack checking is enabled. By default, ThreadX stack checking is
+   disabled. When the following is defined, ThreadX thread stack checking is enabled.  If stack
+   checking is enabled (TX_ENABLE_STACK_CHECKING is defined), the TX_DISABLE_STACK_FILLING
+   define is negated, thereby forcing the stack fill which is necessary for the stack checking
+   logic.  */
+
+#ifdef TX_ENABLE_STACK_CHECKING
+#undef TX_DISABLE_STACK_FILLING
+
+// Lives in threadx/src/tx_thread_stack_analyze.c
+void tx_thread_stack_check(void* thread_ptr);
+
+#define TX_THREAD_STACK_CHECK(thread_ptr) tx_thread_stack_check(thread_ptr);
+#endif
+
+/* Define the TX_THREAD control block extensions for this port. The main reason
+   for the multiple macros is so that backward compatibility can be maintained with
+   existing ThreadX kernel awareness modules.  */
+
+#define TX_THREAD_EXTENSION_0
+#define TX_THREAD_EXTENSION_1
+#define TX_THREAD_EXTENSION_2 ULONG tx_thread_vfp_enable;
+#define TX_THREAD_EXTENSION_3 TX_THREAD_SPECIFIC tx_thread_storage;
+
+/* Define the port extensions of the remaining ThreadX objects.  */
+
+#define TX_BLOCK_POOL_EXTENSION
+#define TX_BYTE_POOL_EXTENSION
+#define TX_EVENT_FLAGS_GROUP_EXTENSION
+#define TX_MUTEX_EXTENSION
+#define TX_QUEUE_EXTENSION
+#define TX_SEMAPHORE_EXTENSION
+#define TX_TIMER_EXTENSION
+
+/* Define the user extension field of the thread control block.  Nothing
+   additional is needed for this port so it is defined as white space.  */
+
+#ifndef TX_THREAD_USER_EXTENSION
+#define TX_THREAD_USER_EXTENSION void* counters;
+#endif
+
+/* Define the macros for processing extensions in tx_thread_create, tx_thread_delete,
+   tx_thread_shell_entry, and tx_thread_terminate.  */
+
+#define TX_THREAD_CREATE_EXTENSION(thread_ptr)
+#define TX_THREAD_DELETE_EXTENSION(thread_ptr) threadx_thread_destroy_extension(thread_ptr);
+#define TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
+#define TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
+
+/* Define the ThreadX object creation extensions for the remaining objects.  */
+
+#define TX_BLOCK_POOL_CREATE_EXTENSION(pool_ptr)
+#define TX_BYTE_POOL_CREATE_EXTENSION(pool_ptr)
+#define TX_EVENT_FLAGS_GROUP_CREATE_EXTENSION(group_ptr)
+#define TX_MUTEX_CREATE_EXTENSION(mutex_ptr)
+#define TX_QUEUE_CREATE_EXTENSION(queue_ptr)
+#define TX_SEMAPHORE_CREATE_EXTENSION(semaphore_ptr)
+#define TX_TIMER_CREATE_EXTENSION(timer_ptr)
+
+/* Define the ThreadX object deletion extensions for the remaining objects.  */
+
+#define TX_BLOCK_POOL_DELETE_EXTENSION(pool_ptr)
+#define TX_BYTE_POOL_DELETE_EXTENSION(pool_ptr)
+#define TX_EVENT_FLAGS_GROUP_DELETE_EXTENSION(group_ptr)
+#define TX_MUTEX_DELETE_EXTENSION(mutex_ptr)
+#define TX_QUEUE_DELETE_EXTENSION(queue_ptr)
+#define TX_SEMAPHORE_DELETE_EXTENSION(semaphore_ptr)
+#define TX_TIMER_DELETE_EXTENSION(timer_ptr)
+
+/* Determine if the ARM architecture has the CLZ instruction. This is available on
+   architectures v5 and above. If available, redefine the macro for calculating the
+   lowest bit set.  */
+
+#if __ARM_ARCH > 4
+
+//#ifndef __thumb__
+
+#define TX_LOWEST_SET_BIT_CALCULATE(m, b)            \
+	m = m & ((ULONG)(-((LONG)m)));                   \
+	asm volatile(" CLZ  %0,%1 " : "=r"(b) : "r"(m)); \
+	b = 31 - b;
+//#endif
+#endif
+
+/* Define ThreadX interrupt lockout and restore macros for protection on
+   access of critical kernel information.  The restore interrupt macro must
+   restore the interrupt posture of the running thread prior to the value
+   present prior to the disable macro.  In most cases, the save area macro
+   is used to define a local function save area for the disable and restore
+   macros.  */
+
+#ifdef __thumb__
+
+unsigned int _tx_thread_interrupt_disable(void);
+unsigned int _tx_thread_interrupt_restore(UINT old_posture);
+
+#define TX_INTERRUPT_SAVE_AREA unsigned int interrupt_save;
+
+#define TX_DISABLE interrupt_save = _tx_thread_interrupt_disable();
+#define TX_RESTORE _tx_thread_interrupt_restore(interrupt_save);
+
+#else
+
+#define TX_INTERRUPT_SAVE_AREA unsigned int interrupt_save;
+
+#ifdef TX_ENABLE_FIQ_SUPPORT
+#define TX_DISABLE asm volatile(" MRS %0,CPSR; CPSID if " : "=r"(interrupt_save));
+#else
+#define TX_DISABLE asm volatile(" MRS %0,CPSR; CPSID i " : "=r"(interrupt_save));
+#endif
+
+#define TX_RESTORE asm volatile(" MSR CPSR_c,%0 " ::"r"(interrupt_save));
+
+#endif
+
+/* Define VFP extension for the Cortex-A5.  Each is assumed to be called in the context of the
+   executing
+   thread.  */
+
+void tx_thread_vfp_enable(void);
+void tx_thread_vfp_disable(void);
+
+/* Define the interrupt lockout macros for each ThreadX object.  */
+
+#define TX_BLOCK_POOL_DISABLE TX_DISABLE
+#define TX_BYTE_POOL_DISABLE TX_DISABLE
+#define TX_EVENT_FLAGS_GROUP_DISABLE TX_DISABLE
+#define TX_MUTEX_DISABLE TX_DISABLE
+#define TX_QUEUE_DISABLE TX_DISABLE
+#define TX_SEMAPHORE_DISABLE TX_DISABLE
+
+extern void tx_pre_scheduler_hook(void);
+
+#define TX_PORT_SPECIFIC_PRE_SCHEDULER_INITIALIZATION tx_pre_scheduler_hook();
+
+/* Define the version ID of ThreadX.  This may be utilized by the application.  */
+
+#ifdef TX_THREAD_INIT
+CHAR _tx_version_id[] = "Copyright (c) 1996-2014 Express Logic Inc. * ThreadX Cortex-A5/GNU "
+						"Version G5.6.5.0 SN: 4109-270-0501 *";
+#else
+extern CHAR _tx_version_id[];
+#endif
+
+#endif
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/aligned_malloc.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/aligned_malloc.h
index 3aabb95..853afb3 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/aligned_malloc.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/aligned_malloc.h	
@@ -1,91 +1,91 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#ifndef ALIGNED_MALLOC_H_
-#define ALIGNED_MALLOC_H_
-
-#include <stddef.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Allocated aligned memory
- *
- * Allocate memory with at least alignment `align` and size `size`
- * 	Memory which has been allocated with aligned_malloc() must be freed by calling
- *	aligned_free(). Calling free() will result in a panic or other negative effects.
- *
- * @param align Alignment of the memory block.
- *	Alignment refers to the starting address of the memory block.
- *	If 32-byte alignment is requested, the start address of the returned pointer
- *	will be 32-byte aligned.
- *	Note: Alignment must be a power of two. (1, 2, 4, 8, etc.)
- *
- * @param size Size of the memory allocation
- *
- * @return Pointer to allocated memory. If memory was not successfully allocated,
- *	the function will return NULL. This can happen due to invalid input
- *	(alignment is 0, size is 0, alignment is not a power of 2) or due to insufficient
- *	memory left for the requested allocation.
- */
-void* aligned_malloc(size_t align, size_t size);
-
-/**
- * @brief A convenience macro for the Linux API
- *
- * memalign() is simply a convenience definition which provides the commonly-used
- *	 Linux API memalign. This forwards the arguments to aligned_malloc() and behaves
- *	 in the same manner.
- *
- * @param align Alignment of the memory block.
- *	Alignment refers to the starting address of the memory block.
- *	If 32-byte alignment is requested, the start address of the returned pointer
- *	will be 32-byte aligned.
- *	Note: Alignment must be a power of two. (1, 2, 4, 8, etc.)
- *
- * @param size Size of the memory allocation
- *
- * @return Pointer to allocated memory. If memory was not successfully allocated,
- *	the function will return NULL. This can happen due to invalid input
- *	(alignment is 0, size is 0, alignment is not a power of 2) or due to insufficient
- *	memory left for the requested allocation.
- */
-#define memalign(align, size) aligned_malloc(align, size)
-
-/** Posix Memory Alignment Extension
- *
- * Generated aligned memory. This function forwards the request to aligned malloc.
- * Allocated memory must be freed with aligned_free().
- *
- * @param memptr A pointer to the pointer which will store the aligned memory. The
- *	memory must be freed with aligned_free(). memptr must not be NULL.
- * @param alignment The target alignment for the memory. Must be a power of 2.
- * @param size The size of the allocation. Must be > 0.
- *
- * @pre `memptr` is not NULL. `alignment` is power-of-2. `size` > 0.
- *
- * @returns ENOMEM if memory could not be allocated, EINVAL if alignment is not a power-of-2, and
- *	0 on successful allocation.
- */
-int posix_memalign(void** memptr, size_t alignment, size_t size);
-
-/**
- * @brief Free aligned memory
- *
- * Free memory that was allocated using aligned_malloc().
- * 	This function *must not* be called on memory which was not allocated
- * 	with aligned_malloc().
- *
- * @param ptr Pointer to the aligned_memory() block that will be freed.
- */
-void aligned_free(void* ptr);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif // ALIGNED_MALLOC_H_
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#ifndef ALIGNED_MALLOC_H_
+#define ALIGNED_MALLOC_H_
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Allocated aligned memory
+ *
+ * Allocate memory with at least alignment `align` and size `size`
+ * 	Memory which has been allocated with aligned_malloc() must be freed by calling
+ *	aligned_free(). Calling free() will result in a panic or other negative effects.
+ *
+ * @param align Alignment of the memory block.
+ *	Alignment refers to the starting address of the memory block.
+ *	If 32-byte alignment is requested, the start address of the returned pointer
+ *	will be 32-byte aligned.
+ *	Note: Alignment must be a power of two. (1, 2, 4, 8, etc.)
+ *
+ * @param size Size of the memory allocation
+ *
+ * @return Pointer to allocated memory. If memory was not successfully allocated,
+ *	the function will return NULL. This can happen due to invalid input
+ *	(alignment is 0, size is 0, alignment is not a power of 2) or due to insufficient
+ *	memory left for the requested allocation.
+ */
+void* aligned_malloc(size_t align, size_t size);
+
+/**
+ * @brief A convenience macro for the Linux API
+ *
+ * memalign() is simply a convenience definition which provides the commonly-used
+ *	 Linux API memalign. This forwards the arguments to aligned_malloc() and behaves
+ *	 in the same manner.
+ *
+ * @param align Alignment of the memory block.
+ *	Alignment refers to the starting address of the memory block.
+ *	If 32-byte alignment is requested, the start address of the returned pointer
+ *	will be 32-byte aligned.
+ *	Note: Alignment must be a power of two. (1, 2, 4, 8, etc.)
+ *
+ * @param size Size of the memory allocation
+ *
+ * @return Pointer to allocated memory. If memory was not successfully allocated,
+ *	the function will return NULL. This can happen due to invalid input
+ *	(alignment is 0, size is 0, alignment is not a power of 2) or due to insufficient
+ *	memory left for the requested allocation.
+ */
+#define memalign(align, size) aligned_malloc(align, size)
+
+/** Posix Memory Alignment Extension
+ *
+ * Generated aligned memory. This function forwards the request to aligned malloc.
+ * Allocated memory must be freed with aligned_free().
+ *
+ * @param memptr A pointer to the pointer which will store the aligned memory. The
+ *	memory must be freed with aligned_free(). memptr must not be NULL.
+ * @param alignment The target alignment for the memory. Must be a power of 2.
+ * @param size The size of the allocation. Must be > 0.
+ *
+ * @pre `memptr` is not NULL. `alignment` is power-of-2. `size` > 0.
+ *
+ * @returns ENOMEM if memory could not be allocated, EINVAL if alignment is not a power-of-2, and
+ *	0 on successful allocation.
+ */
+int posix_memalign(void** memptr, size_t alignment, size_t size);
+
+/**
+ * @brief Free aligned memory
+ *
+ * Free memory that was allocated using aligned_malloc().
+ * 	This function *must not* be called on memory which was not allocated
+ * 	with aligned_malloc().
+ *
+ * @param ptr Pointer to the aligned_memory() block that will be freed.
+ */
+void aligned_free(void* ptr);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif // ALIGNED_MALLOC_H_
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/malloc.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/malloc.h
index 715e78b..b51ef18 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/malloc.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/include/malloc.h	
@@ -1,43 +1,43 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#ifndef MALLOC_H_
-#define MALLOC_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif //__cplusplus
-
-#include <stdlib.h>
-
-/**
- * @brief Assign blocks of memory for use by malloc().
- *
- * Initializes the malloc() backend with a memory address and memory pool size.
- *	This memory is assumed to be owned by malloc() and is vended out when memory is requested.
- * 	Multiple blocks can be added.
- *
- * NOTE: This API must be called before malloc() can be used. If you call malloc() before
- * 	allocating memory, malloc() will return NULL because there is no available memory
- *	to provide to the user.
- *
- * @param addr Pointer to the memory block address that you are providing to malloc()
- * @param size Size of the memory block that you are providing to malloc()
- */
-void malloc_addblock(void* addr, size_t size);
-
-/**
- * @brief Initialize Malloc
- *
- * Weakly linked, can be overridden based on your needs.
- * Each malloc implementation contains a different set of initialization requirements
- */
-void malloc_init(void);
-
-#ifdef __cplusplus
-}
-#endif //__cplusplus
-
-#endif // MALLOC_H_
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#ifndef MALLOC_H_
+#define MALLOC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+#include <stdlib.h>
+
+/**
+ * @brief Assign blocks of memory for use by malloc().
+ *
+ * Initializes the malloc() backend with a memory address and memory pool size.
+ *	This memory is assumed to be owned by malloc() and is vended out when memory is requested.
+ * 	Multiple blocks can be added.
+ *
+ * NOTE: This API must be called before malloc() can be used. If you call malloc() before
+ * 	allocating memory, malloc() will return NULL because there is no available memory
+ *	to provide to the user.
+ *
+ * @param addr Pointer to the memory block address that you are providing to malloc()
+ * @param size Size of the memory block that you are providing to malloc()
+ */
+void malloc_addblock(void* addr, size_t size);
+
+/**
+ * @brief Initialize Malloc
+ *
+ * Weakly linked, can be overridden based on your needs.
+ * Each malloc implementation contains a different set of initialization requirements
+ */
+void malloc_init(void);
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+
+#endif // MALLOC_H_
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/aligned_malloc.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/aligned_malloc.c
index ce8a8c7..c61a0da 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/aligned_malloc.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/aligned_malloc.c	
@@ -1,102 +1,102 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <assert.h>
-#include <stdbool.h>
-#include <stdint.h>
-
-#include "aligned_malloc.h"
-
-#pragma mark - Definitions -
-
-// We forward declare these to prevent include header prevention from the OS
-extern void* malloc(size_t size);
-extern void free(void* ptr);
-
-// We need to declare this prototype here since we don't include the header.
-void* aligned_alloc(size_t align, size_t size);
-
-/**
- * Simple macro for making sure memory addresses are aligned
- * to the nearest power of two
- */
-#ifndef align_up
-#define align_up(num, align) (((num) + ((align)-1)) & ~((align)-1))
-#endif
-
-/// Number of bytes we're using for storing the aligned pointer offset
-typedef uint16_t offset_t;
-
-/// Macro for accessing the size of our current pointer offset
-#define PTR_OFFSET_SZ sizeof(offset_t)
-
-#pragma mark - APIs -
-
-/**
- * We will call malloc with extra bytes for our header and the offset
- *	required to guarantee the desired alignment.
- */
-void* aligned_malloc(size_t align, size_t size)
-{
-	void* ptr = NULL;
-
-	// We want it to be a power of two since align_up operates on powers of two
-	assert((align & (align - 1)) == 0);
-
-	if(align && size)
-	{
-		/*
-		 * We know we have to fit an offset value
-		 * We also allocate extra bytes to ensure we can meet the alignment
-		 */
-		size_t hdr_size = PTR_OFFSET_SZ + (align - 1);
-		void* p = malloc(size + hdr_size);
-
-		if(p)
-		{
-			/*
-			 * Add the offset size to malloc's pointer (we will always store that)
-			 * Then align the resulting value to the arget alignment
-			 */
-			ptr = (void*)align_up(((uintptr_t)p + PTR_OFFSET_SZ), align);
-
-			// Calculate the offset and store it behind our aligned pointer
-			*((offset_t*)ptr - 1) = (offset_t)((uintptr_t)ptr - (uintptr_t)p);
-
-		} // else NULL, could not malloc
-	} // else NULL, invalid arguments
-
-	return ptr;
-}
-
-#if(defined(__ISO_C_VISIBLE) && __ISO_C_VISIBLE >= 2011) || \
-	(defined(__ISO_C_VISIBLE) && __STDC_VERSION >= 20112L)
-void* aligned_alloc(size_t align, size_t size)
-{
-	return aligned_malloc(align, size);
-}
-#endif
-
-/**
- * aligned_free works like free(), but we work backwards from the returned
- * pointer to find the correct offset and pointer location to return to free()
- * Note that it is VERY BAD to call free() on an aligned_malloc() pointer.
- */
-void aligned_free(void* ptr)
-{
-	assert(ptr);
-
-	/*
-	 * Walk backwards from the passed-in pointer to get the pointer offset
-	 * We convert to an offset_t pointer and rely on pointer math to get the data
-	 */
-	offset_t offset = *((offset_t*)ptr - 1);
-
-	/*
-	 * Once we have the offset, we can get our original pointer and call free
-	 */
-	void* p = (void*)((uint8_t*)ptr - offset);
-	free(p);
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "aligned_malloc.h"
+
+#pragma mark - Definitions -
+
+// We forward declare these to prevent include header prevention from the OS
+extern void* malloc(size_t size);
+extern void free(void* ptr);
+
+// We need to declare this prototype here since we don't include the header.
+void* aligned_alloc(size_t align, size_t size);
+
+/**
+ * Simple macro for making sure memory addresses are aligned
+ * to the nearest power of two
+ */
+#ifndef align_up
+#define align_up(num, align) (((num) + ((align)-1)) & ~((align)-1))
+#endif
+
+/// Number of bytes we're using for storing the aligned pointer offset
+typedef uint16_t offset_t;
+
+/// Macro for accessing the size of our current pointer offset
+#define PTR_OFFSET_SZ sizeof(offset_t)
+
+#pragma mark - APIs -
+
+/**
+ * We will call malloc with extra bytes for our header and the offset
+ *	required to guarantee the desired alignment.
+ */
+void* aligned_malloc(size_t align, size_t size)
+{
+	void* ptr = NULL;
+
+	// We want it to be a power of two since align_up operates on powers of two
+	assert((align & (align - 1)) == 0);
+
+	if(align && size)
+	{
+		/*
+		 * We know we have to fit an offset value
+		 * We also allocate extra bytes to ensure we can meet the alignment
+		 */
+		size_t hdr_size = PTR_OFFSET_SZ + (align - 1);
+		void* p = malloc(size + hdr_size);
+
+		if(p)
+		{
+			/*
+			 * Add the offset size to malloc's pointer (we will always store that)
+			 * Then align the resulting value to the arget alignment
+			 */
+			ptr = (void*)align_up(((uintptr_t)p + PTR_OFFSET_SZ), align);
+
+			// Calculate the offset and store it behind our aligned pointer
+			*((offset_t*)ptr - 1) = (offset_t)((uintptr_t)ptr - (uintptr_t)p);
+
+		} // else NULL, could not malloc
+	} // else NULL, invalid arguments
+
+	return ptr;
+}
+
+#if(defined(__ISO_C_VISIBLE) && __ISO_C_VISIBLE >= 2011) || \
+	(defined(__ISO_C_VISIBLE) && __STDC_VERSION >= 20112L)
+void* aligned_alloc(size_t align, size_t size)
+{
+	return aligned_malloc(align, size);
+}
+#endif
+
+/**
+ * aligned_free works like free(), but we work backwards from the returned
+ * pointer to find the correct offset and pointer location to return to free()
+ * Note that it is VERY BAD to call free() on an aligned_malloc() pointer.
+ */
+void aligned_free(void* ptr)
+{
+	assert(ptr);
+
+	/*
+	 * Walk backwards from the passed-in pointer to get the pointer offset
+	 * We convert to an offset_t pointer and rely on pointer math to get the data
+	 */
+	offset_t offset = *((offset_t*)ptr - 1);
+
+	/*
+	 * Once we have the offset, we can get our original pointer and call free
+	 */
+	void* p = (void*)((uint8_t*)ptr - offset);
+	free(p);
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_assert.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_assert.c
index f96b301..c63d7b5 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_assert.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_assert.c	
@@ -1,30 +1,30 @@
-/*
- * Copyright © 2019 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <assert.h>
-#include <malloc.h>
-#include <memory.h>
-
-#pragma mark - APIs -
-
-__attribute__((weak)) void malloc_init(void)
-{
-	assert(0 && "malloc is not supported.");
-}
-
-void* malloc(size_t __attribute__((unused)) size)
-{
-	assert(0 && "malloc is not supported");
-	return NULL;
-}
-
-void free(__attribute__((unused)) void* ptr)
-{
-	assert(0 && "malloc is not supported");
-	while(1)
-	{
-		// Loop forever
-	}
-}
+/*
+ * Copyright © 2019 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <assert.h>
+#include <malloc.h>
+#include <memory.h>
+
+#pragma mark - APIs -
+
+__attribute__((weak)) void malloc_init(void)
+{
+	assert(0 && "malloc is not supported.");
+}
+
+void* malloc(size_t __attribute__((unused)) size)
+{
+	assert(0 && "malloc is not supported");
+	return NULL;
+}
+
+void free(__attribute__((unused)) void* ptr)
+{
+	assert(0 && "malloc is not supported");
+	while(1)
+	{
+		// Loop forever
+	}
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_framework_rtos.cpp b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_framework_rtos.cpp
index 577eaa0..4d5de80 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_framework_rtos.cpp	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_framework_rtos.cpp	
@@ -1,27 +1,27 @@
-/*
- * Copyright © 2019 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <heap.hpp>
-#include <malloc.h>
-
-void malloc_addblock(void* addr, size_t size)
-{
-	os::Heap::addBlock(addr, size);
-}
-
-__attribute__((weak)) void malloc_init()
-{
-	os::Heap::init();
-}
-
-void* malloc(size_t size)
-{
-	return os::Heap::alloc(size);
-}
-
-void free(void* ptr)
-{
-	os::Heap::free(ptr);
-}
+/*
+ * Copyright © 2019 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <heap.hpp>
+#include <malloc.h>
+
+void malloc_addblock(void* addr, size_t size)
+{
+	os::Heap::addBlock(addr, size);
+}
+
+__attribute__((weak)) void malloc_init()
+{
+	os::Heap::init();
+}
+
+void* malloc(size_t size)
+{
+	return os::Heap::alloc(size);
+}
+
+void free(void* ptr)
+{
+	os::Heap::free(ptr);
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freelist.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freelist.c
index cfb8078..2a627a6 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freelist.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freelist.c	
@@ -1,207 +1,207 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <linkedlist/ll.h>
-#include <malloc.h>
-#include <memory.h>
-#include <stdint.h>
-
-#pragma mark - Definitions -
-
-/**
- * Simple macro for making sure memory addresses are aligned
- * to the nearest power of two
- */
-#ifndef align_up
-#define align_up(num, align) (((num) + ((align)-1)) & ~((align)-1))
-#endif
-
-/*
- * This is the container for our free-list.
- * Node the usage of the linked list here: the library uses offsetof
- * and container_of to manage the list and get back to the parent struct.
- */
-typedef struct
-{
-	ll_t node;
-	size_t size;
-	char* block;
-} alloc_node_t;
-
-/**
- * We vend a memory address to the user.  This lets us translate back and forth
- * between the vended pointer and the container we use for managing the data.
- */
-#define ALLOC_HEADER_SZ offsetof(alloc_node_t, block)
-
-// We are enforcing a minimum allocation size of 32B.
-#define MIN_ALLOC_SZ ALLOC_HEADER_SZ + 32
-
-#pragma mark - Prototypes -
-
-static void defrag_free_list(void);
-
-/**
- * @brief Lock malloc (for thread safety.)
- *
- * Weakly linked, can be overridden based on your needs.
- * By default, this implementation is not thread safe, and malloc_lock() is a no-op.
- * If you need a thread-safe version, define the function for your system - it should
- * lock a mutex.
- *
- * @post The lock is held by a single thread.
- */
-void malloc_lock();
-
-/**
- * @brief Unlock malloc (for thread safety)
- *
- * Weakly linked, can be overridden based on your needs.
- * By default, this implementation is not thread safe, and malloc_unlock() is a no-op.
- * If you need a thread-safe version, define the function for your system - it should
- * unlock a mutex.
- *
- * @post The lock is released.
- */
-void malloc_unlock();
-
-#pragma mark - Declarations -
-
-// This macro simply declares and initializes our linked list
-static LIST_INIT(free_list);
-
-#pragma mark - Private Functions -
-
-/**
- * When we free, we can take our node and check to see if any memory blocks
- * can be combined into larger blocks.  This will help us fight against
- * memory fragmentation in a simple way.
- */
-void defrag_free_list(void)
-{
-	alloc_node_t* b = NULL;
-	alloc_node_t* lb = NULL;
-	alloc_node_t* t = NULL;
-
-	list_for_each_entry_safe(b, t, &free_list, node)
-	{
-		if(lb)
-		{
-			if((((uintptr_t)&lb->block) + lb->size) == (uintptr_t)b)
-			{
-				lb->size += sizeof(*b) + b->size;
-				list_del(&b->node);
-				continue;
-			}
-		}
-		lb = b;
-	}
-}
-
-#pragma mark - APIs -
-
-__attribute__((weak)) void malloc_init(void)
-{
-	// Unused here, override to specify your own init function
-	// Which includes malloc_addblock calls
-}
-
-__attribute__((weak)) void malloc_lock()
-{
-	// Intentional no-op
-}
-
-__attribute__((weak)) void malloc_unlock()
-{
-	// Intentional no-op
-}
-
-void* malloc(size_t size)
-{
-	void* ptr = NULL;
-	alloc_node_t* blk = NULL;
-
-	if(size > 0)
-	{
-		// Align the pointer
-		size = align_up(size, sizeof(void*));
-
-		malloc_lock();
-
-		// try to find a big enough block to alloc
-		list_for_each_entry(blk, &free_list, node)
-		{
-			if(blk->size >= size)
-			{
-				ptr = &blk->block;
-				break;
-			}
-		}
-
-		// we found something
-		if(ptr)
-		{
-			// Can we split the block?
-			if((blk->size - size) >= MIN_ALLOC_SZ)
-			{
-				alloc_node_t* new_blk = (alloc_node_t*)((uintptr_t)(&blk->block) + size);
-				new_blk->size = blk->size - size - ALLOC_HEADER_SZ;
-				blk->size = size;
-				list_insert(&new_blk->node, &blk->node, blk->node.next);
-			}
-
-			list_del(&blk->node);
-		}
-
-		malloc_unlock();
-
-	} // else NULL
-
-	return ptr;
-}
-
-void free(void* ptr)
-{
-	// Don't free a NULL pointer..
-	if(ptr)
-	{
-		// we take the pointer and use container_of to get the corresponding alloc block
-		alloc_node_t* blk = container_of(ptr, alloc_node_t, block);
-		alloc_node_t* free_blk = NULL;
-
-		malloc_lock();
-
-		// Let's put it back in the proper spot
-		list_for_each_entry(free_blk, &free_list, node)
-		{
-			if(free_blk > blk)
-			{
-				list_insert(&blk->node, free_blk->node.prev, &free_blk->node);
-				goto blockadded;
-			}
-		}
-		list_add_tail(&blk->node, &free_list);
-
-	blockadded:
-		// Let's see if we can combine any memory
-		defrag_free_list();
-
-		malloc_unlock();
-	}
-}
-
-void malloc_addblock(void* addr, size_t size)
-{
-	// let's align the start address of our block to the next pointer aligned number
-	alloc_node_t* blk = (void*)align_up((uintptr_t)addr, sizeof(void*));
-
-	// calculate actual size - remove our alignment and our header space from the availability
-	blk->size = (uintptr_t)addr + size - (uintptr_t)blk - ALLOC_HEADER_SZ;
-
-	// and now our giant block of memory is added to the list!
-	malloc_lock();
-	list_add(&blk->node, &free_list);
-	malloc_unlock();
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <linkedlist/ll.h>
+#include <malloc.h>
+#include <memory.h>
+#include <stdint.h>
+
+#pragma mark - Definitions -
+
+/**
+ * Simple macro for making sure memory addresses are aligned
+ * to the nearest power of two
+ */
+#ifndef align_up
+#define align_up(num, align) (((num) + ((align)-1)) & ~((align)-1))
+#endif
+
+/*
+ * This is the container for our free-list.
+ * Node the usage of the linked list here: the library uses offsetof
+ * and container_of to manage the list and get back to the parent struct.
+ */
+typedef struct
+{
+	ll_t node;
+	size_t size;
+	char* block;
+} alloc_node_t;
+
+/**
+ * We vend a memory address to the user.  This lets us translate back and forth
+ * between the vended pointer and the container we use for managing the data.
+ */
+#define ALLOC_HEADER_SZ offsetof(alloc_node_t, block)
+
+// We are enforcing a minimum allocation size of 32B.
+#define MIN_ALLOC_SZ ALLOC_HEADER_SZ + 32
+
+#pragma mark - Prototypes -
+
+static void defrag_free_list(void);
+
+/**
+ * @brief Lock malloc (for thread safety.)
+ *
+ * Weakly linked, can be overridden based on your needs.
+ * By default, this implementation is not thread safe, and malloc_lock() is a no-op.
+ * If you need a thread-safe version, define the function for your system - it should
+ * lock a mutex.
+ *
+ * @post The lock is held by a single thread.
+ */
+void malloc_lock();
+
+/**
+ * @brief Unlock malloc (for thread safety)
+ *
+ * Weakly linked, can be overridden based on your needs.
+ * By default, this implementation is not thread safe, and malloc_unlock() is a no-op.
+ * If you need a thread-safe version, define the function for your system - it should
+ * unlock a mutex.
+ *
+ * @post The lock is released.
+ */
+void malloc_unlock();
+
+#pragma mark - Declarations -
+
+// This macro simply declares and initializes our linked list
+static LIST_INIT(free_list);
+
+#pragma mark - Private Functions -
+
+/**
+ * When we free, we can take our node and check to see if any memory blocks
+ * can be combined into larger blocks.  This will help us fight against
+ * memory fragmentation in a simple way.
+ */
+void defrag_free_list(void)
+{
+	alloc_node_t* b = NULL;
+	alloc_node_t* lb = NULL;
+	alloc_node_t* t = NULL;
+
+	list_for_each_entry_safe(b, t, &free_list, node)
+	{
+		if(lb)
+		{
+			if((((uintptr_t)&lb->block) + lb->size) == (uintptr_t)b)
+			{
+				lb->size += sizeof(*b) + b->size;
+				list_del(&b->node);
+				continue;
+			}
+		}
+		lb = b;
+	}
+}
+
+#pragma mark - APIs -
+
+__attribute__((weak)) void malloc_init(void)
+{
+	// Unused here, override to specify your own init function
+	// Which includes malloc_addblock calls
+}
+
+__attribute__((weak)) void malloc_lock()
+{
+	// Intentional no-op
+}
+
+__attribute__((weak)) void malloc_unlock()
+{
+	// Intentional no-op
+}
+
+void* malloc(size_t size)
+{
+	void* ptr = NULL;
+	alloc_node_t* blk = NULL;
+
+	if(size > 0)
+	{
+		// Align the pointer
+		size = align_up(size, sizeof(void*));
+
+		malloc_lock();
+
+		// try to find a big enough block to alloc
+		list_for_each_entry(blk, &free_list, node)
+		{
+			if(blk->size >= size)
+			{
+				ptr = &blk->block;
+				break;
+			}
+		}
+
+		// we found something
+		if(ptr)
+		{
+			// Can we split the block?
+			if((blk->size - size) >= MIN_ALLOC_SZ)
+			{
+				alloc_node_t* new_blk = (alloc_node_t*)((uintptr_t)(&blk->block) + size);
+				new_blk->size = blk->size - size - ALLOC_HEADER_SZ;
+				blk->size = size;
+				list_insert(&new_blk->node, &blk->node, blk->node.next);
+			}
+
+			list_del(&blk->node);
+		}
+
+		malloc_unlock();
+
+	} // else NULL
+
+	return ptr;
+}
+
+void free(void* ptr)
+{
+	// Don't free a NULL pointer..
+	if(ptr)
+	{
+		// we take the pointer and use container_of to get the corresponding alloc block
+		alloc_node_t* blk = container_of(ptr, alloc_node_t, block);
+		alloc_node_t* free_blk = NULL;
+
+		malloc_lock();
+
+		// Let's put it back in the proper spot
+		list_for_each_entry(free_blk, &free_list, node)
+		{
+			if(free_blk > blk)
+			{
+				list_insert(&blk->node, free_blk->node.prev, &free_blk->node);
+				goto blockadded;
+			}
+		}
+		list_add_tail(&blk->node, &free_list);
+
+	blockadded:
+		// Let's see if we can combine any memory
+		defrag_free_list();
+
+		malloc_unlock();
+	}
+}
+
+void malloc_addblock(void* addr, size_t size)
+{
+	// let's align the start address of our block to the next pointer aligned number
+	alloc_node_t* blk = (void*)align_up((uintptr_t)addr, sizeof(void*));
+
+	// calculate actual size - remove our alignment and our header space from the availability
+	blk->size = (uintptr_t)addr + size - (uintptr_t)blk - ALLOC_HEADER_SZ;
+
+	// and now our giant block of memory is added to the list!
+	malloc_lock();
+	list_add(&blk->node, &free_list);
+	malloc_unlock();
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freertos.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freertos.c
index c6277a5..4210536 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freertos.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_freertos.c	
@@ -1,136 +1,136 @@
-/*
- * Copyright © 2018 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <assert.h>
-#include <freertos/FreeRTOS.h>
-#include <freertos/task.h>
-#include <malloc.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdlib.h>
-
-/**
- * NOTE: This FreeRTOS malloc implementation requires heap_5.c
- *
- * Please define the correct heap_region for your project.
- */
-
-#pragma mark - Definitions
-
-/**
- * Your application can define this macro to increase the number of heap regions
- */
-#ifndef FREERTOS_HEAP_REGION_CNT
-#define FREERTOS_HEAP_REGION_CNT 2
-#endif
-
-#pragma mark - Declarations -
-
-/// Maximum number of heap regions that can be specified
-static const uint8_t heap_region_max = FREERTOS_HEAP_REGION_CNT;
-
-/// Current number of allocated heap regions
-static volatile uint8_t heap_region_cnt = 0;
-
-/**
- * FreeRTOS internal memory pool stucture when using heap_5.c
- *
- * The block with the lowest starting address should appear first in the array
- *
- * An additional block is allocated to serve as a NULL terminator
- */
-static HeapRegion_t heap_regions[FREERTOS_HEAP_REGION_CNT + 1];
-
-/**
- * Flag that is used in malloc() to cause competing threads to wait until
- * initialization is completed before allocating memory.
- */
-static volatile bool initialized_ = false;
-
-#pragma mark - Private Functions -
-
-static int cmp_heap(const void* a, const void* b)
-{
-	const HeapRegion_t* ua = a;
-	const HeapRegion_t* ub = b;
-
-	return ((ua->pucStartAddress < ub->pucStartAddress)
-				? -1
-				: ((ua->pucStartAddress != ub->pucStartAddress)));
-}
-
-/**
- * malloc_addblock must be called before memory allocation calls are made.
- * In this FreeRTOS implementation, malloc() calls will block until memory
- * has been allocated
- */
-void malloc_addblock(void* addr, size_t size)
-{
-	assert(addr && (size > 0));
-	assert((heap_region_cnt < heap_region_max) && "Too many heap regions!");
-
-	// Increment the count early to claim a spot in case of multi-threads
-	uint8_t cnt = heap_region_cnt++;
-
-	if(cnt < heap_region_max)
-	{
-		// We have space - add it to the table
-		heap_regions[cnt].pucStartAddress = (uint8_t*)addr;
-		heap_regions[cnt].xSizeInBytes = size;
-	}
-	else
-	{
-		// Decrement the count if we don't have space
-		heap_region_cnt--;
-	}
-}
-
-__attribute__((weak)) void malloc_init()
-{
-	assert((heap_region_cnt > 0) && !initialized_);
-
-	if(heap_region_cnt > 0 && !initialized_)
-	{
-		// Sort the heap regions so addresses are in the correct order
-		qsort(heap_regions, heap_region_cnt, sizeof(HeapRegion_t), cmp_heap);
-
-		// Pass the array into vPortDefineHeapRegions() to enable malloc()
-		vPortDefineHeapRegions(heap_regions);
-
-		// Signal to any waiting threads that we are done initializing
-		initialized_ = true;
-	}
-}
-
-void* malloc(size_t size)
-{
-	void* ptr = NULL;
-
-	while(!initialized_)
-	{
-		// Thread blocks until application malloc has been correctly initialized
-		vTaskDelay(1);
-	}
-
-	if(size > 0)
-	{
-		// We simply wrap the FreeRTOS call into a standard form
-		ptr = pvPortMalloc(size);
-	} // else NULL if there was an error
-
-	return ptr;
-}
-
-void free(void* ptr)
-{
-	/// free should NEVER be called before malloc is init'd
-	assert(initialized_);
-
-	if(ptr)
-	{
-		// We simply wrap the FreeRTOS call into a standard form
-		vPortFree(ptr);
-	}
-}
+/*
+ * Copyright © 2018 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <assert.h>
+#include <freertos/FreeRTOS.h>
+#include <freertos/task.h>
+#include <malloc.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+/**
+ * NOTE: This FreeRTOS malloc implementation requires heap_5.c
+ *
+ * Please define the correct heap_region for your project.
+ */
+
+#pragma mark - Definitions
+
+/**
+ * Your application can define this macro to increase the number of heap regions
+ */
+#ifndef FREERTOS_HEAP_REGION_CNT
+#define FREERTOS_HEAP_REGION_CNT 2
+#endif
+
+#pragma mark - Declarations -
+
+/// Maximum number of heap regions that can be specified
+static const uint8_t heap_region_max = FREERTOS_HEAP_REGION_CNT;
+
+/// Current number of allocated heap regions
+static volatile uint8_t heap_region_cnt = 0;
+
+/**
+ * FreeRTOS internal memory pool stucture when using heap_5.c
+ *
+ * The block with the lowest starting address should appear first in the array
+ *
+ * An additional block is allocated to serve as a NULL terminator
+ */
+static HeapRegion_t heap_regions[FREERTOS_HEAP_REGION_CNT + 1];
+
+/**
+ * Flag that is used in malloc() to cause competing threads to wait until
+ * initialization is completed before allocating memory.
+ */
+static volatile bool initialized_ = false;
+
+#pragma mark - Private Functions -
+
+static int cmp_heap(const void* a, const void* b)
+{
+	const HeapRegion_t* ua = a;
+	const HeapRegion_t* ub = b;
+
+	return ((ua->pucStartAddress < ub->pucStartAddress)
+				? -1
+				: ((ua->pucStartAddress != ub->pucStartAddress)));
+}
+
+/**
+ * malloc_addblock must be called before memory allocation calls are made.
+ * In this FreeRTOS implementation, malloc() calls will block until memory
+ * has been allocated
+ */
+void malloc_addblock(void* addr, size_t size)
+{
+	assert(addr && (size > 0));
+	assert((heap_region_cnt < heap_region_max) && "Too many heap regions!");
+
+	// Increment the count early to claim a spot in case of multi-threads
+	uint8_t cnt = heap_region_cnt++;
+
+	if(cnt < heap_region_max)
+	{
+		// We have space - add it to the table
+		heap_regions[cnt].pucStartAddress = (uint8_t*)addr;
+		heap_regions[cnt].xSizeInBytes = size;
+	}
+	else
+	{
+		// Decrement the count if we don't have space
+		heap_region_cnt--;
+	}
+}
+
+__attribute__((weak)) void malloc_init()
+{
+	assert((heap_region_cnt > 0) && !initialized_);
+
+	if(heap_region_cnt > 0 && !initialized_)
+	{
+		// Sort the heap regions so addresses are in the correct order
+		qsort(heap_regions, heap_region_cnt, sizeof(HeapRegion_t), cmp_heap);
+
+		// Pass the array into vPortDefineHeapRegions() to enable malloc()
+		vPortDefineHeapRegions(heap_regions);
+
+		// Signal to any waiting threads that we are done initializing
+		initialized_ = true;
+	}
+}
+
+void* malloc(size_t size)
+{
+	void* ptr = NULL;
+
+	while(!initialized_)
+	{
+		// Thread blocks until application malloc has been correctly initialized
+		vTaskDelay(1);
+	}
+
+	if(size > 0)
+	{
+		// We simply wrap the FreeRTOS call into a standard form
+		ptr = pvPortMalloc(size);
+	} // else NULL if there was an error
+
+	return ptr;
+}
+
+void free(void* ptr)
+{
+	/// free should NEVER be called before malloc is init'd
+	assert(initialized_);
+
+	if(ptr)
+	{
+		// We simply wrap the FreeRTOS call into a standard form
+		vPortFree(ptr);
+	}
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_threadx.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_threadx.c
index d65c8ab..551c0fb 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_threadx.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/malloc_threadx.c	
@@ -1,88 +1,88 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <assert.h>
-#include <malloc.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <threadx/tx_api.h>
-
-#pragma mark - Declarations -
-
-/// ThreadX internal memory pool stucture
-static TX_BYTE_POOL malloc_pool_;
-
-/**
- * Flag that is used in malloc() to cause competing threads to wait until
- * initialization is completed before allocating memory.
- */
-static volatile bool initialized_ = false;
-
-#pragma mark - APIs -
-
-__attribute__((weak)) void malloc_init(void)
-{
-	// Unused here, override to specify your own init functin
-	// Which includes malloc_addblock calls
-}
-
-/**
- * malloc_addblock must be called before memory allocation calls are made.
- * In this ThreadX implementation, malloc() calls will block until memory
- * has been allocated
- */
-void malloc_addblock(void* addr, size_t size)
-{
-	assert(addr && (size > 0));
-
-	/*
-	 * tx_byte_pool_create is ThreadX's API to create a byte pool using a memory block.
-	 * We are essentially just wrapping ThreadX APIs into a simpler form
-	 */
-	unsigned r = tx_byte_pool_create(&malloc_pool_, "Heap Memory Pool", addr, size);
-	assert(r == TX_SUCCESS);
-
-	// Signal to any threads waiting on do_malloc that we are done
-	initialized_ = true;
-}
-
-void* malloc(size_t size)
-{
-	void* ptr = NULL;
-
-	/**
-	 * In the ThreadX implementaiton, we make sure the ThreadX pool has been
-	 * created before we try to allocate memory, or there will be an error.
-	 * We sleep our threads until memory has been added.
-	 */
-	while(!initialized_)
-	{
-		tx_thread_sleep(1);
-	}
-
-	if(size > 0)
-	{
-		// We simply wrap the threadX call into a standard form
-		unsigned r = tx_byte_allocate(&malloc_pool_, &ptr, size, TX_WAIT_FOREVER);
-
-		// I add the string to provide a more helpful error output.  It's value is always true.
-		assert(r == TX_SUCCESS && "malloc failed");
-	} // else NULL if there was an error
-
-	return ptr;
-}
-
-void free(void* ptr)
-{
-	/// free should NEVER be called before malloc is init'd
-	assert(initialized_);
-
-	if(ptr)
-	{
-		// We simply wrap the threadX call into a standard form
-		unsigned r = tx_byte_release(ptr);
-		assert(r == TX_SUCCESS);
-	}
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <assert.h>
+#include <malloc.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <threadx/tx_api.h>
+
+#pragma mark - Declarations -
+
+/// ThreadX internal memory pool stucture
+static TX_BYTE_POOL malloc_pool_;
+
+/**
+ * Flag that is used in malloc() to cause competing threads to wait until
+ * initialization is completed before allocating memory.
+ */
+static volatile bool initialized_ = false;
+
+#pragma mark - APIs -
+
+__attribute__((weak)) void malloc_init(void)
+{
+	// Unused here, override to specify your own init functin
+	// Which includes malloc_addblock calls
+}
+
+/**
+ * malloc_addblock must be called before memory allocation calls are made.
+ * In this ThreadX implementation, malloc() calls will block until memory
+ * has been allocated
+ */
+void malloc_addblock(void* addr, size_t size)
+{
+	assert(addr && (size > 0));
+
+	/*
+	 * tx_byte_pool_create is ThreadX's API to create a byte pool using a memory block.
+	 * We are essentially just wrapping ThreadX APIs into a simpler form
+	 */
+	unsigned r = tx_byte_pool_create(&malloc_pool_, "Heap Memory Pool", addr, size);
+	assert(r == TX_SUCCESS);
+
+	// Signal to any threads waiting on do_malloc that we are done
+	initialized_ = true;
+}
+
+void* malloc(size_t size)
+{
+	void* ptr = NULL;
+
+	/**
+	 * In the ThreadX implementaiton, we make sure the ThreadX pool has been
+	 * created before we try to allocate memory, or there will be an error.
+	 * We sleep our threads until memory has been added.
+	 */
+	while(!initialized_)
+	{
+		tx_thread_sleep(1);
+	}
+
+	if(size > 0)
+	{
+		// We simply wrap the threadX call into a standard form
+		unsigned r = tx_byte_allocate(&malloc_pool_, &ptr, size, TX_WAIT_FOREVER);
+
+		// I add the string to provide a more helpful error output.  It's value is always true.
+		assert(r == TX_SUCCESS && "malloc failed");
+	} // else NULL if there was an error
+
+	return ptr;
+}
+
+void free(void* ptr)
+{
+	/// free should NEVER be called before malloc is init'd
+	assert(initialized_);
+
+	if(ptr)
+	{
+		// We simply wrap the threadX call into a standard form
+		unsigned r = tx_byte_release(ptr);
+		assert(r == TX_SUCCESS);
+	}
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/posix_memalign.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/posix_memalign.c
index 996a85e..b81240e 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/posix_memalign.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/src/posix_memalign.c	
@@ -1,31 +1,31 @@
-#include <aligned_malloc.h>
-#include <assert.h>
-#include <errno.h>
-#include <stddef.h>
-
-#define IS_POWER_2(x) (!((x) & ((x)-1)))
-
-int posix_memalign(void** __memptr, size_t __alignment, size_t __size)
-{
-	int r = ENOMEM;
-
-	assert(__memptr);
-	assert(__size > 0);
-
-	// TODO: Do we need to check if __alignment is a multiple of sizeof(void *)?
-	if(!IS_POWER_2(__alignment))
-	{
-		r = EINVAL;
-	}
-	else
-	{
-		*__memptr = aligned_malloc(__alignment, __size);
-
-		if(*__memptr != NULL)
-		{
-			r = 0;
-		}
-	}
-
-	return r;
-}
+#include <aligned_malloc.h>
+#include <assert.h>
+#include <errno.h>
+#include <stddef.h>
+
+#define IS_POWER_2(x) (!((x) & ((x)-1)))
+
+int posix_memalign(void** __memptr, size_t __alignment, size_t __size)
+{
+	int r = ENOMEM;
+
+	assert(__memptr);
+	assert(__size > 0);
+
+	// TODO: Do we need to check if __alignment is a multiple of sizeof(void *)?
+	if(!IS_POWER_2(__alignment))
+	{
+		r = EINVAL;
+	}
+	else
+	{
+		*__memptr = aligned_malloc(__alignment, __size);
+
+		if(*__memptr != NULL)
+		{
+			r = 0;
+		}
+	}
+
+	return r;
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/README.md b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/README.md
index 18918e7..8e74d7e 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/README.md	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/README.md	
@@ -1 +1 @@
-The `test` folder contains tests and testing frameworks.
+The `test` folder contains tests and testing frameworks.
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/main.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/main.c
index 7cc0cd6..1995d3d 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/main.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/main.c	
@@ -1,36 +1,36 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <support/memory.h>
-#include <tests.h>
-
-// CMocka needs these
-// clang-format off
-#include <setjmp.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <cmocka.h>
-// clang-format on
-
-int main(void)
-{
-	int overall_result = 0;
-
-	// Generate JUnit results
-	cmocka_set_message_output(CM_OUTPUT_XML);
-
-	/*
-	 * For this test framework, we need to allocate a block of memory before
-	 * we run cmocka commands, otherwise they will fail since malloc cannot
-	 * allocate anything
-	 */
-	allocate_memory();
-
-	overall_result |= malloc_tests();
-
-	overall_result |= aligned_malloc_tests();
-
-	return overall_result;
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <support/memory.h>
+#include <tests.h>
+
+// CMocka needs these
+// clang-format off
+#include <setjmp.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <cmocka.h>
+// clang-format on
+
+int main(void)
+{
+	int overall_result = 0;
+
+	// Generate JUnit results
+	cmocka_set_message_output(CM_OUTPUT_XML);
+
+	/*
+	 * For this test framework, we need to allocate a block of memory before
+	 * we run cmocka commands, otherwise they will fail since malloc cannot
+	 * allocate anything
+	 */
+	allocate_memory();
+
+	overall_result |= malloc_tests();
+
+	overall_result |= aligned_malloc_tests();
+
+	return overall_result;
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/aligned_malloc.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/aligned_malloc.c
index 328984e..6c0c823 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/aligned_malloc.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/aligned_malloc.c	
@@ -1,95 +1,95 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <aligned_malloc.h>
-#include <errno.h>
-#include <support/memory.h>
-#include <tests.h>
-
-// CMocka needs these
-// clang-format off
-#include <setjmp.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <cmocka.h>
-// clang-format on
-
-static void aligned_malloc_test(void** __attribute__((unused)) state)
-{
-	// Make sure memory was previously allocated
-	if(!memory_allocated())
-	{
-		allocate_memory();
-	}
-
-	assert_true(memory_allocated());
-
-	uintptr_t mem_block_addr = block_start_addr();
-	uintptr_t mem_block_end_addr = block_end_addr();
-
-	for(size_t align = 2; align <= 8192; align *= 2)
-	{
-		void* ptr = aligned_malloc(align, 32);
-		assert_non_null(ptr);
-		assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
-		assert_false(((uintptr_t)ptr) & (align - 1));
-		aligned_free(ptr);
-	}
-
-	// Run again, make sure malloc does not fail and memory was really freed
-	for(size_t align = 2; align <= 8192; align *= 2)
-	{
-		void* ptr = aligned_malloc(align, 32);
-		assert_non_null(ptr);
-		assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
-		assert_false(((uintptr_t)ptr) & (align - 1));
-		aligned_free(ptr);
-	}
-
-	// We can have one byte alignment - check
-	void* ptr = aligned_malloc(1, 1024);
-	assert_non_null(ptr);
-	aligned_free(ptr);
-
-	// Check bad input
-	ptr = aligned_malloc(0, 1024);
-	assert_null(ptr);
-}
-
-// Might be unused in the case that AddressSanitizer is enabled
-__attribute__((unused)) static void posix_memalign_test(void** __attribute__((unused)) state)
-{
-	void* ptr = NULL;
-	int r = posix_memalign(&ptr, 8, 8);
-	assert_non_null(ptr);
-	assert_int_equal(r, 0);
-
-	aligned_free(ptr);
-	ptr = NULL;
-
-	r = posix_memalign(&ptr, 3, 8);
-	assert_null(ptr);
-	assert_int_equal(r, EINVAL);
-}
-
-int aligned_malloc_tests(void)
-{
-	const struct CMUnitTest aligned_malloc_tests[] = {
-		cmocka_unit_test(aligned_malloc_test),
-	// POSIX Memalign tests have problems with address sanitizer b/c it replaces our memalign
-	// with their memalign, but we call aligned free.. triggering a failure.
-#if !defined(__SANITIZE_ADDRESS__)
-#if defined(__has_feature)
-#if !__has_feature(address_sanitizer)
-		cmocka_unit_test(posix_memalign_test),
-#endif
-#else // no __has_feature, trust __SANITIZE_ADDRESS__
-		cmocka_unit_test(posix_memalign_test),
-#endif
-#endif
-	};
-
-	return cmocka_run_group_tests(aligned_malloc_tests, NULL, NULL);
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <aligned_malloc.h>
+#include <errno.h>
+#include <support/memory.h>
+#include <tests.h>
+
+// CMocka needs these
+// clang-format off
+#include <setjmp.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <cmocka.h>
+// clang-format on
+
+static void aligned_malloc_test(void** __attribute__((unused)) state)
+{
+	// Make sure memory was previously allocated
+	if(!memory_allocated())
+	{
+		allocate_memory();
+	}
+
+	assert_true(memory_allocated());
+
+	uintptr_t mem_block_addr = block_start_addr();
+	uintptr_t mem_block_end_addr = block_end_addr();
+
+	for(size_t align = 2; align <= 8192; align *= 2)
+	{
+		void* ptr = aligned_malloc(align, 32);
+		assert_non_null(ptr);
+		assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
+		assert_false(((uintptr_t)ptr) & (align - 1));
+		aligned_free(ptr);
+	}
+
+	// Run again, make sure malloc does not fail and memory was really freed
+	for(size_t align = 2; align <= 8192; align *= 2)
+	{
+		void* ptr = aligned_malloc(align, 32);
+		assert_non_null(ptr);
+		assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
+		assert_false(((uintptr_t)ptr) & (align - 1));
+		aligned_free(ptr);
+	}
+
+	// We can have one byte alignment - check
+	void* ptr = aligned_malloc(1, 1024);
+	assert_non_null(ptr);
+	aligned_free(ptr);
+
+	// Check bad input
+	ptr = aligned_malloc(0, 1024);
+	assert_null(ptr);
+}
+
+// Might be unused in the case that AddressSanitizer is enabled
+__attribute__((unused)) static void posix_memalign_test(void** __attribute__((unused)) state)
+{
+	void* ptr = NULL;
+	int r = posix_memalign(&ptr, 8, 8);
+	assert_non_null(ptr);
+	assert_int_equal(r, 0);
+
+	aligned_free(ptr);
+	ptr = NULL;
+
+	r = posix_memalign(&ptr, 3, 8);
+	assert_null(ptr);
+	assert_int_equal(r, EINVAL);
+}
+
+int aligned_malloc_tests(void)
+{
+	const struct CMUnitTest aligned_malloc_tests[] = {
+		cmocka_unit_test(aligned_malloc_test),
+	// POSIX Memalign tests have problems with address sanitizer b/c it replaces our memalign
+	// with their memalign, but we call aligned free.. triggering a failure.
+#if !defined(__SANITIZE_ADDRESS__)
+#if defined(__has_feature)
+#if !__has_feature(address_sanitizer)
+		cmocka_unit_test(posix_memalign_test),
+#endif
+#else // no __has_feature, trust __SANITIZE_ADDRESS__
+		cmocka_unit_test(posix_memalign_test),
+#endif
+#endif
+	};
+
+	return cmocka_run_group_tests(aligned_malloc_tests, NULL, NULL);
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/malloc_freelist.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/malloc_freelist.c
index bd90ac8..42dedd4 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/malloc_freelist.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/src/malloc_freelist.c	
@@ -1,81 +1,81 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <malloc.h>
-#include <stdint.h>
-#include <support/memory.h>
-#include <tests.h>
-
-// CMocka needs these
-// clang-format off
-#include <setjmp.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <cmocka.h>
-// clang-format on
-
-#define ALLOCATION_TEST_COUNT 768
-
-static void* p[ALLOCATION_TEST_COUNT];
-
-static void malloc_test(void** __attribute__((unused)) state)
-{
-	// Make sure memory was previously allocated
-	if(!memory_allocated())
-	{
-		allocate_memory();
-	}
-
-	assert_true(memory_allocated());
-
-	uintptr_t mem_block_addr = block_start_addr();
-	uintptr_t mem_block_end_addr = block_end_addr();
-	size_t mem_block_size = block_size();
-
-	void* ptr = malloc(1024);
-
-	assert_non_null(ptr);
-	assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
-
-	free(ptr);
-
-	// Check request too large
-	ptr = malloc(2 * mem_block_size);
-	assert_null(ptr);
-
-	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
-	{
-		p[i] = malloc(1024);
-		assert_non_null(p[i]);
-		assert_in_range((uintptr_t)p[i], mem_block_addr, mem_block_end_addr);
-	}
-
-	// Cleanup
-	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
-	{
-		free(p[i]);
-	}
-
-	// Run test again, will not fail if our memory has been returned!
-	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
-	{
-		p[i] = malloc(1024);
-		assert_non_null(p[i]);
-		assert_in_range((uintptr_t)p[i], mem_block_addr, mem_block_end_addr);
-	}
-
-	// Cleanup
-	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
-	{
-		free(p[i]);
-	}
-}
-
-int malloc_tests(void)
-{
-	const struct CMUnitTest malloc_test_suite[] = {cmocka_unit_test(malloc_test)};
-
-	return cmocka_run_group_tests(malloc_test_suite, NULL, NULL);
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <malloc.h>
+#include <stdint.h>
+#include <support/memory.h>
+#include <tests.h>
+
+// CMocka needs these
+// clang-format off
+#include <setjmp.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <cmocka.h>
+// clang-format on
+
+#define ALLOCATION_TEST_COUNT 768
+
+static void* p[ALLOCATION_TEST_COUNT];
+
+static void malloc_test(void** __attribute__((unused)) state)
+{
+	// Make sure memory was previously allocated
+	if(!memory_allocated())
+	{
+		allocate_memory();
+	}
+
+	assert_true(memory_allocated());
+
+	uintptr_t mem_block_addr = block_start_addr();
+	uintptr_t mem_block_end_addr = block_end_addr();
+	size_t mem_block_size = block_size();
+
+	void* ptr = malloc(1024);
+
+	assert_non_null(ptr);
+	assert_in_range((uintptr_t)ptr, mem_block_addr, mem_block_end_addr);
+
+	free(ptr);
+
+	// Check request too large
+	ptr = malloc(2 * mem_block_size);
+	assert_null(ptr);
+
+	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
+	{
+		p[i] = malloc(1024);
+		assert_non_null(p[i]);
+		assert_in_range((uintptr_t)p[i], mem_block_addr, mem_block_end_addr);
+	}
+
+	// Cleanup
+	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
+	{
+		free(p[i]);
+	}
+
+	// Run test again, will not fail if our memory has been returned!
+	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
+	{
+		p[i] = malloc(1024);
+		assert_non_null(p[i]);
+		assert_in_range((uintptr_t)p[i], mem_block_addr, mem_block_end_addr);
+	}
+
+	// Cleanup
+	for(int i = 0; i < ALLOCATION_TEST_COUNT; i++)
+	{
+		free(p[i]);
+	}
+}
+
+int malloc_tests(void)
+{
+	const struct CMUnitTest malloc_test_suite[] = {cmocka_unit_test(malloc_test)};
+
+	return cmocka_run_group_tests(malloc_test_suite, NULL, NULL);
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.c b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.c
index a9b35fc..8ffed10 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.c	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.c	
@@ -1,43 +1,43 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#include <malloc.h>
-#include <support/memory.h>
-
-#define MEM_BLOCK_SIZE (1024 * 1024)
-
-static volatile bool allocated = false;
-static const size_t memblock_size = MEM_BLOCK_SIZE;
-static uint8_t mem_block[MEM_BLOCK_SIZE];
-static const uintptr_t mem_block_addr = (uintptr_t)mem_block;
-
-void allocate_memory()
-{
-	if(!allocated)
-	{
-		malloc_addblock(mem_block, memblock_size);
-		allocated = true;
-	}
-}
-
-bool memory_allocated()
-{
-	return allocated;
-}
-
-uintptr_t block_start_addr()
-{
-	return mem_block_addr;
-}
-
-uintptr_t block_end_addr()
-{
-	return mem_block_addr + MEM_BLOCK_SIZE;
-}
-
-size_t block_size()
-{
-	return memblock_size;
-}
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#include <malloc.h>
+#include <support/memory.h>
+
+#define MEM_BLOCK_SIZE (1024 * 1024)
+
+static volatile bool allocated = false;
+static const size_t memblock_size = MEM_BLOCK_SIZE;
+static uint8_t mem_block[MEM_BLOCK_SIZE];
+static const uintptr_t mem_block_addr = (uintptr_t)mem_block;
+
+void allocate_memory()
+{
+	if(!allocated)
+	{
+		malloc_addblock(mem_block, memblock_size);
+		allocated = true;
+	}
+}
+
+bool memory_allocated()
+{
+	return allocated;
+}
+
+uintptr_t block_start_addr()
+{
+	return mem_block_addr;
+}
+
+uintptr_t block_end_addr()
+{
+	return mem_block_addr + MEM_BLOCK_SIZE;
+}
+
+size_t block_size()
+{
+	return memblock_size;
+}
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.h
index 46586c9..c2b5611 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/support/memory.h	
@@ -1,27 +1,27 @@
-/*
- * Copyright © 2017 Embedded Artistry LLC.
- * License: MIT. See LICENSE file for details.
- */
-
-#ifndef MEMORY_SUPPORT_H_
-#define MEMORY_SUPPORT_H_
-
-#include <stdbool.h>
-#include <stddef.h>
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif //__cplusplus
-
-void allocate_memory(void);
-uintptr_t block_start_addr(void);
-size_t block_size(void);
-uintptr_t block_end_addr(void);
-bool memory_allocated(void);
-
-#ifdef __cplusplus
-}
-#endif //__cplusplus
-
-#endif // MEMORY_SUPPORT_H_
+/*
+ * Copyright © 2017 Embedded Artistry LLC.
+ * License: MIT. See LICENSE file for details.
+ */
+
+#ifndef MEMORY_SUPPORT_H_
+#define MEMORY_SUPPORT_H_
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif //__cplusplus
+
+void allocate_memory(void);
+uintptr_t block_start_addr(void);
+size_t block_size(void);
+uintptr_t block_end_addr(void);
+bool memory_allocated(void);
+
+#ifdef __cplusplus
+}
+#endif //__cplusplus
+
+#endif // MEMORY_SUPPORT_H_
diff --git a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/tests.h b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/tests.h
index b31ee6b..f74161e 100644
--- a/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/tests.h	
+++ b/Introduction to Build Systems Using Make/Software Construction/libmemory-source/test/tests.h	
@@ -1,7 +1,7 @@
-#ifndef TEST_H__
-#define TEST_H__
-
-int malloc_tests(void);
-int aligned_malloc_tests(void);
-
-#endif // TEST_H_
+#ifndef TEST_H__
+#define TEST_H__
+
+int malloc_tests(void);
+int aligned_malloc_tests(void);
+
+#endif // TEST_H_
